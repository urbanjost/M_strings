." Text automatically generated by txt2man
.TH "delim" "3m_strings" "September 10, 2021" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.SH NAME
\fBdelim\fP(3f) - [M_strings:TOKENS] parse a string and store tokens into
an array
(LICENSE:PD)

.SH SYNOPSIS
subroutine \fBdelim\fP(line,array,n,icount,ibegin,iterm,lgth,dlim)
.PP
.nf
.fam C
    character(len=*),intent(in)  :: line
    integer,integer(in)          :: n
    integer,intent(out)          :: icount
    character(len=*)             :: array(n)
    integer,intent(out)          :: ibegin(n)
    integer,intent(out)          :: iterm(n)
    integer,intent(out)          :: lgth
    character(len=*)             :: dlim

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
Given a LINE of structure " par1 par2 par3 \.\.\. parn "
store each \fBpar\fP(n) into a separate variable in ARRAY (UNLESS
\fBARRAY\fP(1).eq.'#N#')
.PP
Also set ICOUNT to number of elements of array initialized, and
return beginning and ending positions for each element in \fBIBEGIN\fP(N)
and \fBITERM\fP(N).
.PP
Return position of last non-blank character (even if more
than N elements were found) in lgth
.PP
No quoting or escaping of delimiter is allowed, so the delimiter
character can not be placed in a token.
.PP
No checking for more than N parameters; If any more they are ignored.
.SH OPTIONS
.TP
.B LINE
input string to parse into tokens
.TP
.B \fBARRAY\fP(N)
array that receives tokens
.TP
.B N
size of arrays ARRAY, IBEGIN, ITERM
.TP
.B ICOUNT
number of tokens found
\fBIBEGIN\fP(N) starting columns of tokens found
.TP
.B \fBITERM\fP(N)
ending columns of tokens found
.TP
.B LGTH
position of last non-blank character in input string LINE
.TP
.B DLIM
delimiter characters
.SH EXAMPLES
Sample program:
.PP
.nf
.fam C
    program demo_delim

    use M_strings, only: delim
    implicit none
    character(len=80) :: line
    character(len=80) :: dlm
    integer,parameter :: n=10
    character(len=20) :: array(n)=' '
    integer           :: ibegin(n),iterm(n)
    integer           :: i20, icount, lgth, i10
    line=' first  second 10.3 words_of_stuff  '
    do i20=1,4
       ! change delimiter list and what is calculated or parsed
       if(i20.eq.1)dlm=' '
       if(i20.eq.2)dlm='o'
       if(i20.eq.3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
       if(i20.eq.3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
       if(i20.eq.4)line='AAAaBBBBBBbIIIIIi  J K L'

       ! write out a break line composed of =========== ..
       write(*,'(57("="))')
       ! show line being parsed
       write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
       ! call parsing procedure
       call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
       write(*,*)'number of tokens found=',icount
       write(*,*)'last character in column ',lgth
       if(icount.gt.0)then
          if(lgth.ne.iterm(icount))then
             write(*,*)'ignored from column ',iterm(icount)+1,' to ',lgth
          endif
          do i10=1,icount
             ! check flag to see if ARRAY() was set
             if(array(1).ne.'#N#')then
                ! from returned array
                write(*,'(a,a,a)',advance='no')&
                &'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
             endif
          enddo
          ! using start and end positions in IBEGIN() and ITERM()
          write(*,*)
          do i10=1,icount
             ! from positions in original line
             write(*,'(a,a,a)',advance='no')&
             &'[',line(ibegin(i10):iterm(i10)),']'
          enddo
          write(*,*)
       endif
    enddo
    end program demo_delim

.fam T
.fi
Expected output
.SH AUTHOR
John S. Urban
.SH LICENSE
Public Domain
