<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for Cygwin (vers 25 March 2009), see www.w3.org" />

  <title></title>
  <style type="text/css">
/*<![CDATA[*/

  px {font-family: "Lucida Console", Monaco, monospace}
  p { font-size:100%; line-height:1.1em; }
  body {xfont-style: sans-serif}
  body {
  color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
  a:visited { color:#666; }
  h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
  h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
  h2 { font-size:143%;color:teal; }
  h3 { font-size:134%;color:blue; }
  h4 { font-size:120%;color:gray; }
  img { max-width: 55em}
  p{ padding: 0;margin:0; }
  p{ padding-right:1.4em; }
  p{ padding-bottom:1em; }
  p{ padding-top:1em; }
  p{ whitespace: pre-wrap; }
  h5,h6 { font-size:100% }
  a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
  XXtable { border:double #000; border-collapse:collapse; }
  XXtable { border-collapse:collapse; }
  XXtd { border:thin solid #888; }
  XXtd { border:none; }
  li { margin-bottom:0.5em; }
  blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
  pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
  a,li span { color:#000; }
  a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
  #Container { margin:0 10px; text-align:center; background-color: #BBB}
  #Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
  span.webName { font-size:.5em; }
  textarea#content { font-size: 1em; line-height: 1.125; }
  h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
  .property { color:#666; font-size:100%; }
  a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
  .byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
  /*]]>*/
  </style>
  <style type="text/css">
/*<![CDATA[*/
  body {
  background-color: #F0F0F0;
  color: #000000;
  }
  :link { color: #0000FF }
  :visited { color: #C000C0 }
  :active { color: #FF0000 }
  span.c96 {font-size: 80%}
  td.c95 {font-weight: bold}
  td.c94 {font-style: italic}
  div.c93 {text-align: center}
  /*]]>*/
  </style>
</head>

<body>
  <a name="top"></a>

  <h5><a href="download.html">[UP]</a></h5>

  <div id="Container">
    <div id="Content">
      <div class="c93">
        <hr />

        <h1><i>Manual Reference Pages  - </i>matchw&nbsp;(3)</h1>
        <hr />
      </div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>matchw(3f)</b> - [M_strings:COMPARE] compare given string for match to pattern which may contain wildcard characters <b>(LICENSE:PD)</b>
      </blockquote><a name="contents"></a>

      <h3>CONTENTS</h3>

      <blockquote>
        <a href="#1">Synopsis</a><br />
        <a href="#2">Description</a><br />
        <a href="#3">Options</a><br />
        <a href="#4">Examples</a><br />
        <a href="#5">Author</a><br />
        <a href="#6">Reference</a><br />
        <a href="#7">License</a><br />
      </blockquote><a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>matchw</b>(<i>string</i>, pattern )
<br />
    character(len=*),intent(in) :: string
    character(len=*),intent(in) :: pattern
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p><b>matchw</b>(3f) compares given <i>string</i> for match to pattern which may contain wildcard characters.</p>

        <p>In this version to get a match entire <i>string</i> must be described by pattern. Trailing whitespace is significant, so trim the input
        <i>string</i> to have trailing whitespace ignored.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c94" width="6%" nowrap="nowrap">string</td>

            <td valign="bottom">the input <i>string</i> to test to see if it contains the pattern.</td>
          </tr>

          <tr valign="top">
            <td class="c95" colspan="2">pattern</td>
          </tr>

          <tr valign="top">
            <td width="6%"> </td>

            <td>
              the following simple globbing options are available

              <table width="100%" cellpadding="3">
                <!-- tsb: the following simple globbing options are available
 -->

                <tr>
                  <td></td>
                </tr>

                <tr>
                  <td></td>
                </tr>

                <tr valign="top">
                  <td class="c95" width="6%" nowrap="nowrap">o</td>

                  <td valign="bottom">"?" matching any one character</td>
                </tr>

                <tr valign="top">
                  <td class="c95" width="6%" nowrap="nowrap">o</td>

                  <td valign="bottom">"*" matching zero or more characters. Do NOT use adjacent asterisks.</td>
                </tr>

                <tr valign="top">
                  <td class="c95" width="6%" nowrap="nowrap">o</td>

                  <td valign="bottom">Both strings may have trailing spaces which are ignored.</td>
                </tr>

                <tr valign="top">
                  <td class="c95" width="6%" nowrap="nowrap">o</td>

                  <td valign="bottom">There is no escape character, so matching strings with literal question mark and asterisk is problematic.</td>
                </tr>

                <tr>
                  <td></td>
                </tr>
              </table>
            </td>
          </tr>

          <tr>
            <td></td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLES</a></h3>

      <blockquote>
        Example program
        <pre>
   program demo_matchw
   implicit none
   ! This main() routine passes a bunch of test strings into the above code.
   ! In performance comparison mode, it does that over and over.  Otherwise,
   ! it does it just once.  Either way, it outputs a passed/failed result.
   !
   integer :: nReps
   logical :: allpassed
   integer :: i
    allpassed = .true.
<br />
    nReps = 10000
    nReps = 1     ! Can choose as many repetitions as you're expecting in the real world.
<br />
    do i=1,nReps
     ! Cases with repeating character sequences.
     allpassed=allpassed .and. test("a*abab", "a*b", .true.)
     !!cycle
     allpassed=allpassed .and. test("ab", "*?", .true.)
     allpassed=allpassed .and. test("abc", "*?", .true.)
     allpassed=allpassed .and. test("abcccd", "*ccd", .true.)
     allpassed=allpassed .and. test("bLah", "bLaH", .false.)
     allpassed=allpassed .and. test("mississippi", "*sip*", .true.)
     allpassed=allpassed .and. test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.)
     allpassed=allpassed .and. test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.)
     allpassed=allpassed .and. test("mississipissippi", "*issip*ss*", .true.)
     allpassed=allpassed .and. test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.)
     allpassed=allpassed .and. test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.)
     allpassed=allpassed .and. test("xyxyxyzyxyz", "xy*z*xyz", .true.)
     allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.)
     allpassed=allpassed .and. test("mississippi", "mi*sip*", .true.)
     allpassed=allpassed .and. test("ababac", "*abac*", .true.)
     allpassed=allpassed .and. test("aaazz", "a*zz*", .true.)
     allpassed=allpassed .and. test("a12b12", "*12*23", .false.)
     allpassed=allpassed .and. test("a12b12", "a12b", .false.)
     allpassed=allpassed .and. test("a12b12", "*12*12*", .true.)
<br />
     ! Additional cases where the '*' char appears in the tame string.
     allpassed=allpassed .and. test("*", "*", .true.)
     allpassed=allpassed .and. test("a*r", "a*", .true.)
     allpassed=allpassed .and. test("a*ar", "a*aar", .false.)
<br />
     ! More double wildcard scenarios.
     allpassed=allpassed .and. test("XYXYXYZYXYz", "XY*Z*XYz", .true.)
     allpassed=allpassed .and. test("missisSIPpi", "*SIP*", .true.)
     allpassed=allpassed .and. test("mississipPI", "*issip*PI", .true.)
     allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.)
     allpassed=allpassed .and. test("miSsissippi", "mi*sip*", .true.)
     allpassed=allpassed .and. test("miSsissippi", "mi*Sip*", .false.)
     allpassed=allpassed .and. test("abAbac", "*Abac*", .true.)
     allpassed=allpassed .and. test("aAazz", "a*zz*", .true.)
     allpassed=allpassed .and. test("A12b12", "*12*23", .false.)
     allpassed=allpassed .and. test("a12B12", "*12*12*", .true.)
     allpassed=allpassed .and. test("oWn", "*oWn*", .true.)
<br />
     ! Completely tame (no wildcards) cases.
     allpassed=allpassed .and. test("bLah", "bLah", .true.)
<br />
     ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
     allpassed=allpassed .and. test("a", "*?", .true.)
<br />
     ! More mixed wildcard tests including coverage for false positives.
     allpassed=allpassed .and. test("a", "??", .false.)
     allpassed=allpassed .and. test("ab", "?*?", .true.)
     allpassed=allpassed .and. test("ab", "*?*?*", .true.)
     allpassed=allpassed .and. test("abc", "?**?*?", .true.)
     allpassed=allpassed .and. test("abc", "?**?*&amp;?", .false.)
     allpassed=allpassed .and. test("abcd", "?b*??", .true.)
     allpassed=allpassed .and. test("abcd", "?a*??", .false.)
     allpassed=allpassed .and. test("abcd", "?**?c?", .true.)
     allpassed=allpassed .and. test("abcd", "?**?d?", .false.)
     allpassed=allpassed .and. test("abcde", "?*b*?*d*?", .true.)
<br />
     ! Single-character-match cases.
     allpassed=allpassed .and. test("bLah", "bL?h", .true.)
     allpassed=allpassed .and. test("bLaaa", "bLa?", .false.)
     allpassed=allpassed .and. test("bLah", "bLa?", .true.)
     allpassed=allpassed .and. test("bLaH", "?Lah", .false.)
     allpassed=allpassed .and. test("bLaH", "?LaH", .true.)
<br />
     ! Many-wildcard scenarios.
     allpassed=allpassed .and. test(&amp;
     &amp;"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&amp;
     &amp;"a*a*a*a*a*a*aa*aaa*a*a*b",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("aaabbaabbaab", "*aabbaa*a*", .true.)
     allpassed=allpassed .and. test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", "a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.)
     allpassed=allpassed .and. test("aaaaaaaaaaaaaaaaa", "*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.)
     allpassed=allpassed .and. test("aaaaaaaaaaaaaaaa", "*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp;
     &amp; "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp;
     &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("abc*abcd*abcd*abc*abcd", "abc*abc*abc*abc*abc", .false.)
     allpassed=allpassed .and. test( "abc*abcd*abcd*abc*abcd*abcd*abc*abcd*abc*abc*abcd", &amp;
     &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("abc", "********a********b********c********", .true.)
     allpassed=allpassed .and. test("********a********b********c********", "abc", .false.)
     allpassed=allpassed .and. test("abc", "********a********b********b********", .false.)
     allpassed=allpassed .and. test("*abc*", "***a*b*c***", .true.)
<br />
     ! A case-insensitive algorithm test.
     ! allpassed=allpassed .and. test("mississippi", "*issip*PI", .true.)
    enddo
<br />
    if (allpassed)then
       write(*,'(a)')"Passed",nReps
    else
       write(*,'(a)')"Failed"
    endif
   contains
   ! This is a test program for wildcard matching routines.  It can be used
   ! either to test a single routine for correctness, or to compare the timings
   ! of two (or more) different wildcard matching routines.
   !
   function test(tame, wild, bExpectedResult) result(bpassed)
   use M_strings, only : matchw
      character(len=*) :: tame
      character(len=*) :: wild
      logical          :: bExpectedResult
      logical          :: bResult
      logical          :: bPassed
      bResult = .true.    ! We'll do "&amp;=" cumulative checking.
      bPassed = .false.   ! Assume the worst.
      write(*,*)repeat('=',79)
      bResult = matchw(tame, wild) ! Call a wildcard matching routine.
<br />
      ! To assist correctness checking, output the two strings in any failing scenarios.
      if (bExpectedResult .eqv. bResult) then
         bPassed = .true.
         if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
      else
         if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
      endif
<br />
   end function test
   end program demo_matchw
<br />
</pre>Expected output
      </blockquote><a name="5"></a>

      <h3><a name="5">AUTHOR</a></h3>

      <blockquote>
        John S. Urban
      </blockquote><a name="6"></a>

      <h3><a name="6">REFERENCE</a></h3>

      <blockquote>
        The article "Matching Wildcards: An Empirical Way to Tame an Algorithm" in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
      </blockquote><a name="7"></a>

      <h3><a name="7">LICENSE</a></h3>

      <blockquote>
        Public Domain
      </blockquote>
      <hr />

      <table width="100%">
        <tr>
          <td width="33%"></td>

          <td width="33%" align="center">matchw (3)</td>

          <td class="c94" align="right" width="33%">December 15, 2019</td>
        </tr>
      </table><span class="c96">Generated by <a href="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</a> from
      89dc5ef6-1661-46d4-84de-bc38a89b4cb3 using man macros.</span><br />
      <br />

      <div class="c93"><img src="images/matchw.3.gif" /></div>
    </div>
  </div>
</body>
</html>
