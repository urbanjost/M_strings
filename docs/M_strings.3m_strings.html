<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace}
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="download.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>M_strings (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_strings(3f) </B>- [M_strings:INTRO] Fortran string module
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Description</A><BR>
<A HREF=#2>Synopsis</A><BR>
<A HREF=#3>See Also</A><BR>
<A HREF=#4>Examples</A><BR>
</BLOCKQUOTE>
<A name=5>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
The <B>M_strings</B>(3fm) module is a collection of Fortran procedures
that supplement the built-in intrinsic string routines. Routines
for parsing, tokenizing, changing case, substituting new strings for
substrings, locating strings with simple wildcard expressions, removing
tabs and line terminators and other string manipulations are included.
<P>
<B>M_strings_oop</B>(3fm) is a companion module that provides an OOP interface
to the M_strings module.
</BLOCKQUOTE>
<A name=2>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<PRE>
<B>public</B> entities:
<P>
   use M_strings, only : split,delim,chomp
   use M_strings, only : substitute,change,modif,transliterate,reverse,replace,join
   use M_strings, only : upper,lower,upper_quoted
   use M_strings, only : rotate13
   use M_strings, only : adjustc,compact,nospace,indent,crop,unquote,quote
   use M_strings, only : len_white,atleast,stretch,lenset,merge_str
   use M_strings, only : switch,s2c,c2s
   use M_strings, only : noesc,notabs,expand,uc,visible
   use M_strings, only : string_to_value,string_to_values,s2v,s2vs,value_to_string,v2s,msg
   use M_strings, only : listout,getvals
   use M_strings, only : matchw
   use M_strings, only : fmt
   use M_strings, only : base, decodebase, codebase
   use M_strings, only : isalnum, isalpha, iscntrl, isdigit, isgraph, islower,
                         isprint, ispunct, isspace, isupper, isascii, isblank, isxdigit
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TOKENS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>split</B> </TD><TD valign=bottom>
subroutine parses string using specified delimiter characters and stores tokens into an array
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>delim</B> </TD><TD valign=bottom>
subroutine parses string using specified delimiter characters and store tokens into an array
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>chomp</B> </TD><TD valign=bottom>
function consumes input line as it returns next token in a string using specified delimiters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>fmt</B> </TD><TD valign=bottom>
convert a string into a paragraph
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; EDITING</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>substitute</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
subroutine non-recursively globally replaces old substring
with new substring
</TD></TR>
<TR valign=top><TD colspan=2>
<B>replace</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
function non-recursively globally replaces old substring
with new substring using allocatable string (version of
<B>substitute</B>(3f) without limitation on length of output string)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>change</B> </TD><TD valign=bottom>
subroutine non-recursively globally replaces old substring
with new substring with a directive like line editor
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>modif</B> </TD><TD valign=bottom>
subroutine modifies a string with a directive like the XEDIT
line editor MODIFY command
</TD></TR>
<TR valign=top><TD colspan=2>
<B>transliterate</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
replace characters found in set one with characters from set two
</TD></TR>
<TR valign=top><TD colspan=2>
<B>reverse</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
reverse character order in a string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>join</B> </TD><TD valign=bottom>
join an array of CHARACTER variables with specified separator
</TD></TR>
<TR valign=top><TD colspan=2>
<B>rotate13</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
apply trivial encryption algorithm ROT13 to a string
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CASE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>upper</B> </TD><TD valign=bottom>
function converts string to uppercase
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>lower</B> </TD><TD valign=bottom>
function converts string to miniscule
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>upper</B> </TD><TD valign=bottom>
function converts string to uppercase skipping strings quoted per Fortran rules
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; WHITE SPACE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>adjustc</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
elemental function centers text within the length of the input string
</TD></TR>
<TR valign=top><TD colspan=2>
<B>compact</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
left justify string and replace duplicate whitespace with single characters or nothing
</TD></TR>
<TR valign=top><TD colspan=2>
<B>nospace</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
function replaces whitespace with nothing
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>indent</B> </TD><TD valign=bottom>
find number of leading spaces
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>crop</B> </TD><TD valign=bottom>
function trims leading and trailing spaces
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; QUOTES</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>unquote</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
remove quotes from string as if read with list-directed input
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>quote</B> </TD><TD valign=bottom>
add quotes to string as if written with list-directed input
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STRING LENGTH</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>len_white</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
find location of last non-whitespace character
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>lenset</B> </TD><TD valign=bottom>
return a string of specified length
</TD></TR>
<TR valign=top><TD colspan=2>
<B>atleast</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
return a string of at least specified length
</TD></TR>
<TR valign=top><TD colspan=2>
<B>stretch</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
return a string of at least specified length with suffix
</TD></TR>
<TR valign=top><TD colspan=2>
<B>merge_str</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
make strings of equal length and then call <B>MERGE</B>(3f) intrinsic
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CHARACTER ARRAY VERSUS STRING</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>switch</B> </TD><TD valign=bottom>
switch between a string and an array of single characters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>s2c</B> </TD><TD valign=bottom>
convert string to array of single characters and add null terminator for passing to C
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>c2s</B> </TD><TD valign=bottom>
convert null-terminated array of single characters to string for converting strings returned from C
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NONALPHA</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>noesc</B> </TD><TD valign=bottom>
convert non-printable ASCII8 characters to a space
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>notabs</B> </TD><TD valign=bottom>
convert tabs to spaces while maintaining columns, assuming tabs are set every 8 characters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>expand</B> </TD><TD valign=bottom>
expand escape sequences in a string
</TD></TR>
<TR valign=top><TD colspan=2>
<B>visible</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
expand escape sequences in a string to control and meta-control representations
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NUMERIC STRINGS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>string_to_value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic subroutine returns numeric value (REAL, DOUBLEPRECISION, INTEGER)  from string
</TD></TR>
<TR valign=top><TD colspan=2>
<B>string_to_values</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
subroutine reads an array of numbers from a string
</TD></TR>
<TR valign=top><TD colspan=2>
<B>getvals</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
subroutine reads a relatively arbitrary number of values from a string using list-directed read
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>s2v</B> </TD><TD valign=bottom>
function returns DOUBLEPRECISION numeric value from string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>s2vs</B> </TD><TD valign=bottom>
function returns a DOUBLEPRECISION array of numbers from a string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>msg</B> </TD><TD valign=bottom>
append the values of up to nine values into a string
</TD></TR>
<TR valign=top><TD colspan=2>
<B>value_to_string</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic subroutine returns string given numeric value (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>v2s</B> </TD><TD valign=bottom>
generic function returns string from numeric value (REAL, DOUBLEPRECISION, INTEGER )
</TD></TR>
<TR valign=top><TD colspan=2>
<B>listout</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
expand a list of numbers where  negative numbers denote range ends (1 <B>-10</B> means 1 thru 10)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>isnumber</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
determine if string represents a number
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CHARACTER TESTS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>matchw</B> </TD><TD valign=bottom>
compares given string for match to pattern which may contain wildcard characters
</TD></TR>
<TR></TR></TABLE><TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
isalnum returns .true. if character is a letter or digit
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isalpha returns .true. if character is a letter and .false. otherwise
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
iscntrl returns .true. if character is a delete character or ordinary control character
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isdigit returns .true. if character is a digit (0,1,&#46;&#46;&#46;,9) and .false. otherwise
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isgraph returns .true. if character is a printable character except a space is considered non-printable
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
islower returns .true. if character is a miniscule letter (a-z)
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isprint returns .true. if character is an ASCII printable character
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
ispunct returns .true. if character is a printable punctuation character
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isspace returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isupper returns .true. if character is an uppercase letter (A-Z)
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isascii returns .true. if the character is in the range <B>char</B>(0) to <B>char</B>(127)
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isblank returns .true. if character is a blank character (space or horizontal tab.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
isxdigit returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BASE CONVERSION</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>base</B> </TD></TR><TR valign=top><TD width=3%>&nbsp;</TD><TD>
convert whole number string in base [2-36] to string in alternate base [2-36]
</TD></TR>
<TR valign=top><TD colspan=2>
<B>codebase</B> </TD></TR><TR valign=top><TD width=3%>&nbsp;</TD><TD>
convert whole number string in base [2-36] to base 10 number
decodebase convert whole number in base 10 to string in base [2-36]
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MISCELLANEOUS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>describe</B> </TD></TR><TR valign=top><TD width=3%>&nbsp;</TD><TD>
returns a string describing the name of a single character
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<A name=>

    <H4>&nbsp; &nbsp; INTRINSICS</H4>
</A>
<BLOCKQUOTE>
<P>
The <B>M_strings</B>(3fm) module supplements and works in combination with
the Fortran built-in intrinsics. Stand-alone
Fortran lets you access the characters in a string using ranges
much like they are character arrays, assignment, comparisons with
standard operators, supports dynamically allocatable strings and
supports concatenation using the // operator, as well as a number
of intrinsic string routines:
<P>
<PRE>
       adjustl             Left adjust a string
       adjustr             Right adjust a string
       index               Position of a substring within a string
       repeat              Repeated string concatenation
       scan                Scan a string for the presence of a set of characters
       trim                Remove trailing blank characters of a string
       verify              Scan a string for the absence of a set of characters
       len                 It returns the length of a character string
       achar               converts an integer into a character
       iachar              converts a character into an integer
       len_trim            finds length of string with trailing spaces ignored
       new_line            Newline character
       selected_char_kind  Choose character kind
       lge                 Lexical greater than or equal
       lgt                 Lexical greater than
       lle                 Lexical less than or equal
       llt                 Lexical less than
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; OOPS INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
The <B>M_strings_oop</B>(3fm) module (included with the <B>M_strings</B>(3fm)
module) provides an OOP (Object-Oriented Programming) interface
to the <B>M_strings</B>(3fm) module; as described in the example program
OBJECT_ORIENTED shown below&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=3>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<P>
There are additional routines in other GPF modules for working with
expressions (M_calculator), time strings (M_time), random strings
(M_random, M_uuid), lists (M_list), and interfacing with the C regular
expression library (M_regex).
</BLOCKQUOTE>
<A name=4>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Each of the procedural functions includes an example program in the corresponding <B>man</B>(1) page for the function.
The object-oriented interface does not have individual <B>man</B>(1) pages, but is instead demonstrated using the following
example program:
<P>
<PRE>
 program demo_M_strings
 !
 ! This is an example using the object-oriented class/type model
 ! defined in M_strings_oop
 ! This is essentially the same functionality as the procedures
 ! combined with several Fortran intrinsics and overloaded operators
 !
 use M_strings_oop,only : string, p
 implicit none
 TYPE(string) :: str1
 TYPE(string) :: str2
 TYPE(string) :: str3
 TYPE(string) :: str4
 !==============================================================================
   write(*,*)&#146;exercise the M_STRING_OOP module interface&#146;
   ! draw a break line in the output
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Call methods of type(STRING)&#146;
   ! define TYPE(STRING) with constructor
   str2=string(&#146;   This  is  a  String!       &#146;)
   str4=string(&#146; a  String &#146;)
   write(*,*)repeat(&#146;=&#146;,78)
   ! print members of type
   write(*,101)&#146;str2%str is &#46;&#46;&#46;............. &#146;,str2%str
   ! same as intrinsic LEN()
   write(*,202)&#146;len &#46;&#46;&#46;..................... &#146;,str2%len()
   ! same as intrinsic INDEX()
   write(*,202)&#146;len_trim &#46;&#46;&#46;................ &#146;,str2%len_trim()
   ! same as intrinsic INDEX()
   write(*,202)&#146;index("is")&#46;&#46;&#46;.............. &#146;,str2%index("is")
   ! same as intrinsic INDEX()
   write(*,202)&#146;index("is",back=.T.) &#46;&#46;&#46;.... &#146;,str2%index("is",back=.TRUE.)
   ! output TYPE(STRING) with %str all uppercase
   write(*,101)&#146;upper &#46;&#46;&#46;................... &#146;,p(str2%upper())
   ! output TYPE(STRING) with %str all miniscule
   write(*,101)&#146;lower &#46;&#46;&#46;................... &#146;,p(str2%lower())
   ! output TYPE(STRING) with %str reversed
   write(*,101)&#146;reverse &#46;&#46;&#46;................. &#146;,p(str2%reverse())
   ! same as intrinsic ADJUSTL()
   write(*,101)&#146;adjustl &#46;&#46;&#46;................. &#146;,p(str2%adjustl())
   ! same as intrinsic ADJUSTR()
   write(*,101)&#146;adjustr &#46;&#46;&#46;................. &#146;,p(str2%adjustr())
   ! center string in current string length
   write(*,101)&#146;adjustc &#46;&#46;&#46;................. &#146;,p(str2%adjustc())
   ! center string in string length of NN
   write(*,101)&#146;adjustc(49) &#46;&#46;&#46;............. &#146;,p(str2%adjustc(49))
   ! force %str to be NN characters long
   write(*,101)&#146;lenset(49) &#46;&#46;&#46;.............. &#146;,p(str2%lenset(49))
   ! same as intrinsic TRIM()
   write(*,101)&#146;trim &#46;&#46;&#46;.................... &#146;,p(str2%trim())
   ! trim leading and trailing spaces
   write(*,101)&#146;crop &#46;&#46;&#46;.................... &#146;,p(str2%crop())
   ! calls M_strings procedure SUBSTITUTE()
   write(*,101)&#146;substitute("This","Here") .. &#146;,p(str2%substitute("This","Here"))
   ! calls M_strings procedure COMPACT()
   write(*,101)&#146;compact &#46;&#46;&#46;................. &#146;,p(str2%compact())
   write(*,101)&#146;compact("") &#46;&#46;&#46;............. &#146;,p(str2%compact(""))
   write(*,101)&#146;compact(":") &#46;&#46;&#46;............ &#146;,p(str2%compact(":"))
   ! calls M_strings procedure TRANSLITERATE()
   write(*,101)&#146;transliterate("aei","VWX") . &#146;,p(str2%transliterate("aei","VWX"))
   write(*,101)&#146;transliterate("aeiou"," ") . &#146;,p(str2%transliterate("aeiou"," "))
   write(*,101)&#146;transliterate("aeiou","") .. &#146;,p(str2%transliterate("aeiou",""))
   write(*,101)&#146;transliterate(" aeiou","") . &#146;,p(str2%transliterate(" aeiou",""))
   ! calls M_strings procedure SWITCH()
   write(*,404)&#146;chars &#46;&#46;&#46;................. . &#146;,str4%chars()
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   str2%str=&#146;\t\tSome tabs\t   x\bX &#146;
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,101)&#146;expand &#46;&#46;&#46;.................. &#146;,p(str2%expand())
   str2=str2%expand()
   ! calls M_strings procedure NOTABS()
   write(*,101)&#146;notabs &#46;&#46;&#46;.................. &#146;,p(str2%notabs())
   ! calls M_strings procedure NOESC()
   write(*,101)&#146;noesc &#46;&#46;&#46;................... &#146;,p(str2%noesc())
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Casting to numeric variables&#146;
   str3=string(&#146;   12.345678901234567e1        &#146;)
   write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;int  &#46;&#46;&#46;.................... &#146;, str3%int()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;real &#46;&#46;&#46;.................... &#146;, str3%real()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;dble &#46;&#46;&#46;.................... &#146;, str3%dble()
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Matching simple globbing patterns&#146;
   str3=string(&#146;   12.345678901234567e1        &#146;)
   str3=string(&#146;Four score and seven years ago&#146;)
   write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("Fo*") &#46;&#46;&#46;............ &#146;, str3%match("Fo*")
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("and") &#46;&#46;&#46;............ &#146;, str3%match("and")
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("*and*") &#46;&#46;&#46;.......... &#146;, str3%match("*and*")
<P>
   101 format(1x,a,"[",a,"]")
   202 format(1x,a,i0)
   303 format(1x,*(l3))
   404 format(1x,a,*("[",a1,"]":))
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))&#146;
   str1%str=&#146;123.456&#146;
   str2%str=&#146;AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;str1 + str2 &#46;&#46;&#46;............. &#146;,p(str1 + str2)
   ! a string that looks like a numeric value can have a value added
   write(*,*)&#146;str1 + 20000 &#46;&#46;&#46;............ &#146;,p(str1 +20000)
   write(*,*)&#146;str1 - 20.0 &#46;&#46;&#46;............. &#146;,p(str1 -20.0)
   write(*,*)&#146;str2 - "Aa" (removes ALL) .. &#146;,p(str2 - &#146;Aa&#146;)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (multiply,return TYPE(STRING))&#146;
   str1%str=&#146;AaBbCcDdEeFfGgHhIiJj&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,*)&#146;str1 * 3 &#46;&#46;&#46;................ &#146;,p(str1 * 3)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (//,return TYPE(STRING))&#146;
   str1%str=&#146;String one:&#146;
   str2%str=&#146;String two:&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;str1 // str2 &#46;&#46;&#46;............. &#146;,p(str1 // str2)
   ! numeric values are converted to strings
   write(*,*)&#146;str1 // 20000 &#46;&#46;&#46;............ &#146;,p(str1 // 20000)
   write(*,*)&#146;str1 // 20.0 &#46;&#46;&#46;............. &#146;,p(str1 // 20.0)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (logical comparisons,return logical)&#146;
   ! NOTE: comparisons are performed on the character variable members
   !       of the type(string)
   str1%str=&#146;abcdefghij&#146;
   str2%str=&#146;klmnopqrst&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;: EQ LT GT LE GE NE&#146;
   write(*,*)&#146;compare str1 to str1&#146;
   write(*,303)str1.eq.str1  ,str1.lt.str1  ,str1.gt.str1  ,str1.le.str1 &
              & ,str1.ge.str1  ,str1.ne.str1
   write(*,*)&#146;compare str1 to str2&#146;
   write(*,303)str1.eq.str2  ,str1.lt.str2  ,str1.gt.str2  ,str1.le.str2 &
              & ,str1.ge.str2  ,str1.ne.str2
   write(*,*)&#146;compare str2 to str1&#146;
   write(*,303)str2.eq.str1  ,str2.lt.str1  ,str2.gt.str1  ,str2.le.str1 &
              & ,str2.ge.str1  ,str2.ne.str1
<P>
   write(*,*)repeat(&#146;=&#146;,78)
<P>
 end program demo_M_strings
<P>
 Expected output
<P>
  exercise the M_STRING_OOP module interface
  =============================================================================
  Call methods of type(STRING)
  =============================================================================
  str2%str is &#46;&#46;&#46;............. [   This  is  a  String!             ]
  len &#46;&#46;&#46;..................... 36
  len_trim &#46;&#46;&#46;................ 23
  index("is")&#46;&#46;&#46;.............. 6
  index("is",back=.T.) &#46;&#46;&#46;.... 10
  upper &#46;&#46;&#46;................... [   THIS  IS  A  STRING!             ]
  lower &#46;&#46;&#46;................... [   this  is  a  string!             ]
  reverse &#46;&#46;&#46;................. [             !gnirtS  a  si  sihT   ]
  adjustl &#46;&#46;&#46;................. [This  is  a  String!                ]
  adjustr &#46;&#46;&#46;................. [                This  is  a  String!]
  adjustc &#46;&#46;&#46;................. [        This  is  a  String!        ]
  adjustc(49) &#46;&#46;&#46;............. [              This  is  a  String!               ]
  lenset(49) &#46;&#46;&#46;.............. [   This  is  a  String!                          ]
  trim &#46;&#46;&#46;.................... [   This  is  a  String!]
  crop &#46;&#46;&#46;.................... [This  is  a  String!]
  substitute("This","Here") .. [   Here  is  a  String!             ]
  compact &#46;&#46;&#46;................. [This is a String!]
  compact("") &#46;&#46;&#46;............. [ThisisaString!]
  compact(":") &#46;&#46;&#46;............ [This:is:a:String!]
  transliterate("aei","VWX") . [   ThXs  Xs  V  StrXng!             ]
  transliterate("aeiou"," ") . [   Th s   s     Str ng!             ]
  transliterate("aeiou","") .. [   Ths  s    Strng!                 ]
  transliterate(" aeiou","") . [ThssStrng!                          ]
  chars &#46;&#46;&#46;................. . [ ][a][ ][s][t][r][i][n][g][ ]
  =============================================================================
  str2%str &#46;&#46;&#46;................ [\t\tSome tabs\t   x\bX ]
  expand &#46;&#46;&#46;.................. [         Some tabs          x   X]
  notabs &#46;&#46;&#46;.................. [                Some tabs          x    X]
  noesc &#46;&#46;&#46;................... [  Some tabs    x X]
  =============================================================================
  Casting to numeric variables
  str3%str &#46;&#46;&#46;................ [   12.345678901234567e1        ]
  int  &#46;&#46;&#46;....................          123
  real &#46;&#46;&#46;....................    123.456787
  dble &#46;&#46;&#46;....................    123.45678901234567
  =============================================================================
  Matching simple globbing patterns
  str3%str &#46;&#46;&#46;................ [Four score and seven years ago]
  match("Fo*") &#46;&#46;&#46;............  T
  match("and") &#46;&#46;&#46;............  F
  match("*and*") &#46;&#46;&#46;..........  T
  ==============================================================================
  OVERLOADED OPERATORS (add and subtract, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [123.456]
  str2%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj]
  str1 + str2 &#46;&#46;&#46;............. 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj
  str1 + 20000 &#46;&#46;&#46;............ 20123.455999999998
  str1 - 20.0 &#46;&#46;&#46;............. -103.456
  str2 - "Aa" (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (multiply, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj]
  str1 * 3 &#46;&#46;&#46;................ AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (//, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [String one:]
  str2%str &#46;&#46;&#46;................ [String two:]
  str1 // str2 &#46;&#46;&#46;............. String one:String two:
  str1 // 20000 &#46;&#46;&#46;............ String one:20000
  str1 // 20.0 &#46;&#46;&#46;............. String one:20.0
  =============================================================================
  OVERLOADED OPERATORS (logical comparisons, return logical)
  str1%str &#46;&#46;&#46;................ [abcdefghij]
  str2%str &#46;&#46;&#46;................ [klmnopqrst]
  : EQ LT GT LE GE NE
  compare str1 to str1
  :  T  F  F  T  T  F
  compare str1 to str2
  :  F  T  F  T  F  T
  compare str2 to str1
  :  F  F  T  F  T  T
  =============================================================================
</PRE>
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>M_strings (3)</TD> <TD align=right width=33%><I>July 12, 2020</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 956f4ccb-f653-4a9b-8e71-724adef62648 using man macros.</FONT>
<br><br><center><img src="images/M_strings.3m_strings.gif"></center>
</div>
</div>
</body>
</HTML>
