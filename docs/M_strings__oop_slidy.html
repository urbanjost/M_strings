<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>M_strings</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">M_strings</h1>
</div>
<div id="name" class="slide section level1">
<h1>NAME</h1>
<p>adjustc(3f) - [M_strings:WHITESPACE] center text (LICENSE:PD)</p>
<h2 id="synopsis">SYNOPSIS</h2>
<p>pure function adjustc(string[,length])</p>
<pre><code>   character(len=*),intent(in)  :: string
   integer,intent(in),optional  :: length
   character(len=:),allocatable :: adjustc
</code></pre>
<h2 id="description">DESCRIPTION</h2>
<p>Centers input text in a string of the length specified. Returns a string of length LENGTH if LENGTH is present. Otherwise returns a string of the length of the input string.</p>
<h2 id="options">OPTIONS</h2>
<ul>
<li><p><strong>string</strong><br />
input string to trim and center</p></li>
<li><p><strong>length</strong><br />
line length to center text in, optional.</p></li>
</ul>
<h2 id="returns">RETURNS</h2>
<ul>
<li><strong>adjustc</strong><br />
centered output string</li>
</ul>
<h2 id="examples">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_adjustc
   use M_strings, only : adjustc
   !  using length of the input string
      write(*,&#39;(a)&#39;)       &#39;================================&#39;
      write(*,&#39;(a)&#39;)adjustc(&#39;centered string                 &#39;)
      write(*,&#39;(a)&#39;)adjustc(&#39;                 centered string&#39;)
      write(*,&#39;(a)&#39;)adjustc(&#39;  centered string               &#39;)
   !  using explicit output string length
      write(*,&#39;(a)&#39;)repeat(&#39;=&#39;,50)
      write(*,&#39;(a)&#39;)adjustc(&#39;this is a centered string&#39;,50)
      write(*,&#39;(a)&#39;)repeat(&#39;=&#39;,50)
   end program demo_adjustc
</code></pre>
<p>Expected output</p>
<pre><code>   ================================
           centered string
           centered string
           centered string
   ==================================================
               this is a centered string
   ==================================================
</code></pre>
<h2 id="author">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-1" class="slide section level1">
<h1>NAME</h1>
<p>aton(3f) - [M_strings:TYPE] function returns argument as a numeric value from a string (LICENSE:PD)</p>
<h2 id="synopsis-1">SYNOPSIS</h2>
<p>logical function aton(str,val[,msg])</p>
<pre><code>    character(len=*),intent(in)       :: str
    type(TYPE(kind=KIND)),intent(out) :: val
    character(len=:),allocatable,intent(out) :: msg
</code></pre>
<h2 id="description-1">DESCRIPTION</h2>
<p>This function converts a string to a numeric value.</p>
<h2 id="options-1">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
holds string assumed to represent a numeric value</p></li>
<li><p><strong>val</strong><br />
returned value. May be REAL or INTEGER.</p></li>
<li><p><strong>msg</strong><br />
message describing error when ATON returns .false.</p></li>
</ul>
<h2 id="returns-1">RETURNS</h2>
<ul>
<li><strong>aton</strong><br />
ï¿½true. if the conversion was successful, .false. otherwise</li>
</ul>
<h2 id="examples-1">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_aton

      use M_strings, only: aton
      implicit none
      character(len=14),allocatable :: strings(:)
      doubleprecision               :: dv
      integer                       :: iv
      real                          :: rv
      integer                       :: i

      ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
      strings=[&amp;
      &amp;&#39; 10.345       &#39;,&amp;
      &amp;&#39;+10           &#39;,&amp;
      &amp;&#39;    -3        &#39;,&amp;
      &amp;&#39;    -4.94e-2  &#39;,&amp;
      &amp;&#39;0.1           &#39;,&amp;
      &amp;&#39;12345.678910d0&#39;,&amp;
      &amp;&#39;              &#39;,&amp; ! Note: will return zero without an error message
      &amp;&#39;1 2 1 2 1 . 0 &#39;,&amp; ! Note: spaces will be ignored
      &amp;&#39;WHAT?         &#39;]  ! Note: error messages will appear, zero returned

      do i=1,size(strings)
         write(*,&#39;(a)&#39;,advance=&#39;no&#39;)&#39;STRING:&#39;,strings(i)
         if(aton(strings(i),iv)) write(*,&#39;(g0)&#39;,advance=&#39;no&#39;)&#39;:INTEGER &#39;,iv
         if(aton(strings(i),rv)) write(*,&#39;(g0)&#39;,advance=&#39;no&#39;)&#39;:INTEGER &#39;,rv
         if(aton(strings(i),dv)) write(*,&#39;(g0)&#39;,advance=&#39;no&#39;)&#39;:INTEGER &#39;,dv
      enddo

      end program demo_aton

</code></pre>
<h2 id="author-1">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-1">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-2" class="slide section level1">
<h1>NAME</h1>
<p>base2(3f) - [M_strings:BASE] convert whole number to string in base 2 (LICENSE:PD)</p>
<h2 id="synopsis-2">SYNOPSIS</h2>
<p>function base2(int)</p>
<pre><code>    integer,intent(in)           :: int
    character(len=:),allocatable :: base2
</code></pre>
<h2 id="description-2">DESCRIPTION</h2>
<p>Convert a whole number to a string in base 2.</p>
<p>This is often done with the B edit descriptor and an internal WRITE() statement, but is done without calling the I/O routines, and as a function.</p>
<h2 id="options-2">OPTIONS</h2>
<ul>
<li><strong>int</strong><br />
input string representing numeric whole value</li>
</ul>
<h2 id="returns-2">RETURNS</h2>
<ul>
<li><strong>base2</strong><br />
string representing input value in base 2</li>
</ul>
<h2 id="examples-2">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_base2
     use M_strings, only : base2
     implicit none
        write(*,&#39;(a)&#39;) base2(huge(0))
        write(*,&#39;(a)&#39;) base2(0)
        write(*,&#39;(a)&#39;) base2(64)
        write(*,&#39;(a)&#39;) base2(-64)
        write(*,&#39;(a)&#39;) base2(-huge(0)-1)
     end program demo_base2
</code></pre>
<p>Results:</p>
<pre><code>    &gt; 1111111111111111111111111111111
    &gt; 0
    &gt; 1000000
    &gt; 11111111111111111111111111000000
    &gt; 10000000000000000000000000000000
</code></pre>
<h2 id="author-2">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-2">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-3" class="slide section level1">
<h1>NAME</h1>
<p>base(3f) - [M_strings:BASE] convert whole number string in base [2-36] to string in alternate base [2-36] (LICENSE:PD)</p>
<h2 id="synopsis-3">SYNOPSIS</h2>
<p>elemental impure logical function base(x,b,y,a)</p>
<pre><code>   character(len=*),intent(in)  :: x
   character(len=*),intent(out) :: y
   integer,intent(in)           :: b,a
</code></pre>
<h2 id="description-3">DESCRIPTION</h2>
<p>Convert a numeric string from base B to base A. The function returns FALSE if B is not in the range [2..36] or if string X contains invalid characters in base B or if result Y is too big</p>
<p>The letters A,B,```,Z represent 10,11,...,36 in a base &gt; 10.</p>
<h2 id="options-3">OPTIONS</h2>
<ul>
<li><p><strong>x</strong><br />
input string representing numeric whole value</p></li>
<li><p><strong>b</strong><br />
assumed base of input string</p></li>
<li><p><strong>y</strong><br />
output string</p></li>
<li><p><strong>a</strong><br />
base specified for output string</p></li>
</ul>
<h2 id="examples-3">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_base
   use M_strings, only : base
   implicit none
   integer           :: ba,bd
   character(len=40) :: x,y

   print *,&#39; BASE CONVERSION&#39;
   write(*,&#39;(&quot;Start   Base (2 to 36): &quot;)&#39;,advance=&#39;no&#39;); read *, bd
   write(*,&#39;(&quot;Arrival Base (2 to 36): &quot;)&#39;,advance=&#39;no&#39;); read *, ba
   INFINITE: do
      write(*,&#39;(&quot;Enter number in start base (0 to quit): &quot;)&#39;,advance=&#39;no&#39;)
      read *, x
      if(x == &#39;0&#39;) exit INFINITE
      if(base(x,bd,y,ba))then
           write(*,&#39;(&quot;In base &quot;,I2,&quot;: &quot;,A20)&#39;)  ba, y
       else
         print *,&#39;Error in decoding/encoding number.&#39;
       endif
    enddo INFINITE

    end program demo_base
</code></pre>
<h2 id="author-3">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-3">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-4" class="slide section level1">
<h1>NAME</h1>
<p>bundle(3f) - [M_strings:ARRAY] return up to twenty strings of arbitrary length as an array (LICENSE:PD)</p>
<h2 id="synopsis-4">SYNOPSIS</h2>
<p>function bundle(str1,str2,```str20,len) result (vec)</p>
<pre><code>    character(len=*),intent(in),optional   :: str1, str2 ``` str20
    integer,intent(in),optional            :: len
</code></pre>
<h2 id="description-4">DESCRIPTION</h2>
<p>Given a list of up to twenty strings create a string array. The length of the variables with be the same as the maximum length of the input strings unless explicitly specified via LEN.</p>
<p>This is an alternative to the syntax</p>
<pre><code>     [ CHARACTER(LEN=NN) :: str1, str2, ``` ]
</code></pre>
<p>that by default additionally calculates the minimum length required to prevent truncation.</p>
<h2 id="options-4">OPTIONS</h2>
<ul>
<li><p><strong>str1,str2, ``` str20</strong><br />
input strings to combine into a vector</p></li>
<li><p><strong>len</strong><br />
length of returned array variables</p></li>
</ul>
<h2 id="examples-4">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_bundle
   use M_strings, only: bundle
   implicit none
      print &quot;(*(&#39;&quot;&quot;&#39;,a,&#39;&quot;&quot;&#39;:,&#39;,&#39;,1x))&quot;, bundle(&quot;one&quot;)
      print &quot;(*(&#39;&quot;&quot;&#39;,a,&#39;&quot;&quot;&#39;:,&#39;,&#39;,1x))&quot;, bundle(&quot;one&quot;,&quot;two&quot;)
      print &quot;(*(&#39;&quot;&quot;&#39;,a,&#39;&quot;&quot;&#39;:,&#39;,&#39;,1x))&quot;, bundle(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;)
      print &quot;(*(&#39;&quot;&quot;&#39;,a,&#39;&quot;&quot;&#39;:,&#39;,&#39;,1x))&quot;, bundle(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&amp;
              &amp; &quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;)
   end program demo_bundle
</code></pre>
<p>Expected output</p>
<pre><code>   &quot;one&quot;
   &quot;one&quot;, &quot;two&quot;
   &quot;one  &quot;, &quot;two  &quot;, &quot;three&quot;
   &quot;one  &quot;, &quot;two  &quot;, &quot;three&quot;, &quot;four &quot;, &quot;five &quot;, &quot;six  &quot;, &quot;seven&quot;
</code></pre>
<h2 id="author-4">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-4">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-5" class="slide section level1">
<h1>NAME</h1>
<p>c2s(3f) - [M_strings:ARRAY] convert C string pointer to Fortran character string (LICENSE:PD)</p>
<h2 id="synopsis-5">SYNOPSIS</h2>
<p>function c2s(c_string_pointer) result(f_string)</p>
<pre><code>    type(c_ptr), intent(in)       :: c_string_pointer
    character(len=:), allocatable :: f_string
</code></pre>
<h2 id="description-5">DESCRIPTION</h2>
<p>Given a C pointer to a character string return a Fortran character string.</p>
<h2 id="options-5">OPTIONS</h2>
<ul>
<li><strong>c_string_pointer</strong><br />
C pointer to convert</li>
</ul>
<h2 id="returns-3">RETURNS</h2>
<ul>
<li><strong>f_string</strong><br />
Fortran character variable to return</li>
</ul>
<h2 id="examples-5">EXAMPLES</h2>
<h2 id="author-5">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-5">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-6" class="slide section level1">
<h1>NAME</h1>
<p>change(3f) - [M_strings:EDITING] change old string to new string with a directive like a line editor (LICENSE:PD)</p>
<h2 id="synopsis-6">SYNOPSIS</h2>
<p>subroutine change(target_string,cmd,ierr)</p>
<pre><code>    character(len=*),intent(inout) :: target_string
    character(len=*),intent(in)    :: cmd
    integer                        :: ierr
</code></pre>
<h2 id="description-6">DESCRIPTION</h2>
<p>change an old substring into a new substring in a character variable like a line editor. Primarily used to create interactive utilities such as input history editors for interactive line-mode programs. The output string is assumed long enough to accommodate the change. a directive resembles a line editor directive of the form</p>
<pre><code>      C/old_string/new_string/
</code></pre>
<p>where / may be any character which is not included in old_string or new_string.</p>
<p>a null old_string implies "beginning of string".</p>
<h2 id="options-6">OPTIONS</h2>
<ul>
<li><p><strong>target_string</strong><br />
line to be changed</p></li>
<li><p><strong>cmd</strong><br />
contains instructions to change the string</p></li>
<li><p><strong>ierr</strong><br />
error code.</p>
<ul>
<li><p>=<strong>-1</strong> bad directive</p></li>
<li><p>=0 no changes made</p></li>
<li><p>&gt;0 count of changes made</p></li>
</ul></li>
</ul>
<h2 id="examples-6">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_change

    use M_strings, only : change
    implicit none
    character(len=132) :: line=&#39;This is a test string to change&#39;
    integer            :: ierr
       write(*,*)trim(line)
       ! change miniscule a to uppercase A
       call change(line,&#39;c/a/A/&#39;,ierr)
       write(*,*)trim(line)
       ! put string at beginning of line
       call change(line,&#39;c//prefix: /&#39;,ierr)
       write(*,*)trim(line)
       ! remove blanks
       call change(line,&#39;c/ //&#39;,ierr)
       write(*,*)trim(line)
   end program demo_change
</code></pre>
<p>Expected output</p>
<pre><code>    This is a test string to change
    This is A test string to chAnge
    prefix: This is A test string to chAnge
    prefix:ThisisAteststringtochAnge
</code></pre>
<h2 id="author-6">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-6">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-7" class="slide section level1">
<h1>NAME</h1>
<p>chomp(3f) - [M_strings:TOKENS] Tokenize a string, consuming it one token per call (LICENSE:PD)</p>
<h2 id="synopsis-7">SYNOPSIS</h2>
<p>function chomp(source_string,token[,delimiters])</p>
<pre><code>    character(len=*)                     :: source_string
    character(len=:),intent(out)         :: token
    character(len=:),intent(in),optional :: delimiters
    integer                              :: chomp
</code></pre>
<h2 id="description-7">DESCRIPTION</h2>
<p>The CHOMP(3f) function is used to isolate sequential tokens in a string, SOURCE_STRING. These tokens are delimited in the string by at least one of the characters in DELIMITERS. This routine consumes the source_string one token per call. It returns <strong>-1</strong> when complete. The default delimiter list is "space,tab,carriage return,newline".</p>
<h2 id="options-7">OPTIONS</h2>
<ul>
<li><p><strong>SOURCE_STRING</strong><br />
string to tokenize</p></li>
<li><p><strong>DELIMITERS</strong><br />
list of separator characters</p></li>
</ul>
<h2 id="returns-4">RETURNS</h2>
<ul>
<li><p><strong>TOKEN</strong><br />
returned token</p></li>
<li><p><strong>CHOMP</strong><br />
status flag. 0 = success, <strong>-1</strong> = no tokens remain</p></li>
</ul>
<h2 id="examples-7">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_chomp

   use M_strings, only : chomp
   implicit none
   character(len=100)            :: inline
   character(len=:),allocatable  :: token
   character(len=*),parameter    :: delimiters=&#39; ;,&#39;
   integer                       :: ios
   integer                       :: icount
   integer                       :: itoken
      icount=0
      do        ! read lines from stdin until end-of-file or error
         read (unit=*,fmt=&quot;(a)&quot;,iostat=ios) inline
         if(ios /= 0)stop
         icount=icount+1
         itoken=0
         write(*,*)&#39;INLINE &#39;,trim(inline)
         do while ( chomp(inline,token,delimiters) &gt;=  0)
            itoken=itoken+1
            print *, itoken,&#39;TOKEN=[&#39;//trim(token)//&#39;]&#39;
         enddo
      enddo

   end program demo_chomp
</code></pre>
<p>sample input file</p>
<pre><code>    this is a test of chomp; A:B :;,C;;
</code></pre>
<p>sample output file</p>
<pre><code>    &gt; INLINE     this is a test of chomp; A:B :;,C;;
    &gt;           1 TOKEN=[this]
    &gt;           2 TOKEN=[is]
    &gt;           3 TOKEN=[a]
    &gt;           4 TOKEN=[test]
    &gt;           5 TOKEN=[of]
    &gt;           6 TOKEN=[chomp]
    &gt;           7 TOKEN=[A:B]
    &gt;           8 TOKEN=[:]
    &gt;           9 TOKEN=[C]
</code></pre>
<h2 id="author-7">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-7">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-8" class="slide section level1">
<h1>NAME</h1>
<p>clip(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks from a string (LICENSE:PD)</p>
<h2 id="synopsis-8">SYNOPSIS</h2>
<p>function clip(strin) result (strout)</p>
<pre><code>    character(len=*),intent(in)  :: strin
    character(len=:),allocatable :: strout
</code></pre>
<h2 id="description-8">DESCRIPTION</h2>
<p>leading and trailing spaces are trimmed from the resulting string.</p>
<h2 id="options-8">OPTIONS</h2>
<ul>
<li><strong>strin</strong><br />
input string to trim leading and trailing space characters from</li>
</ul>
<h2 id="returns-5">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
clipped version of input string</li>
</ul>
<h2 id="examples-8">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_clip
   use M_strings, only: clip
   implicit none
   character(len=20) ::  untrimmed = &#39;   ABCDEFG abcdefg  &#39;
      write(*,*) &#39;untrimmed string=[&#39;,untrimmed,&#39;]&#39;
      write(*,*) &#39;clipped string=[&#39;,clip(untrimmed),&#39;]&#39;
   end program demo_clip
</code></pre>
<p>Expected output</p>
<pre><code>     untrimmed string=[   ABCDEFG abcdefg                      ]
     clipped string=[ABCDEFG abcdefg]
</code></pre>
<h2 id="author-8">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-8">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-9" class="slide section level1">
<h1>NAME</h1>
<p>codebase(3f) - [M_strings:BASE] convert whole number in base 10 to string in base [2-36] (LICENSE:PD)</p>
<h2 id="synopsis-9">SYNOPSIS</h2>
<p>logical function codebase(in_base10,out_base,answer)</p>
<pre><code>   integer,intent(in)           :: in_base10
   integer,intent(in)           :: out_base
   character(len=*),intent(out) :: answer
</code></pre>
<h2 id="description-9">DESCRIPTION</h2>
<p>Convert a number from base 10 to base OUT_BASE. The function returns ï¿½FALSE. if OUT_BASE is not in [2..36] or if number IN_BASE10 is too big.</p>
<p>The letters A,B,```,Z represent 10,11,...,36 in the base &gt; 10.</p>
<h2 id="examples-9">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_codebase
   use M_strings, only : codebase
   implicit none
   character(len=20) :: answer
   integer           :: i, j
   logical           :: ierr
   do j=1,100
      do i=2,36
         ierr=codebase(j,i,answer)
         write(*,*)&#39;VALUE=&#39;,j,&#39; BASE=&#39;,i,&#39; ANSWER=&#39;,answer
      enddo
   enddo
   end program demo_codebase
</code></pre>
<h2 id="author-9">AUTHOR</h2>
<p>John S. Urban</p>
<pre><code>    Ref.: &quot;Math matiques en Turbo-Pascal by
           M. Ducamp and A. Reverchon (2),
           Eyrolles, Paris, 1988&quot;.
</code></pre>
<p>based on a F90 Version By J-P Moreau (<a href="http://www.jpmoreau.fr">www.jpmoreau.fr</a>)</p>
<h2 id="license-9">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-10" class="slide section level1">
<h1>NAME</h1>
<p>compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing) (LICENSE:PD)</p>
<h2 id="synopsis-10">SYNOPSIS</h2>
<p>function compact(STR,CHAR) result (OUTSTR)</p>
<pre><code>    character(len=*),intent(in)          :: STR
    character(len=*),intent(in),optional :: CHAR
    character(len=len(str))              :: OUTSTR
</code></pre>
<h2 id="description-10">DESCRIPTION</h2>
<p>COMPACT(3f) converts multiple spaces, tabs and control characters (called "whitespace") to a single character or nothing. Leading whitespace is removed.</p>
<h2 id="options-9">OPTIONS</h2>
<ul>
<li><p><strong>STR</strong><br />
input string to reduce or remove whitespace from</p></li>
<li><p><strong>CHAR</strong><br />
By default the character that replaces adjacent whitespace is a space. If the optional CHAR parameter is supplied it will be used to replace the whitespace. If a null character is supplied for CHAR whitespace is removed.</p></li>
</ul>
<h2 id="returns-6">RETURNS</h2>
<ul>
<li><strong>OUTSTR</strong><br />
string of same length as input string but with all contiguous whitespace reduced to a single space and leading whitespace removed</li>
</ul>
<h2 id="examples-10">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_compact
    use M_strings, only : compact
    implicit none
    ! produces &#39;This is a test               &#39;
    write(*,*)compact(&#39;  This     is      a     test  &#39;)
    ! produces &#39;Thisisatest                  &#39;
    write(*,*)compact(&#39;  This     is      a     test  &#39;,char=&#39;&#39;)
    ! produces &#39;This:is:a:test               &#39;
    write(*,*)compact(&#39;  This     is      a     test  &#39;,char=&#39;:&#39;)
    ! note CHAR is used to replace the whitespace, but if CHAR is
    ! in the original string it is just copied
    write(*,*)compact(&#39;A  AA    A   AAAAA&#39;,char=&#39;A&#39;)
    ! produces (original A characters are left as-is) &#39;AAAAAAAAAAAA&#39;
    ! not &#39;A&#39;
   end program demo_compact

   Expected output

    &gt;This is a test
    &gt;Thisisatest
    &gt;This:is:a:test
    &gt;AAAAAAAAAAAA
</code></pre>
<h2 id="author-10">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-10">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-11" class="slide section level1">
<h1>NAME</h1>
<p>cpad(3f) - [M_strings:LENGTH] convert to a cropped string and then centers the string to specified length (LICENSE:PD)</p>
<h2 id="synopsis-11">SYNOPSIS</h2>
<p>function cpad(valuein,length) result(strout)</p>
<pre><code>    class*,intent(in)       :: valuein(..)
    integer,intent(in)      :: length
</code></pre>
<h2 id="description-11">DESCRIPTION</h2>
<p>cpad(3f) converts a scalar value to a cropped string and then pads it with spaces to center it to at least the specified length. If the trimmed input is longer than the requested length the string is returned trimmed of leading and trailing spaces.</p>
<h2 id="options-10">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
The input may be scalar or a vector. the input value to return as a string, padded with spaces to center it at the the specified length if shorter than length. The input may be any intrinsic scalar which is converted to a cropped string much as if written with list-directed output.</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return</p></li>
</ul>
<h2 id="returns-7">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
The input string center-padded to the requested length with spaces.</li>
</ul>
<h2 id="examples-11">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_cpad
      use M_strings, only : cpad
      implicit none
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( &#39;my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( &#39;my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( &#39;   my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( &#39;   my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( valuein=42 , length=7)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) cpad( valuein=1.0/9.0 , length=20)
     end program demo_cpad

</code></pre>
<h2 id="author-11">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-11">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-12" class="slide section level1">
<h1>NAME</h1>
<p>crop(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks and control characters from a string (LICENSE:PD)</p>
<h2 id="synopsis-12">SYNOPSIS</h2>
<p>function crop(strin) result (strout)</p>
<pre><code>    character(len=*),intent(in)  :: strin
    character(len=:),allocatable :: strout
</code></pre>
<h2 id="description-12">DESCRIPTION</h2>
<p>All control characters throughout the string are replaced with spaces and leading and trailing spaces are trimmed from the resulting string. Tabs are expanded assuming a stop every eight characters.</p>
<h2 id="options-11">OPTIONS</h2>
<ul>
<li><strong>strin</strong><br />
input string to trim leading and trailing space and control characters from</li>
</ul>
<h2 id="returns-8">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
cropped version of input string</li>
</ul>
<h2 id="examples-12">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_crop
   use M_strings, only: crop
   implicit none
   character(len=20) ::  untrimmed = &#39;   ABCDEFG abcdefg  &#39;
      write(*,*) &#39;untrimmed string=[&#39;,untrimmed,&#39;]&#39;
      write(*,*) &#39;cropped string=[&#39;,crop(untrimmed),&#39;]&#39;
   end program demo_crop
</code></pre>
<p>Expected output</p>
<pre><code>     untrimmed string=[   ABCDEFG abcdefg                      ]
     cropped string=[ABCDEFG abcdefg]
</code></pre>
<h2 id="author-12">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-12">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-13" class="slide section level1">
<h1>NAME</h1>
<p>dble(3f) - [M_strings:TYPE] overloads DBLE(3f) so it can handle character arguments (LICENSE:PD)</p>
<h2 id="synopsis-13">SYNOPSIS</h2>
<p>impure elemental function dble(string)</p>
<pre><code>    character(len=*) :: string
    integer          :: dble
</code></pre>
<h2 id="description-13">DESCRIPTION</h2>
<p>dble(3f) returns a DOUBLE value when given a numeric representation of a numeric value. This overloads the DBLE(3f) intrinsic so that CHARACTER arguments assumed to represent a numeric value may be input.</p>
<h2 id="options-12">OPTIONS</h2>
<ul>
<li><strong>STRING</strong><br />
input string to be converted to a dble value</li>
</ul>
<h2 id="returns-9">RETURNS</h2>
<ul>
<li><strong>DBLE</strong><br />
double precision value represented by input string</li>
</ul>
<h2 id="examples-13">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_dble
     use M_strings, only: dble
     implicit none
     write(*,*)dble(&#39;100&#39;),dble(&#39;20.4&#39;)
     write(*,*)&#39;dble still works&#39;,dble(20),dble(20.4)
     write(*,*)&#39;elemental&#39;,&amp;
     &amp; dble([character(len=23) :: &#39;10&#39;,&#39;20.3&#39;,&#39;20.5&#39;,&#39;20.6&#39;])
     end program demo_dble
</code></pre>
<p>Results:</p>
<pre><code>     &gt;    100.00000000000000        20.399999999999999
     &gt;  dble still works   20.000000000000000 20.399999618530273
     &gt;  elemental   10.00000000000000  20.30000000000000
     &gt;  20.50000000000000 20.60000000000000
</code></pre>
<h2 id="author-13">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-13">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-14" class="slide section level1">
<h1>NAME</h1>
<p>decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number (LICENSE:PD)</p>
<h2 id="synopsis-14">SYNOPSIS</h2>
<p>logical function decodebase(string,basein,out10)</p>
<pre><code>   character(len=*),intent(in)  :: string
   integer,intent(in)           :: basein
   integer,intent(out)          :: out10
</code></pre>
<h2 id="description-14">DESCRIPTION</h2>
<p>Convert a numeric string representing a whole number in base BASEIN to base 10. The function returns FALSE if BASEIN is not in the range [2..36] or if string STRING contains invalid characters in base BASEIN or if result OUT10 is too big</p>
<p>The letters A,B,```,Z represent 10,11,...,36 in the base &gt; 10.</p>
<h2 id="options-13">OPTIONS</h2>
<ul>
<li><p><strong>string</strong><br />
input string. It represents a whole number in the base specified by BASEIN unless BASEIN is set to zero. When BASEIN is zero STRING is assumed to be of the form BASE#VALUE where BASE represents the function normally provided by BASEIN.</p></li>
<li><p><strong>basein</strong><br />
base of input string; either 0 or from 2 to 36.</p></li>
<li><p><strong>out10</strong><br />
output value in base 10</p></li>
</ul>
<h2 id="examples-14">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_decodebase
   use M_strings, only : codebase, decodebase
   implicit none
   integer           :: ba,bd
   character(len=40) :: x,y
   integer           :: r

   print *,&#39; BASE CONVERSION&#39;
   write(*,&#39;(&quot;Start   Base (2 to 36): &quot;)&#39;,advance=&#39;no&#39;); read *, bd
   write(*,&#39;(&quot;Arrival Base (2 to 36): &quot;)&#39;,advance=&#39;no&#39;); read *, ba
   INFINITE: do
      print *,&#39;&#39;
      write(*,&#39;(&quot;Enter number in start base: &quot;)&#39;,advance=&#39;no&#39;); read *, x
      if(x == &#39;0&#39;) exit INFINITE
      if(decodebase(x,bd,r)) then
         if(codebase(r,ba,y)) then
           write(*,&#39;(&quot;In base &quot;,I2,&quot;: &quot;,A20)&#39;)  ba, y
         else
           print *,&#39;Error in coding number.&#39;
         endif
      else
         print *,&#39;Error in decoding number.&#39;
      endif
   enddo INFINITE

   end program demo_decodebase
</code></pre>
<h2 id="author-14">AUTHOR</h2>
<p>John S. Urban</p>
<pre><code>      Ref.: &quot;Math matiques en Turbo-Pascal by
             M. Ducamp and A. Reverchon (2),
             Eyrolles, Paris, 1988&quot;.
</code></pre>
<p>based on a F90 Version By J-P Moreau (<a href="http://www.jpmoreau.fr">www.jpmoreau.fr</a>)</p>
<h2 id="license-14">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-15" class="slide section level1">
<h1>NAME</h1>
<p>delim(3f) - [M_strings:TOKENS] parse a string and store tokens into an array (LICENSE:PD)</p>
<h2 id="synopsis-15">SYNOPSIS</h2>
<p>subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)</p>
<pre><code>    character(len=*),intent(in)  :: line
    integer,integer(in)          :: n
    integer,intent(out)          :: icount
    character(len=*)             :: array(n)
    integer,intent(out)          :: ibegin(n)
    integer,intent(out)          :: iterm(n)
    integer,intent(out)          :: lgth
    character(len=*)             :: dlim
</code></pre>
<h2 id="description-15">DESCRIPTION</h2>
<p>Given a LINE of structure " par1 par2 par3 ``` parn " store each par(n) into a separate variable in ARRAY (UNLESS ARRAY(1) == '#N#')</p>
<p>Also set ICOUNT to number of elements of array initialized, and return beginning and ending positions for each element in IBEGIN(N) and ITERM(N).</p>
<p>Return position of last non-blank character (even if more than N elements were found) in lgth</p>
<p>No quoting or escaping of delimiter is allowed, so the delimiter character can not be placed in a token.</p>
<p>No checking for more than N parameters; If any more they are ignored.</p>
<p>This routine originates pre-Fortran90. A version using optional parameters and allocatable arrays is on the TODO list.</p>
<h2 id="options-14">OPTIONS</h2>
<ul>
<li><p><strong>LINE</strong><br />
input string to parse into tokens</p></li>
<li><p><strong>ARRAY(N)</strong><br />
array that receives tokens</p></li>
<li><p><strong>N</strong><br />
size of arrays ARRAY, IBEGIN, ITERM</p></li>
<li><p><strong>ICOUNT</strong><br />
number of tokens found</p></li>
<li><p><strong>IBEGIN(N)</strong><br />
starting columns of tokens found</p></li>
<li><p><strong>ITERM(N)</strong><br />
ending columns of tokens found</p></li>
<li><p><strong>LGTH</strong><br />
position of last non-blank character in input string LINE</p></li>
<li><p><strong>DLIM</strong><br />
delimiter characters</p></li>
</ul>
<h2 id="examples-15">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_delim

    use M_strings, only: delim
    implicit none
    character(len=80) :: line
    character(len=80) :: dlm
    integer,parameter :: n=80
    character(len=20) :: array(n)=&#39; &#39;
    integer           :: ibegin(n),iterm(n)
    integer           :: i20, icount, lgth, i10,i30
    line=&#39; first  second 10.3 words_of_stuff  &#39;
    do i20=1,4
       ! change delimiter list and what is calculated or parsed
       if(i20 == 1)dlm=&#39; &#39;
       if(i20 == 2)dlm=&#39;o&#39;
       if(i20 == 3)dlm=&#39; aeiou&#39;    ! NOTE SPACE IS FIRST
       if(i20 == 3)ARRAY(1)=&#39;#N#&#39;  ! QUIT RETURNING STRING ARRAY
       if(i20 == 4)line=&#39;AAAaBBBBBBbIIIIIi  J K L&#39;

       ! write out a break line composed of =========== ..
       write(*,&#39;(57(&quot;=&quot;))&#39;)
       ! show line being parsed
       write(*,&#39;(a)&#39;)&#39;PARSING=[&#39;//trim(line)//&#39;] on &#39;//trim(dlm)
       ! call parsing procedure
       call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
       write(*,*)&#39;number of tokens found=&#39;,icount
       write(*,*)&#39;last character in column &#39;,lgth
       if(icount &gt; 0)then
          if(lgth /= iterm(icount))then
             write(*,*)&#39;ignored from column &#39;,iterm(icount)+1,&#39; to &#39;,lgth
          endif
          do i10=1,icount
             ! check flag to see if ARRAY() was set
             if(array(1) /= &#39;#N#&#39;)then
                ! from returned array
                write(*,&#39;(a,a,a)&#39;,advance=&#39;no&#39;)&amp;
                &amp;&#39;[&#39;,array(i10)(:iterm(i10)-ibegin(i10)+1),&#39;]&#39;
             endif
          enddo
          ! using start and end positions in IBEGIN() and ITERM()
          write(*,*)
          do i10=1,icount
             ! from positions in original line
             write(*,&#39;(a,a,a)&#39;,advance=&#39;no&#39;)&amp;
             &amp;&#39;[&#39;,line(ibegin(i10):iterm(i10)),&#39;]&#39;
          enddo
          write(*,*)
       endif
    enddo
       line=&#39;four    score and   seven  years ago&#39;
       call delim(line,[&quot;#N#&quot;],n,icount,ibegin,iterm,lgth,&#39; &#39;)
       do i30=1,icount
          write(*,*)ibegin(i30),iterm(i30),&amp;
          &amp; &#39;[&#39;//line(ibegin(i30):iterm(i30))//&#39;]&#39;
       enddo

    end program demo_delim
</code></pre>
<p>Results:</p>
<pre><code> &gt; =========================================================
 &gt; PARSING=[ first  second 10.3 words_of_stuff] on
 &gt;  number of tokens found=           4
 &gt;  last character in column           34
 &gt; [first][second][10.3][words_of_stuff]
 &gt; [first][second][10.3][words_of_stuff]
 &gt; =========================================================
 &gt; PARSING=[ first  second 10.3 words_of_stuff] on o
 &gt;  number of tokens found=           4
 &gt;  last character in column           34
 &gt; [ first  sec][nd 10.3 w][rds_][f_stuff]
 &gt; [ first  sec][nd 10.3 w][rds_][f_stuff]
 &gt; =========================================================
 &gt; PARSING=[ first  second 10.3 words_of_stuff] on  aeiou
 &gt;  number of tokens found=          10
 &gt;  last character in column           34
 &gt;
 &gt; [f][rst][s][c][nd][10.3][w][rds_][f_st][ff]
 &gt; =========================================================
 &gt; PARSING=[AAAaBBBBBBbIIIIIi  J K L] on  aeiou
 &gt;  number of tokens found=           5
 &gt;  last character in column           24
 &gt;
 &gt; [AAA][BBBBBBbIIIII][J][K][L]
 &gt;            1           4 [four]
 &gt;            9          13 [score]
 &gt;           15          17 [and]
 &gt;           21          25 [seven]
 &gt;           28          32 [years]
 &gt;           34          36 [ago]
</code></pre>
<p>================================================================================</p>
<h2 id="author-15">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-15">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-16" class="slide section level1">
<h1>NAME</h1>
<p>describe(3f) - [M_strings:DESCRIBE] returns a string describing the name of a single character (LICENSE:PD)</p>
<h2 id="synopsis-16">SYNOPSIS</h2>
<p>function describe(ch) result (string)</p>
<pre><code>    character(len=1),intent(in)   :: ch
    character(len=:),allocatable  :: string
</code></pre>
<h2 id="description-16">DESCRIPTION</h2>
<p>describe(3f) returns a string describing long name of a single character</p>
<h2 id="examples-16">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_describe
    use M_strings, only : describe
    implicit none
    integer :: i
       do i=1,128  ! fill variable with base ASCII character set
          write(*,*)describe(char(i-1))
       enddo
   end program demo_describe
</code></pre>
<p>Expected output</p>
<pre><code>    ctrl-@ or ctrl-? (NUL) null
    ctrl-A (SOH) start of heading
    ctrl-B (STX) start of text
    ctrl-C (ETX) end of text
    ctrl-D (EOT) end of transmission
    ctrl-E (ENQ) enquiry
    ctrl-F (ACK) acknowledge
    ctrl-G (BEL) bell
    ctrl-H (BS) backspace
    ctrl-I (HT) horizontal tabulation
    ctrl-J (LF) line feed
    ctrl-K (VT) vertical tabulation
    ctrl-L (FF) form feed
    ctrl-M (CR) carriage return
    ctrl-N (SO) shift out
    ctrl-O (SI) shift in
    ctrl-P (DLE) data link escape
    ctrl-Q (DC1) device control 1
    ctrl-R (DC2) device control 2
    ctrl-S (DC3) device control 3
    ctrl-T (DC4) device control 4
    ctrl-U (NAK) negative acknowledge
    ctrl-V (SYN) synchronous idle
    ctrl-W (ETB) end of transmission block
    ctrl-X (CAN) cancel
    ctrl-Y (EM) end of medium
    ctrl-Z (SUB) substitute
    ctrl-[ (ESC) escape
    ctrl-\ or ctrl-@ (FS) file separator
    ctrl-] (GS) group separator
    ctrl-^ or ctrl-= (RS) record separator
    ctrl-_ (US) unit separator
    space
    ! exclamation point
    &quot; quotation marks
    # number sign
    $ currency symbol
    % percent
    &amp; ampersand
    &#39; apostrophe
    ( left parenthesis
    ) right parenthesis
    * asterisk
    + plus
    , comma
    - minus
    . period
    / slash
    0 zero
    1 one
    2 two
    3 three
    4 four
    5 five
    6 six
    7 seven
    8 eight
    9 nine
    : colon
    ; semicolon
    &lt; less than
    = equals
    &gt; greater than
    ? question mark
    @ at sign
    majuscule A
    majuscule B
    majuscule C
    majuscule D
    majuscule E
    majuscule F
    majuscule G
    majuscule H
    majuscule I
    majuscule J
    majuscule K
    majuscule L
    majuscule M
    majuscule N
    majuscule O
    majuscule P
    majuscule Q
    majuscule R
    majuscule S
    majuscule T
    majuscule U
    majuscule V
    majuscule W
    majuscule X
    majuscule Y
    majuscule Z
    [ left bracket
    \ backslash
    ] right bracket
    ^ caret
    _ underscore
    ` grave accent
    miniscule a
    miniscule b
    miniscule c
    miniscule d
    miniscule e
    miniscule f
    miniscule g
    miniscule h
    miniscule i
    miniscule j
    miniscule k
    miniscule l
    miniscule m
    miniscule n
    miniscule o
    miniscule p
    miniscule q
    miniscule r
    miniscule s
    miniscule t
    miniscule u
    miniscule v
    miniscule w
    miniscule x
    miniscule y
    miniscule z
    { left brace
    | vertical line
    } right brace
    ~ tilde
    ctrl-? (DEL) delete
</code></pre>
<h2 id="author-16">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-16">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-17" class="slide section level1">
<h1>NAME</h1>
<p>dilate(3f) - [M_strings:NONALPHA] expand tab characters (LICENSE:PD)</p>
<h2 id="synopsis-17">SYNOPSIS</h2>
<p>function dilate(INSTR) result(OUTSTR)</p>
<pre><code>    character(len=*),intent=(in)  :: INSTR
    character(len=:),allocatable  :: OUTSTR
</code></pre>
<h2 id="description-17">DESCRIPTION</h2>
<ul>
<li><strong>dilate() converts tabs in INSTR to spaces in OUTSTR.</strong><br />
It assumes a tab is set every 8 characters. Trailing spaces are removed.</li>
</ul>
<p>In addition, trailing carriage returns and line feeds are removed (they are usually a problem created by going to and from MSWindows).</p>
<h2 id="options-15">OPTIONS</h2>
<ul>
<li><strong>instr</strong><br />
Input line to remove tabs from</li>
</ul>
<h2 id="returns-10">RETURNS</h2>
<ul>
<li><strong>outstr</strong><br />
Output string with tabs expanded.</li>
</ul>
<h2 id="examples-17">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_dilate

   use M_strings, only : dilate, visible
   implicit none
   character(len=:),allocatable :: in
   integer                      :: i
      in=&#39;  this is my string  &#39;
      ! change spaces to tabs to make a sample input
      do i=1,len(in)
         if(in(i:i) == &#39; &#39;)in(i:i)=char(9)
      enddo
      write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;)visible(in)
      write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;)visible(dilate(in))
   end program demo_dilate
</code></pre>
<p>Results:</p>
<pre><code>   &gt; [^I^Ithis^Iis^Imy^Istring^I^I]
   &gt; [                this    is      my      string]
</code></pre>
<h2 id="author-17">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-17">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-18" class="slide section level1">
<h1>NAME</h1>
<p>edit_distance(3f) - [M_strings:DESCRIBE] returns a naive edit distance using the Levenshtein distance algorithm (LICENSE:PD)</p>
<h2 id="synopsis-18">SYNOPSIS</h2>
<p>pure elemental function edit_distance(str1,str2) result (distance)</p>
<pre><code>    character(len=*),intent(in)   :: str1, str2
    integer :: distance
</code></pre>
<h2 id="description-18">DESCRIPTION</h2>
<p>The Levenshtein distance function returns how many edits (deletions, insertions, transposition) are required to turn one string into another.</p>
<h2 id="examples-18">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_edit_distance
   use M_strings, only : edit_distance
      write(*,*)edit_distance(&#39;kittens&#39;,&#39;sitting&#39;)==3
      write(*,*)edit_distance(&#39;geek&#39;,&#39;gesek&#39;)==1
      write(*,*)edit_distance(&#39;Saturday&#39;,&#39;Sunday&#39;)==3
   end program demo_edit_distance
</code></pre>
<p>Expected output</p>
<pre><code>    &gt; T
    &gt; T
    &gt; T
</code></pre>
<h2 id="author-18">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-18">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-19" class="slide section level1">
<h1>NAME</h1>
<p>ends_with(3f) - [M_strings:COMPARE] test if string ends with specified suffix(es) (LICENSE:PD)</p>
<h2 id="synopsis-19">SYNOPSIS</h2>
<p>function ends_with(source_string,suffix)</p>
<pre><code>    or
</code></pre>
<p>function ends_with(source_string,[suffix])</p>
<pre><code>    character(len=*),intent(in)          :: source_string
    character(len=*),intent(in)          :: suffix(..)
    logical                              :: ends_with
</code></pre>
<h2 id="description-19">DESCRIPTION</h2>
<h2 id="options-16">OPTIONS</h2>
<ul>
<li><p><strong>SOURCE_STRING</strong><br />
string to tokenize</p></li>
<li><p><strong>SUFFIX</strong><br />
list of separator strings. May be scalar or an array. Trailing spaces are ignored.</p></li>
</ul>
<h2 id="returns-11">RETURNS</h2>
<ul>
<li><strong>ENDS_WITH</strong><br />
returns .TRUE. if one of the suffix match the end of SOURCE_STRING.</li>
</ul>
<h2 id="examples-19">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_ends_with
   use M_strings, only : ends_with
   use, intrinsic :: iso_fortran_env, only : stdout=&gt;output_unit
   implicit none
      write(stdout,*)ends_with(&#39;prog.a&#39;,[&#39;.o&#39;,&#39;.i&#39;,&#39;.s&#39;])
      write(stdout,*)ends_with(&#39;prog.f90&#39;,[&#39;.F90&#39;,&#39;.f90&#39;,&#39;.f  &#39;,&#39;.F  &#39;])
      write(stdout,*)ends_with(&#39;prog.pdf&#39;,&#39;.pdf&#39;)
      write(stdout,*)ends_with(&#39;prog.doc&#39;,&#39;.txt&#39;)
   end program demo_ends_with
</code></pre>
<p>Results:</p>
<pre><code>    &gt; F
    &gt; T
    &gt; T
    &gt; F
</code></pre>
<h2 id="author-19">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-19">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-20" class="slide section level1">
<h1>NAME</h1>
<p>expand(3f) - [M_strings:NONALPHA] expand C-like escape sequences (LICENSE:PD)</p>
<h2 id="synopsis-20">SYNOPSIS</h2>
<p>function expand(line,escape) result(lineout)</p>
<pre><code>   character(len=*)                      :: line
   character(len=1),intent(in),optional  :: escape
   character(len=:),allocatable          :: lineout
</code></pre>
<h2 id="description-20">DESCRIPTION</h2>
<p>EXPAND() expands sequences used to represent commonly used escape sequences or control characters. By default ```</p>
<p>Escape sequences</p>
<pre><code>      \      backslash
      a      alert (BEL) -- g is an alias for a
      b      backspace
      c      suppress further output
      e      escape
      f      form feed
      n      new line
      r      carriage return
      t      horizontal tab
      v      vertical tab
      oNNN   byte with octal value NNN (3 digits)
      dNNN   byte with decimal value NNN (3 digits)
      xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
</code></pre>
<p>The default escape character is the backslash, but this may be changed using the optional parameter ESCAPE.</p>
<h2 id="examples-20">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_expand
      use M_strings, only : expand
      integer,parameter     :: iwidth=1024
      integer               :: i
      character(len=iwidth),parameter :: input(*)=[ character(len=iwidth) :: &amp;
         &#39;\e[H\e[2J&#39;,&amp;
         &#39;\tABC\tabc&#39;,&amp;
         &#39;\tA\a&#39;,&amp;
         &#39;\nONE\nTWO\nTHREE&#39;,&amp;
         &#39;\\&#39;]
         write(*,&#39;(a)&#39;)(trim(expand(input(i))),i=1,size(input))
   end program demo_expand
</code></pre>
<p>Results (with nonprintable characters shown visible):</p>
<pre><code>    &gt; ^[[H^[[2J
    &gt; ^IABC^Iabc
    &gt; ^IA^G
    &gt;
    &gt; ONE
    &gt; TWO
    &gt; THREE
    &gt; \
</code></pre>
<h2 id="author-20">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-20">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-21" class="slide section level1">
<h1>NAME</h1>
<p>find_field(3f) - [M_strings:TOKENS] parse a string into tokens (LICENSE:MIT)</p>
<h2 id="synopsis-21">SYNOPSIS</h2>
<p>subroutine find_field (string, field, position, delims, delim, found)</p>
<pre><code>    character*(*),intent(in)           :: string
    character*(*),intent(out)          :: field
    integer,optional,intent(inout)     :: position
    character*(*),optional,intent(in)  :: delims
    character*(*),optional,intent(out) :: delim
    logical,optional,intent(out)       :: found
</code></pre>
<h2 id="description-21">DESCRIPTION</h2>
<p>Find a delimited field in a string.</p>
<p>Here's my equivalent, which I've used for nearly 2 decades, as you can see from the date. This doesn't try to mimic the C strtok (and doesn't have its limitations either). It is in a much more native Fortran style.</p>
<p>It is a little more complicated than some because it does some things that I regularly find useful. For example, it can tell the caller what trailing delimiter it found. This can be useful, for example, to distinguish between</p>
<pre><code>       somefield, someotherfield
</code></pre>
<p>versus</p>
<pre><code>       somefield=somevalue, someotherfield
</code></pre>
<p>Also, I have a bit of special handling for blanks. All the usage information is in the argument descriptions. Note that most of the arguments are optional.</p>
<p>from comp.lang.fortran @ Richard Maine</p>
<h2 id="options-17">OPTIONS</h2>
<ul>
<li><p><strong>STRING</strong><br />
The string input.</p></li>
<li><p><strong>FIELD</strong><br />
The returned field. Blank if no field found.</p></li>
<li><p><strong>POSITION</strong><br />
On entry, the starting position for searching for the field. Default is 1 if the argument is not present. On exit, the starting position of the next field or len(string)+1 if there is no following field.</p></li>
<li><p><strong>DELIMS</strong><br />
String containing the characters to be accepted as delimiters. If this includes a blank character, then leading blanks are removed from the returned field and the end delimiter may optionally be preceded by blanks. If this argument is not present, the default delimiter set is a blank.</p></li>
<li><p><strong>DELIM</strong><br />
Returns the actual delimiter that terminated the field. Returns char(0) if the field was terminated by the end of the string or if no field was found. If blank is in delimiters and the field was terminated by one or more blanks, followed by a non-blank delimiter, the non-blank delimiter is returned.</p></li>
<li><p><strong>FOUND</strong><br />
True if a field was found.</p></li>
</ul>
<h2 id="examples-21">EXAMPLES</h2>
<p>Sample of uses</p>
<pre><code>       program demo_find_field
       use M_strings, only : find_field
       implicit none
       character(len=256)           :: string
       character(len=256)           :: field
       integer                      :: position
       character(len=:),allocatable :: delims
       character(len=1)             :: delim
       logical                      :: found

       delims=&#39;[,]&#39;
       position=1
       found=.true.
       string=&#39;[a,b,[ccc,ddd],and more]&#39;
       write(*,&#39;(a)&#39;)trim(string)
       do
          call find_field(string,field,position,delims,delim,found=found)
          if(.not.found)exit
          write(*,&#39;(&quot;&lt;&quot;,a,&quot;&gt;&quot;)&#39;)trim(field)
       enddo
       write(*,&#39;(*(g0))&#39;)repeat(&#39;=&#39;,70)

       position=1
       found=.true.
       write(*,&#39;(a)&#39;)trim(string)
       do
          call find_field(string,field,position,&#39;[], &#39;,delim,found=found)
          if(.not.found)exit
          write(*,&#39;(&quot;&lt;&quot;,a,&quot;&gt;&quot;,i0,1x,a)&#39;)trim(field),position,delim
       enddo
       write(*,&#39;(*(g0))&#39;)repeat(&#39;=&#39;,70)

       end program demo_find_field
</code></pre>
<p>Results:</p>
<pre><code>    &gt; [a,b,[ccc,ddd],and more]
    &gt; &lt;&gt;
    &gt; &lt;a&gt;
    &gt; &lt;b&gt;
    &gt; &lt;&gt;
    &gt; &lt;ccc&gt;
    &gt; &lt;ddd&gt;
    &gt; &lt;&gt;
    &gt; &lt;and more&gt;
    &gt; &lt;&gt;
    &gt; ==================================================================
    &gt; [a,b,[ccc,ddd],and more]
    &gt; &lt;&gt;2 [
    &gt; &lt;a&gt;4 ,
    &gt; &lt;b&gt;6 ,
    &gt; &lt;&gt;7 [
    &gt; &lt;ccc&gt;11 ,
    &gt; &lt;ddd&gt;15 ]
    &gt; &lt;&gt;16 ,
    &gt; &lt;and&gt;20
    &gt; &lt;more&gt;257 ]
    &gt; ==================================================================
</code></pre>
<h2 id="author-21">AUTHOR</h2>
<p>Richard Maine</p>
<h2 id="license-21">LICENSE</h2>
<h3 id="mit">MIT</h3>
<h2 id="version">VERSION</h2>
<p>version 0.1.0, copyright Nov 15 1990, Richard Maine</p>
<p>Minor editing to conform to inclusion in the string procedure module</p>
</div>
<div id="name-22" class="slide section level1">
<h1>NAME</h1>
<p>fortran_name(3f) - [M_strings:COMPARE] test if string meets criteria for being a fortran name</p>
<h2 id="synopsis-22">SYNOPSIS</h2>
<p>elemental function fortran_name(line) result (lout)</p>
<pre><code>     character(len=*),intent(in)  :: line
     logical                      :: lout
</code></pre>
<h2 id="description-22">DESCRIPTION</h2>
<p>Determines if a string is an allowed Fortran name. To pass the input string must be composed of 1 to 63 ASCII characters and start with a letter and be composed entirely of alphanumeric characters [a-zA-Z0-9] and underscores.</p>
<h2 id="options-18">OPTIONS</h2>
<ul>
<li><strong>LINE</strong><br />
input string to test. Leading spaces are significant but trailing spaces are ignored.</li>
</ul>
<h2 id="returns-12">RETURNS</h2>
<ul>
<li><strong>LOUT</strong><br />
a logical value indicating if the input string passed or failed the test to see if it is a valid Fortran name or not.</li>
</ul>
<h2 id="examples-22">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>     program demo_fortran_name
     use M_strings, only : fortran_name
     implicit none
     character(len=20),parameter :: names(*)=[character(len=20) ::  &amp;
      &amp; &#39;_name&#39;,         &#39;long_variable_name&#39;, &#39;name_&#39;,         &amp;
      &amp; &#39;12L&#39;,           &#39;a__b__c  &#39;,          &#39;PropertyOfGas&#39;, &amp;
      &amp; &#39;3%3&#39;,           &#39;$NAME&#39;,              &#39; &#39;,             &amp;
      &amp; &#39;Variable-name&#39;, &#39;A&#39;,                  &#39;x@x&#39; ]
     integer :: i
        write(*,&#39;(i3,1x,a20,1x,l1)&#39;)&amp;
        &amp; (i,names(i),fortran_name(names(i)),i=1,size(names))
     end program demo_fortran_name
</code></pre>
<p>Results:</p>
<pre><code>     &gt;  1 _name                F
     &gt;  2 long_variable_name   T
     &gt;  3 name_                T
     &gt;  4 12L                  F
     &gt;  5 a__b__c              T
     &gt;  6 PropertyOfGas        T
     &gt;  7 3%3                  F
     &gt;  8 $NAME                F
     &gt;  9                      F
     &gt; 10 Variable-name        F
     &gt; 11 A                    T
     &gt; 12 x@x                  F
</code></pre>
</div>
<div id="name-23" class="slide section level1">
<h1>NAME</h1>
<p>getvals(3f) - [M_strings:TYPE] read arbitrary number of REAL values from a character variable up to size of VALUES() array (LICENSE:PD)</p>
<h2 id="synopsis-23">SYNOPSIS</h2>
<p>subroutine getvals(line,values,icount,ierr)</p>
<pre><code>    character(len=*),intent(in)  :: line
    class(*),intent(out)         :: values(:)
    integer,intent(out)          :: icount
    integer,intent(out),optional :: ierr
</code></pre>
<h2 id="description-23">DESCRIPTION</h2>
<p>GETVALS(3f) reads a relatively arbitrary number of numeric values from a character variable into a REAL array using list-directed input.</p>
<p>NOTE: In this version null values are skipped instead of meaning to leave that value unchanged</p>
<blockquote>
<p>1,,,,,,,2 / reads VALUES=[1.0,2.0]</p>
</blockquote>
<p>Per list-directed rules when reading values, allowed delimiters are comma, semi-colon and space.</p>
<p>the slash separator can be used to add inline comments.</p>
<pre><code>       10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
</code></pre>
<p>Repeat syntax can be used up to the size of the output array. These are equivalent input lines:</p>
<pre><code>       4*10.0
       10.0, 10.0, 10.0, 10.0
</code></pre>
<h2 id="options-19">OPTIONS</h2>
<ul>
<li><strong>LINE</strong><br />
A character variable containing the characters representing a list of numbers</li>
</ul>
<h2 id="returns-13">RETURNS</h2>
<ul>
<li><p><strong>VALUES()</strong><br />
array holding numbers read from string. May be of type INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the strings are returned as simple words instead of numeric values.</p></li>
<li><p><strong>ICOUNT</strong><br />
number of defined numbers in VALUES(). If ICOUNT reaches the size of the VALUES() array parsing stops.</p></li>
<li><p><strong>IERR</strong><br />
zero if no error occurred in reading numbers. Optional. If not present and an error occurs the program is terminated.</p></li>
</ul>
<h2 id="examples-23">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>      program demo_getvals
      use M_strings, only: getvals
      implicit none
      integer,parameter  :: longest_line=256
      character(len=longest_line) :: line
      real               :: values(longest_line/2+1)
      integer            :: ios,icount,ierr
      INFINITE: do
         read(*,&#39;(a)&#39;,iostat=ios) line
         if(ios /= 0)exit INFINITE
         call getvals(line,values,icount,ierr)
         write(*,&#39;(4(g0,1x))&#39;)&#39;VALUES=&#39;,values(:icount)
      enddo INFINITE
      end program demo_getvals
</code></pre>
<p>Sample input lines</p>
<pre><code>       10,20 30.4
       1 2 3
       1

       3 4*2.5 8
       32.3333 / comment 1
       30e3;300,    30.0, 3
       even 1 like this! 10
       11,,,,22,,,,33
</code></pre>
<p>Expected output:</p>
<pre><code>    VALUES=   10.0000000       20.0000000       30.3999996
    VALUES=   1.00000000       2.00000000       3.00000000
    VALUES=   1.00000000
    VALUES=
    VALUES=   3.00000000       2.50000000       2.50000000
    2.50000000       2.50000000       8.00000000
    VALUES=   32.3333015
    VALUES=   30000.0000       300.000000       30.0000000
    3.00000000
    *getvals* WARNING:[even] is not a number
    *getvals* WARNING:[like] is not a number
    *getvals* WARNING:[this!] is not a number
    VALUES=   1.00000000       10.0000000
    VALUES=   11.0000000       22.0000000       33.0000000
</code></pre>
<h2 id="author-22">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-22">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-24" class="slide section level1">
<h1>NAME</h1>
<p>glob(3f) - [M_strings:COMPARE] compare given string for match to a pattern which may contain globbing wildcard characters (LICENSE:PD)</p>
<h2 id="synopsis-24">SYNOPSIS</h2>
<p>logical function glob(string, pattern )</p>
<pre><code>    character(len=*),intent(in) :: string
    character(len=*),intent(in) :: pattern
</code></pre>
<h2 id="description-24">DESCRIPTION</h2>
<p>glob(3f) compares given (entire) STRING for a match to PATTERN which may contain basic wildcard "globbing" characters.</p>
<p>In this version to get a match the entire string must be described by PATTERN. Trailing whitespace is significant, so trim the input string to have trailing whitespace ignored.</p>
<p>Patterns like "b*ba" fail on a string like "babababa" because the algorithm finds an early match. To skip over the early matches insert an extra character at the end of the string and pattern that does not occur in the pattern. Typically a NULL is used (char(0)).</p>
<h2 id="options-20">OPTIONS</h2>
<ul>
<li><p><strong>string</strong><br />
the input string to test to see if it contains the pattern.</p></li>
<li><p><strong>pattern</strong><br />
the following simple globbing options are available</p>
<ul>
<li><p>"?" matching any one character</p></li>
<li><p>"*" matching zero or more characters. Do NOT use adjacent asterisks.</p></li>
<li><p>spaces are significant and must be matched or pretrimmed</p></li>
<li><p>There is no escape character, so matching strings with literal question mark and asterisk is problematic.</p></li>
</ul></li>
</ul>
<h2 id="examples-24">EXAMPLES</h2>
<p>Example program</p>
<pre><code>   program demo_glob
   implicit none
   ! This main() routine passes a bunch of test strings
   ! into the above code.  In performance comparison mode,
   ! it does that over and over. Otherwise, it does it just
   ! once. Either way, it outputs a passed/failed result.
   !
   integer :: nReps
   logical :: allpassed
   integer :: i
   allpassed = .true.

   nReps = 10000
   ! Can choose as many repetitions as you&#39;re expecting
   ! in the real world.
   nReps = 1

   do i=1,nReps
      ! Cases with repeating character sequences.
      allpassed= test(&quot;a*abab&quot;,      &quot;a*b&quot;,   .true.)  .and. allpassed
      allpassed= test(&quot;ab&quot;,          &quot;*?&quot;,    .true.)  .and. allpassed
      allpassed= test(&quot;abc&quot;,         &quot;*?&quot;,    .true.)  .and. allpassed
      allpassed= test(&quot;abcccd&quot;,      &quot;*ccd&quot;,  .true.)  .and. allpassed
      allpassed= test(&quot;bLah&quot;,        &quot;bLaH&quot;,  .false.) .and. allpassed
      allpassed= test(&quot;mississippi&quot;, &quot;*sip*&quot;, .true.)  .and. allpassed
      allpassed= &amp;
       &amp; test(&quot;xxxx*zzzzzzzzy*f&quot;, &quot;xxx*zzy*f&quot;, .true.) .and. allpassed
      allpassed= &amp;
       &amp; test(&quot;xxxx*zzzzzzzzy*f&quot;, &quot;xxxx*zzy*fffff&quot;, .false.) .and. allpassed
      allpassed= &amp;
       &amp; test(&quot;mississipissippi&quot;, &quot;*issip*ss*&quot;, .true.) .and. allpassed
      allpassed= &amp;
       &amp; test(&quot;xxxxzzzzzzzzyf&quot;, &quot;xxxx*zzy*fffff&quot;, .false.) .and. allpassed
      allpassed= &amp;
       &amp; test(&quot;xxxxzzzzzzzzyf&quot;, &quot;xxxx*zzy*f&quot;, .true.) .and. allpassed
      allpassed= test(&quot;xyxyxyzyxyz&quot;, &quot;xy*z*xyz&quot;, .true.)  .and. allpassed
      allpassed= test(&quot;xyxyxyxyz&quot;,   &quot;xy*xyz&quot;,   .true.)  .and. allpassed
      allpassed= test(&quot;mississippi&quot;, &quot;mi*sip*&quot;,  .true.)  .and. allpassed
      allpassed= test(&quot;ababac&quot;,      &quot;*abac*&quot;,   .true.)  .and. allpassed
      allpassed= test(&quot;aaazz&quot;,       &quot;a*zz*&quot;,    .true.)  .and. allpassed
      allpassed= test(&quot;a12b12&quot;,      &quot;*12*23&quot;,   .false.) .and. allpassed
      allpassed= test(&quot;a12b12&quot;,      &quot;a12b&quot;,     .false.) .and. allpassed
      allpassed= test(&quot;a12b12&quot;,      &quot;*12*12*&quot;,  .true.)  .and. allpassed

      ! Additional cases where the &#39;*&#39; char appears in the tame string.
      allpassed= test(&quot;*&quot;,     &quot;*&quot;,      .true.)  .and. allpassed
      allpassed= test(&quot;a*r&quot;,   &quot;a*&quot;,     .true.)  .and. allpassed
      allpassed= test(&quot;a*ar&quot;,  &quot;a*aar&quot;,  .false.) .and. allpassed

      ! More double wildcard scenarios.
      allpassed= test(&quot;XYXYXYZYXYz&quot;, &quot;XY*Z*XYz&quot;,  .true.)  .and. allpassed
      allpassed= test(&quot;missisSIPpi&quot;, &quot;*SIP*&quot;,     .true.)  .and. allpassed
      allpassed= test(&quot;mississipPI&quot;, &quot;*issip*PI&quot;, .true.)  .and. allpassed
      allpassed= test(&quot;xyxyxyxyz&quot;,   &quot;xy*xyz&quot;,    .true.)  .and. allpassed
      allpassed= test(&quot;miSsissippi&quot;, &quot;mi*sip*&quot;,   .true.)  .and. allpassed
      allpassed= test(&quot;miSsissippi&quot;, &quot;mi*Sip*&quot;,   .false.) .and. allpassed
      allpassed= test(&quot;abAbac&quot;,      &quot;*Abac*&quot;,    .true.)  .and. allpassed
      allpassed= test(&quot;aAazz&quot;,       &quot;a*zz*&quot;,     .true.)  .and. allpassed
      allpassed= test(&quot;A12b12&quot;,      &quot;*12*23&quot;,    .false.) .and. allpassed
      allpassed= test(&quot;a12B12&quot;,      &quot;*12*12*&quot;,   .true.)  .and. allpassed
      allpassed= test(&quot;oWn&quot;,         &quot;*oWn*&quot;,     .true.)  .and. allpassed

      ! Completely tame (no wildcards) cases.
      allpassed= test(&quot;bLah&quot;, &quot;bLah&quot;, .true.) .and. allpassed

      ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
      allpassed= test(&quot;a&quot;, &quot;*?&quot;, .true.) .and. allpassed

      ! More mixed wildcard tests including coverage for false positives.
      allpassed= test(&quot;a&quot;,      &quot;??&quot;,         .false.) .and. allpassed
      allpassed= test(&quot;ab&quot;,     &quot;?*?&quot;,        .true.)  .and. allpassed
      allpassed= test(&quot;ab&quot;,     &quot;*?*?*&quot;,      .true.)  .and. allpassed
      allpassed= test(&quot;abc&quot;,    &quot;?**?*?&quot;,     .true.)  .and. allpassed
      allpassed= test(&quot;abc&quot;,    &quot;?**?*&amp;?&quot;,    .false.) .and. allpassed
      allpassed= test(&quot;abcd&quot;,   &quot;?b*??&quot;,      .true.)  .and. allpassed
      allpassed= test(&quot;abcd&quot;,   &quot;?a*??&quot;,      .false.) .and. allpassed
      allpassed= test(&quot;abcd&quot;,   &quot;?**?c?&quot;,     .true.)  .and. allpassed
      allpassed= test(&quot;abcd&quot;,   &quot;?**?d?&quot;,     .false.) .and. allpassed
      allpassed= test(&quot;abcde&quot;,  &quot;?*b*?*d*?&quot;,  .true.)  .and. allpassed

      ! Single-character-match cases.
      allpassed= test(&quot;bLah&quot;,   &quot;bL?h&quot;,  .true.)  .and. allpassed
      allpassed= test(&quot;bLaaa&quot;,  &quot;bLa?&quot;,  .false.) .and. allpassed
      allpassed= test(&quot;bLah&quot;,   &quot;bLa?&quot;,  .true.)  .and. allpassed
      allpassed= test(&quot;bLaH&quot;,   &quot;?Lah&quot;,  .false.) .and. allpassed
      allpassed= test(&quot;bLaH&quot;,   &quot;?LaH&quot;,  .true.)  .and. allpassed

      allpassed= test(&#39;abcdefghijk&#39; ,  &#39;?b*&#39;,     .true.)  .and. allpassed
      allpassed= test(&#39;abcdefghijk&#39; ,  &#39;*c*&#39;,     .true.)  .and. allpassed
      allpassed= test(&#39;abcdefghijk&#39; ,  &#39;*c&#39;,      .false.) .and.  allpassed
      allpassed= test(&#39;abcdefghijk&#39; ,  &#39;*c*k&#39;,    .true.)  .and. allpassed
      allpassed= test(&#39;LS&#39;          ,  &#39;?OW&#39;,     .false.) .and.  allpassed
      allpassed= test(&#39;teztit&#39;      ,  &#39;tez*t*t&#39;, .true.)  .and. allpassed
        ! Two pattern match problems that might pose difficulties
      allpassed= test(&#39;e &#39;           , &#39;*e* &#39;,      .true.) .and. allpassed
      allpassed= test(&#39;abcde       &#39; , &#39;*e      *&#39;, .true.) .and. allpassed
      allpassed= test(&#39;bababa&#39;       , &#39;b*ba&#39;,      .true.) .and. allpassed
      allpassed= test(&#39;baaaaax&#39;      , &#39;b*ax&#39;,      .true.) .and. allpassed
      allpassed= test(&#39;baaaaa&#39;       , &#39;b*ax&#39;,      .false.) .and. allpassed
      allpassed= test(&#39;baaaaax&#39;      , &#39;b*a&#39;,       .false.) .and. allpassed
      allpassed= test(&#39;&#39;             , &#39;b*&#39;,        .false.) .and. allpassed
      allpassed= test(&#39;&#39;             , &#39;*&#39;,         .true.) .and.  allpassed
      allpassed= test(&#39;b&#39;            , &#39;&#39;,          .false.) .and. allpassed
      allpassed= test(&#39;3&#39;            , &#39;??&#39;,        .false.) .and. allpassed
      ! known flaws
      allpassed= test(&#39;&#39;             , &#39;&#39;,          .true.) .and. allpassed
      allpassed= test(&#39;baaaaa&#39;       , &#39;b*a&#39;,       .true.) .and. allpassed
      ! add unused character to work around
      allpassed= test(&#39;&#39;//char(0),      &#39;&#39;//char(0),   .true.).and.allpassed
      allpassed= test(&#39;baaaaa&#39;//char(0),&#39;b*a&#39;//char(0),.true.).and.allpassed

      ! Many-wildcard scenarios.
      allpassed= test(&amp;
      &amp;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;
      &amp;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;,&amp;
      &amp;&quot;a*a*a*a*a*a*aa*aaa*a*a*b&quot;,&amp;
      &amp;.true.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abababababababababababababababababababaacacacacacacac&amp;
      &amp;adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab&quot;,&amp;
      &amp;&quot;*a*b*ba*ca*a*aa*aaa*fa*ga*b*&quot;,&amp;
      &amp;.true.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abababababababababababababababababababaacacacacacaca&amp;
      &amp;cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab&quot;,&amp;
      &amp;&quot;*a*b*ba*ca*a*x*aaa*fa*ga*b*&quot;,&amp;
      &amp;.false.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abababababababababababababababababababaacacacacacacacad&amp;
      &amp;aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab&quot;,&amp;
      &amp;&quot;*a*b*ba*ca*aaaa*fa*ga*gggg*b*&quot;,&amp;
      &amp;.false.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abababababababababababababababababababaacacacacacacacad&amp;
      &amp;aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab&quot;,&amp;
      &amp;&quot;*a*b*ba*ca*aaaa*fa*ga*ggg*b*&quot;,&amp;
      &amp;.true.) .and. allpassed
      allpassed= test(&quot;aaabbaabbaab&quot;,&quot;*aabbaa*a*&quot;,.true.).and.allpassed
      allpassed= &amp;
      test(&quot;a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*&quot;,&amp;
      &amp;&quot;a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*&quot;, .true.) .and. allpassed
      allpassed= test(&quot;aaaaaaaaaaaaaaaaa&quot;,&amp;
      &amp;&quot;*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*&quot;, .true.) .and. allpassed
      allpassed= test(&quot;aaaaaaaaaaaaaaaa&quot;,&amp;
      &amp;&quot;*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*&quot;, .false.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&amp;
      &amp;*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn&quot;,&amp;
      &amp; &quot;abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&amp;
      &amp;*abc*abc*abc*&quot;,&amp;
      &amp;.false.) .and. allpassed
      allpassed= test(&amp;
      &amp;&quot;abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&amp;
      &amp;*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn&quot;,&amp;
      &amp;&quot;abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*&quot;,&amp;
      &amp;.true.) .and. allpassed
      allpassed= test(&quot;abc*abcd*abcd*abc*abcd&quot;,&amp;
      &amp;&quot;abc*abc*abc*abc*abc&quot;, .false.) .and. allpassed
      allpassed= test( &quot;abc*abcd*abcd*abc*abcd*abcd&amp;
      &amp;*abc*abcd*abc*abc*abcd&quot;, &amp;
      &amp;&quot;abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd&quot;,&amp;
      &amp;.true.) .and. allpassed
      allpassed= test(&quot;abc&quot;,&amp;
      &amp;&quot;********a********b********c********&quot;, .true.) .and. allpassed
      allpassed=&amp;
      &amp;test(&quot;********a********b********c********&quot;, &quot;abc&quot;,.false.)&amp;
      &amp; .and.allpassed
      allpassed= &amp;
      &amp;test(&quot;abc&quot;, &quot;********a********b********b********&quot;,.false.)&amp;
      &amp; .and.allpassed
      allpassed= test(&quot;*abc*&quot;, &quot;***a*b*c***&quot;, .true.) .and. allpassed

      ! A case-insensitive algorithm test.
      ! allpassed=test(&quot;mississippi&quot;, &quot;*issip*PI&quot;, .true.) .and. allpassed
    enddo

    if (allpassed)then
       write(*,&#39;(*(g0,1x))&#39;)&quot;Passed&quot;,nReps
    else
       write(*,&#39;(a)&#39;)&quot;Failed&quot;
    endif
   contains
   ! This is a test program for wildcard matching routines.
   ! It can be used either to test a single routine for correctness,
   ! or to compare the timings of two (or more) different wildcard
   ! matching routines.
   !
   function test(tame, wild, bExpectedResult) result(bPassed)
   use M_strings, only : glob
      character(len=*) :: tame
      character(len=*) :: wild
      logical          :: bExpectedResult
      logical          :: bResult
      logical          :: bPassed
      bResult = .true.    ! We&#39;ll do &quot;&amp;=&quot; cumulative checking.
      bPassed = .false.   ! Assume the worst.
      write(*,*)repeat(&#39;=&#39;,79)
      bResult = glob(tame, wild) ! Call a wildcard matching routine.

      ! To assist correctness checking, output the two strings in any
      ! failing scenarios.
      if (bExpectedResult .eqv. bResult) then
         bPassed = .true.
         if(nReps == 1) write(*,*)&quot;Passed match on &quot;,tame,&quot; vs. &quot;, wild
      else
         if(nReps == 1) write(*,*)&quot;Failed match on &quot;,tame,&quot; vs. &quot;, wild
      endif

   end function test
   end program demo_glob
</code></pre>
<p>Expected output</p>
<h2 id="author-23">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="references">REFERENCES</h2>
<p>The article "Matching Wildcards: An Empirical Way to Tame an Algorithm" in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014</p>
<h2 id="license-23">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-25" class="slide section level1">
<h1>NAME</h1>
<p>indent(3f) - [M_strings:WHITESPACE] count number of leading spaces in a string (LICENSE:PD)</p>
<h2 id="synopsis-25">SYNOPSIS</h2>
<p>function indent(line)</p>
<pre><code>    integer                        :: indent
    character(len=*),intent(in)    :: line
</code></pre>
<h2 id="description-25">DESCRIPTION</h2>
<p>Count number of leading spaces in a CHARACTER variable.</p>
<h2 id="examples-25">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_indent
   !  test filter to count leading spaces in a character variable
   !  might want to call notabs(3f) to expand tab characters
   use M_strings, only : indent
   implicit none
   character(len=1024) :: in
   integer             :: ios
      READFILE: do
         read(*,&#39;(A)&#39;,iostat=ios)in
         if(ios /= 0) exit READFILE
         write(*,&#39;(i3,&quot;&quot;,a)&#39;)indent(in),trim(in)
      enddo READFILE
   end program demo_indent
</code></pre>
<p>Results:</p>
<pre><code>     &gt; 3   a b c
     &gt; 0a b c
     &gt; 6      a b c
</code></pre>
<h2 id="author-24">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-24">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-26" class="slide section level1">
<h1>NAME</h1>
<p>int(3f) - [M_strings:TYPE] overloads INT(3f) so it can handle character arguments (LICENSE:PD)</p>
<h2 id="synopsis-26">SYNOPSIS</h2>
<p>impure elemental function int(string)</p>
<pre><code>    character(len=*) :: string
    integer(kind=int32) :: int
</code></pre>
<h2 id="description-26">DESCRIPTION</h2>
<p>int(3f) returns an integer when given a numeric representation of a numeric value. This overloads the INT(3f) intrinsic so that CHARACTER arguments assumed to represent a numeric value may be input.</p>
<h2 id="options-21">OPTIONS</h2>
<ul>
<li><strong>STRING</strong><br />
input string to be converted to an INT32 integer</li>
</ul>
<h2 id="returns-14">RETURNS</h2>
<ul>
<li><strong>INT</strong><br />
integer represented by input string</li>
</ul>
<h2 id="examples-26">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_int
     use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
     use M_strings, only: int
     implicit none
     character(len=*),parameter :: g=&#39;(*(g0,1x))&#39;
        write(*,g)int(&#39;100&#39;),int(&#39;20.4&#39;)
        write(*,g)&#39;intrinsic int(3f) still works&#39;,int(20,int32)
        write(*,g)&#39;elemental&#39;,&amp;
        &amp; int([character(len=23) :: &#39;10&#39;,&#39;20.3&#39;,&#39;20.5&#39;,&#39;20.6&#39;])
     end program demo_int
</code></pre>
<p>Results:</p>
<pre><code>    &gt; 100 20
    &gt; intrinsic int(3f) still works 20
    &gt; elemental 10 20 20 20
</code></pre>
<h2 id="author-25">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-25">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-27" class="slide section level1">
<h1>NAME</h1>
<p>isalnum,isalpha,iscntrl,isdigit,isgraph,islower, isprint,ispunct,isspace,isupper, isascii,isblank,isxdigit(3f) - [M_strings:COMPARE] test membership in subsets of ASCII set (LICENSE:PD)</p>
<h2 id="synopsis-27">SYNOPSIS</h2>
<p>Where "FUNCNAME" is one of the function names in the group, the functions are defined by</p>
<pre><code>    elemental function FUNCNAME(onechar)
    character,intent(in) :: onechar
    logical              :: FUNC_NAME
</code></pre>
<h2 id="description-27">DESCRIPTION</h2>
<p>These elemental functions test if a character belongs to various subsets of the ASCII character set.</p>
<ul>
<li><p><strong>isalnum</strong><br />
returns .true. if character is a letter (a-z,A-Z) or digit (0-9)</p></li>
<li><p><strong>isalpha</strong><br />
returns .true. if character is a letter and ï¿½false. otherwise</p></li>
<li><p><strong>isascii</strong><br />
returns .true. if character is in the range char(0) to char(127)</p></li>
<li><p><strong>isblank</strong><br />
returns .true. if character is a blank (space or horizontal tab).</p></li>
<li><p><strong>iscntrl</strong><br />
returns .true. if character is a delete character or ordinary control character (0x7F or 0x00-0x1F).</p></li>
<li><p><strong>isdigit</strong><br />
returns .true. if character is a digit (0,1,```,9) and .false. otherwise</p></li>
<li><p><strong>isgraph</strong><br />
returns .true. if character is a printable ASCII character excluding space</p></li>
<li><p><strong>islower</strong><br />
returns .true. if character is a miniscule letter (a-z)</p></li>
<li><p><strong>isprint</strong><br />
returns .true. if character is a printable ASCII character</p></li>
<li><p><strong>ispunct</strong><br />
returns .true. if character is a printable punctuation character (isgraph(c) &amp;&amp; !isalnum(c)).</p></li>
<li><p><strong>isspace</strong><br />
returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed</p></li>
<li><p><strong>isupper</strong><br />
returns .true. if character is an uppercase letter (A-Z)</p></li>
<li><p><strong>isxdigit</strong><br />
returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).</p></li>
</ul>
<h2 id="examples-27">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_isdigit

    use M_strings, only : isdigit, isspace, switch
    implicit none
    character(len=10),allocatable :: string(:)
    integer                       :: i
       string=[&amp;
       &amp; &#39;1 2 3 4 5 &#39; ,&amp;
       &amp; &#39;letters   &#39; ,&amp;
       &amp; &#39;1234567890&#39; ,&amp;
       &amp; &#39;both 8787 &#39; ]
       ! if string is nothing but digits and whitespace return .true.
       do i=1,size(string)
          write(*,&#39;(a)&#39;,advance=&#39;no&#39;)&#39;For string[&#39;//string(i)//&#39;]&#39;
          write(*,*) &amp;
          all(isdigit(switch(string(i))) .or. &amp;
          &amp; isspace(switch(string(i))))
       enddo

    end program demo_isdigit
</code></pre>
<p>Expected output:</p>
<pre><code>   For string[1 2 3 4 5 ] T
   For string[letters   ] F
   For string[1234567890] T
   For string[both 8787 ] F
</code></pre>
<h2 id="author-26">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-26">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-28" class="slide section level1">
<h1>NAME</h1>
<p>isalpha(3f) - [M_strings:COMPARE] returns .true. if character is a letter and .false. otherwise (LICENSE:PD)</p>
<h2 id="synopsis-28">SYNOPSIS</h2>
<p>elemental function isalpha(onechar)</p>
<pre><code>   character,intent(in) :: onechar
   logical              :: isalpha
</code></pre>
<h2 id="description-28">DESCRIPTION</h2>
<p>isalpha(3f) returns .true. if character is a letter and ï¿½false. otherwise</p>
<h2 id="options-22">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-15">RETURNS</h2>
<ul>
<li><strong>isalpha</strong><br />
logical value returns .true. if character is a ASCII letter or false otherwise.</li>
</ul>
<h2 id="examples-28">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>    program demo_isalpha
    use M_strings, only : isalpha
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(40(a))&#39;)&#39;ISGRAPH: &#39;,pack( string, isalpha(string) )
    end program demo_isalpha
</code></pre>
<p>Results:</p>
<pre><code>   ISGRAPH: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm
   nopqrstuvwxyz
</code></pre>
<h2 id="author-27">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-27">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-29" class="slide section level1">
<h1>NAME</h1>
<p>isascii(3f) - [M_strings:COMPARE] returns .true. if the character is in the range char(0) to char(256) (LICENSE:PD)</p>
<h2 id="synopsis-29">SYNOPSIS</h2>
<p>elemental function isascii(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isascii
</code></pre>
<h2 id="description-29">DESCRIPTION</h2>
<p>isascii(3f) returns .true. if the character is in the range char(0) to char(127)</p>
<h2 id="options-23">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-16">RETURNS</h2>
<ul>
<li><strong>isupper</strong><br />
logical value returns true if character is an ASCII character.</li>
</ul>
<h2 id="examples-29">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>    program demo_isascii
    use M_strings, only : isascii
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,255)]
       write(*,&#39;(10(g0,1x))&#39;)&#39;ISASCII: &#39;, &amp;
       &amp; iachar(pack( string, isascii(string) ))
    end program demo_isascii
</code></pre>
<p>Results:</p>
<pre><code>   ISASCII:  0 1 2 3 4 5 6 7 8
   9 10 11 12 13 14 15 16 17 18
   19 20 21 22 23 24 25 26 27 28
   29 30 31 32 33 34 35 36 37 38
   39 40 41 42 43 44 45 46 47 48
   49 50 51 52 53 54 55 56 57 58
   59 60 61 62 63 64 65 66 67 68
   69 70 71 72 73 74 75 76 77 78
   79 80 81 82 83 84 85 86 87 88
   89 90 91 92 93 94 95 96 97 98
   99 100 101 102 103 104 105 106 107 108
   109 110 111 112 113 114 115 116 117 118
   119 120 121 122 123 124 125 126 127
</code></pre>
<h2 id="author-28">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-28">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-30" class="slide section level1">
<h1>NAME</h1>
<p>isblank(3f) - [M_strings:COMPARE] returns .true. if character is a blank character (space or horizontal tab). (LICENSE:PD)</p>
<h2 id="synopsis-30">SYNOPSIS</h2>
<p>elemental function isblank(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isblank
</code></pre>
<h2 id="description-30">DESCRIPTION</h2>
<p>isblank(3f) returns .true. if character is a blank character (space or horizontal tab).</p>
<h2 id="options-24">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-17">RETURNS</h2>
<ul>
<li><p><strong>isblank</strong><br />
logical value returns true if character is a "blank"</p>
<ul>
<li><strong>( an ASCII</strong><br />
space or horizontal tab character).</li>
</ul></li>
</ul>
<h2 id="examples-30">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_isblank
    use M_strings, only : isblank
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(*(g0,1x))&#39;)&#39;ISXBLANK: &#39;,&amp;
       &amp; iachar(pack( string, isblank(string) ))
    end program demo_isblank
</code></pre>
<p>Results:</p>
<pre><code>   ISXBLANK:  9 32
</code></pre>
<h2 id="author-29">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-29">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-31" class="slide section level1">
<h1>NAME</h1>
<p>iscntrl(3f) - [M_strings:COMPARE] returns .true. if character is a delete character or ordinary control character (LICENSE:PD)</p>
<h2 id="synopsis-31">SYNOPSIS</h2>
<p>elemental function iscntrl(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: iscntrl
</code></pre>
<h2 id="description-31">DESCRIPTION</h2>
<p>iscntrl(3f) returns .true. if character is a delete character or ordinary control character</p>
<h2 id="options-25">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-18">RETURNS</h2>
<ul>
<li><strong>iscntrl</strong><br />
logical value returns true if character is a control character</li>
</ul>
<h2 id="examples-31">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>    program demo_iscntrl
    use M_strings, only : iscntrl
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(20(g0,1x))&#39;)&#39;ISCNTRL: &#39;, &amp;
       &amp; iachar(pack( string, iscntrl(string) ))
    end program demo_iscntrl
</code></pre>
<p>Results:</p>
<pre><code>   ISCNTRL:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
   20 21 22 23 24 25 26 27 28 29 30 31 127
</code></pre>
<h2 id="author-30">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-30">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-32" class="slide section level1">
<h1>NAME</h1>
<p>isdigit(3f) - [M_strings:COMPARE] returns .true. if character is a digit (0,1,```,9) and .false. otherwise (LICENSE:PD)</p>
<h2 id="synopsis-32">SYNOPSIS</h2>
<p>elemental function isdigit(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isdigit
</code></pre>
<h2 id="description-32">DESCRIPTION</h2>
<p>isdigit(3f) returns .true. if character is a digit (0,1,```,9) and .false. otherwise</p>
<h2 id="examples-32">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>    program demo_isdigit
    use M_strings, only : isdigit, isspace, switch
    implicit none
    character(len=10),allocatable :: string(:)
    integer                       :: i
       string=[&amp;
       &amp; &#39;1 2 3 4 5 &#39; ,&amp;
       &amp; &#39;letters   &#39; ,&amp;
       &amp; &#39;1234567890&#39; ,&amp;
       &amp; &#39;both 8787 &#39; ]
       ! if string is nothing but digits and whitespace return .true.
       do i=1,size(string)
          write(*,&#39;(a)&#39;,advance=&#39;no&#39;)&#39;For string[&#39;//string(i)//&#39;]&#39;
          write(*,*) &amp;
           &amp; all(isdigit(switch(string(i))).or.&amp;
           &amp; isspace(switch(string(i))))
       enddo
    end program demo_isdigit
</code></pre>
<p>Expected output:</p>
<pre><code>       For string[1 2 3 4 5 ] T
       For string[letters   ] F
       For string[1234567890] T
       For string[both 8787 ] F
</code></pre>
<h2 id="author-31">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-31">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-33" class="slide section level1">
<h1>NAME</h1>
<p>isgraph(3f) - [M_strings:COMPARE] returns .true. if character is a printable character except a space is considered non-printable (LICENSE:PD)</p>
<h2 id="synopsis-33">SYNOPSIS</h2>
<p>elemental function isgraph(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isgraph
</code></pre>
<h2 id="description-33">DESCRIPTION</h2>
<p>isgraph(3f) returns .true. if character is a printable character except a space is considered non-printable</p>
<h2 id="options-26">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-19">RETURNS</h2>
<ul>
<li><strong>isgraph</strong><br />
logical value returns true if character is a printable non-space character</li>
</ul>
<h2 id="examples-33">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_isgraph
   use M_strings, only : isgraph
   implicit none
   integer                    :: i
   character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
      write(*,&#39;(40(a))&#39;)&#39;ISGRAPH: &#39;,pack( string, isgraph(string) )
   end program demo_isgraph
</code></pre>
<p>Results:</p>
<pre><code>   ISGRAPH: !&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFG
   HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
   pqrstuvwxyz{|}~
</code></pre>
<h2 id="author-32">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-32">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-34" class="slide section level1">
<h1>NAME</h1>
<p>islower(3f) - [M_strings:COMPARE] returns .true. if character is a miniscule letter (a-z) (LICENSE:PD)</p>
<h2 id="synopsis-34">SYNOPSIS</h2>
<p>elemental function islower(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: islower
</code></pre>
<h2 id="description-34">DESCRIPTION</h2>
<p>islower(3f) returns .true. if character is a miniscule letter (a-z)</p>
<h2 id="options-27">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-20">RETURNS</h2>
<ul>
<li><strong>islower</strong><br />
logical value returns true if character is a lowercase ASCII character else false.</li>
</ul>
<h2 id="examples-34">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>    program demo_islower
    use M_strings, only : islower
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(15(g0,1x))&#39;)&#39;ISLOWER: &#39;, &amp;
       &amp; iachar(pack( string, islower(string) ))
       write(*,&#39;(15(g0,1x))&#39;)&#39;ISLOWER: &#39;, &amp;
       &amp; pack( string, islower(string) )
    end program demo_islower
</code></pre>
<p>Results:</p>
<pre><code>   ISLOWER:  97 98 99 100 101 102 103 104 105 106 107 108 109 110
   111 112 113 114 115 116 117 118 119 120 121 122
   ISLOWER:  a b c d e f g h i j k l m n
   o p q r s t u v w x y z
</code></pre>
<h2 id="author-33">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-33">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-35" class="slide section level1">
<h1>NAME</h1>
<p>isnumber(3f) - [M_strings:TYPE] determine if a string represents a number (LICENSE:PD)</p>
<h2 id="synopsis-35">SYNOPSIS</h2>
<p>function isnumber(str,msg)</p>
<pre><code>    character(len=*),intent(in)  :: str
    character(len=:),intent(out),allocatable,optional  :: msg
</code></pre>
<h2 id="description-35">DESCRIPTION</h2>
<p>ISNUMBER(3f) returns a value greater than zero if the string represents a number, and a number less than or equal to zero if it is a bad number. Blank characters are ignored.</p>
<h2 id="options-28">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
the string to evaluate as to whether it represents a numeric value or not</p></li>
<li><p><strong>msg</strong><br />
An optional message describing the string</p></li>
</ul>
<h2 id="returns-21">RETURNS</h2>
<ul>
<li><p><strong>isnumber</strong><br />
the following values are returned</p>
<ul>
<li><p><strong>1 for an integer</strong><br />
[-+]NNNNN</p></li>
<li><p><strong>2 for a whole number</strong><br />
[-+]NNNNN.</p></li>
<li><p><strong>3 for a real value</strong><br />
[-+]NNNNN.MMMM</p></li>
<li><p><strong>4 for a exponential value</strong><br />
[-+]NNNNN.MMMM[-+]LLLL [-+]NNNNN.MMMM[ed][-+]LLLL</p></li>
</ul></li>
</ul>
<p>values less than 1 represent an error</p>
<h2 id="examples-35">EXAMPLES</h2>
<p>As the example shows, you can use an internal READ(3f) along with the IOSTAT= parameter to check (and read) a string as well.</p>
<pre><code>    program demo_isnumber
    use M_strings, only : isnumber
    implicit none
    character(len=256) :: line
    real               :: value
    integer            :: ios1, ios2
    integer            :: answer
    character(len=256) :: message
    character(len=:),allocatable :: description
       write(*,*)&#39;Begin entering values, one per line&#39;
       do
          read(*,&#39;(a)&#39;,iostat=ios1)line
          !
          ! try string as number using list-directed input
          line=&#39;&#39;
          read(line,*,iostat=ios2,iomsg=message) value
          if(ios2 == 0)then
             write(*,*)&#39;VALUE=&#39;,value
          elseif( is_iostat_end(ios1) ) then
             stop &#39;end of file&#39;
          else
             write(*,*)&#39;ERROR:&#39;,ios2,trim(message)
          endif
          !
          ! try string using isnumber(3f)
          answer=isnumber(line,msg=description)
          if(answer &gt; 0)then
             write(*,*) &amp;
             &amp; &#39; for &#39;,trim(line),&#39; &#39;,answer,&#39;:&#39;,description
          else
             write(*,*) &amp;
             &amp; &#39; ERROR for &#39;,trim(line),&#39; &#39;,answer,&#39;:&#39;,description
          endif
          !
       enddo
    end program demo_isnumber
</code></pre>
<p>Example run</p>
<pre><code>   &gt; Begin entering values
   &gt; ERROR:          -1 End of file
   &gt;  ERROR for            -1 :null string
   &gt;10
   &gt; VALUE=   10.0000000
   &gt;  for 10            1 :integer
   &gt;20
   &gt; VALUE=   20.0000000
   &gt;  for 20            1 :integer
   &gt;20.
   &gt; VALUE=   20.0000000
   &gt;  for 20.            2 :whole number
   &gt;30.1
   &gt; VALUE=   30.1000004
   &gt;  for 30.1            3 :real number
   &gt;3e1
   &gt; VALUE=   30.0000000
   &gt;  for 3e1            4 :value with exponent
   &gt;1-2
   &gt; VALUE=   9.99999978E-03
   &gt;  for 1-2            4 :value with exponent
   &gt;100.22d-4
   &gt; VALUE=   1.00220004E-02
   &gt;  for 100.22d-4            4 :value with exponent
   &gt;1--2
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for 1--2           -5 :bad number
   &gt;e
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for e           -6 :missing leading value before exponent
   &gt;e1
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for e1           -6 :missing leading value before exponent
   &gt;1e
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for 1e           -3 :missing exponent
   &gt;1e+
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for 1e+           -4 :missing exponent after sign
   &gt;1e+2.0
   &gt; ERROR:        5010 Bad real number in item 1 of list input
   &gt;  ERROR for 1e+2.0           -5 :bad number
</code></pre>
<h2 id="author-34">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-34">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-36" class="slide section level1">
<h1>NAME</h1>
<p>isprint(3f) - [M_strings:COMPARE] returns .true. if character is an ASCII printable character (LICENSE:PD)</p>
<h2 id="synopsis-36">SYNOPSIS</h2>
<p>elemental function isprint(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isprint
</code></pre>
<h2 id="description-36">DESCRIPTION</h2>
<p>isprint(3f) returns .true. if character is an ASCII printable character</p>
<h2 id="options-29">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-22">RETURNS</h2>
<ul>
<li><strong>isprint</strong><br />
logical value returns true if character is a printable ASCII character else false.</li>
</ul>
<h2 id="examples-36">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_isprint
   use M_strings, only : isprint
   implicit none
   integer                    :: i
   character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
      write(*,&#39;(40(a))&#39;)&#39;ISPRINT: &#39;,pack( string, isprint(string) )
   end program demo_isprint
</code></pre>
<p>Results:</p>
<pre><code>   ISPRINT:  !&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEF
   GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
   opqrstuvwxyz{|}~
</code></pre>
<h2 id="author-35">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-35">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-37" class="slide section level1">
<h1>NAME</h1>
<p>ispunct(3f) - [M_strings:COMPARE] returns .true. if character is a printable punctuation character (LICENSE:PD)</p>
<h2 id="synopsis-37">SYNOPSIS</h2>
<p>elemental function ispunct(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: ispunct
</code></pre>
<h2 id="description-37">DESCRIPTION</h2>
<p>ispunct(3f) returns .true. if character is a printable punctuation character</p>
<h2 id="options-30">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-23">RETURNS</h2>
<ul>
<li><strong>ispunct</strong><br />
logical value returns true if character is a printable punctuation character.</li>
</ul>
<h2 id="examples-37">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_ispunct
    use M_strings, only : ispunct
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(20(g0,1x))&#39;)&#39;ISPUNCT: &#39;, &amp;
       &amp; iachar(pack( string, ispunct(string) ))
       write(*,&#39;(20(g0,1x))&#39;)&#39;ISPUNCT: &#39;, &amp;
       &amp; pack( string, ispunct(string) )
    end program demo_ispunct
</code></pre>
<p>Results:</p>
<pre><code>   ISPUNCT:  33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61
   62 63 64 91 92 93 94 95 96 123 124 125 126
   ISPUNCT:  ! &quot; # $ % &amp; &#39; ( ) * + , - . / : ; &lt; =
   &gt; ? @ [ \ ] ^ _ ` { | } ~
</code></pre>
<h2 id="author-36">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-36">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-38" class="slide section level1">
<h1>NAME</h1>
<p>isspace(3f) - [M_strings:COMPARE] returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed (LICENSE:PD)</p>
<h2 id="synopsis-38">SYNOPSIS</h2>
<p>elemental function isspace(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isspace
</code></pre>
<h2 id="description-38">DESCRIPTION</h2>
<p>isspace(3f) returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed</p>
<h2 id="options-31">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-24">RETURNS</h2>
<ul>
<li><strong>isspace</strong><br />
returns true if character is ASCII white space</li>
</ul>
<h2 id="examples-38">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_isspace
    use M_strings, only : isspace
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(20(g0,1x))&#39;)&#39;ISSPACE: &#39;, &amp;
       &amp; iachar(pack( string, isspace(string) ))
    end program demo_isspace
</code></pre>
<p>Results:</p>
<pre><code>   ISSPACE:  0 9 10 11 12 13 32
</code></pre>
<h2 id="author-37">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-37">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-39" class="slide section level1">
<h1>NAME</h1>
<p>isupper(3f) - [M_strings:COMPARE] returns .true. if character is an uppercase letter (A-Z) (LICENSE:PD)</p>
<h2 id="synopsis-39">SYNOPSIS</h2>
<p>elemental function isupper(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isupper
</code></pre>
<h2 id="description-39">DESCRIPTION</h2>
<p>isupper(3f) returns .true. if character is an uppercase letter (A-Z)</p>
<h2 id="options-32">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-25">RETURNS</h2>
<ul>
<li><strong>isupper</strong><br />
logical value returns true if character is an uppercase ASCII character else false.</li>
</ul>
<h2 id="examples-39">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_isupper
    use M_strings, only : isupper
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(10(g0,1x))&#39;)&#39;ISUPPER: &#39;, &amp;
       &amp; iachar(pack( string, isupper(string) ))
       write(*,&#39;(10(g0,1x))&#39;)&#39;ISUPPER: &#39;, &amp;
       &amp; pack( string, isupper(string) )
    end program demo_isupper
</code></pre>
<p>Results:</p>
<pre><code>    &gt; ISUPPER:  65 66 67 68 69 70 71 72 73
    &gt; 74 75 76 77 78 79 80 81 82 83
    &gt; 84 85 86 87 88 89 90
    &gt; ISUPPER:  A B C D E F G H I
    &gt; J K L M N O P Q R S
    &gt; T U V W X Y Z
</code></pre>
<h2 id="author-38">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-38">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-40" class="slide section level1">
<h1>NAME</h1>
<p>isxdigit(3f) - [M_strings:COMPARE] returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F). (LICENSE:PD)</p>
<h2 id="synopsis-40">SYNOPSIS</h2>
<p>elemental function isxdigit(onechar)</p>
<pre><code>    character,intent(in) :: onechar
    logical              :: isxdigit
</code></pre>
<h2 id="description-40">DESCRIPTION</h2>
<p>isxdigit(3f) returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).</p>
<h2 id="options-33">OPTIONS</h2>
<ul>
<li><strong>onechar</strong><br />
character to test</li>
</ul>
<h2 id="returns-26">RETURNS</h2>
<ul>
<li><strong>isxdigit</strong><br />
logical value returns true if character is a hexadecimal digit</li>
</ul>
<h2 id="examples-40">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>    program demo_isxdigit
    use M_strings, only : isxdigit
    implicit none
    integer                    :: i
    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
       write(*,&#39;(40(a))&#39;)&#39;ISXDIGIT: &#39;,pack( string, isxdigit(string) )
    end program demo_isxdigit
</code></pre>
<p>Results:</p>
<pre><code>   ISXDIGIT: 0123456789ABCDEFabcdef
</code></pre>
<h2 id="author-39">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-39">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-41" class="slide section level1">
<h1>NAME</h1>
<p>join(3f) - [M_strings:EDITING] append CHARACTER variable array into a single CHARACTER variable with specified separator (LICENSE:PD)</p>
<h2 id="synopsis-41">SYNOPSIS</h2>
<p>pure function join(str,sep,trm,left,right,start,end) result (string)</p>
<pre><code>    character(len=*),intent(in)          :: str(:)
    character(len=*),intent(in),optional :: sep
    logical,intent(in),optional          :: trm
    character(len=*),intent(in),optional :: right
    character(len=*),intent(in),optional :: left
    character(len=*),intent(in),optional :: start
    character(len=*),intent(in),optional :: end
    character(len=:),allocatable         :: string
</code></pre>
<h2 id="description-41">DESCRIPTION</h2>
<p>JOIN(3f) appends the elements of a CHARACTER array into a single CHARACTER variable, with elements 1 to N joined from left to right. By default each element is trimmed of trailing spaces and the default separator is a null string.</p>
<h2 id="options-34">OPTIONS</h2>
<ul>
<li><p><strong>STR(:)</strong><br />
array of CHARACTER variables to be joined</p></li>
<li><p><strong>SEP</strong><br />
separator string to place between each variable. defaults to a null string.</p></li>
<li><p><strong>LEFT</strong><br />
string to place at left of each element</p></li>
<li><p><strong>RIGHT</strong><br />
string to place at right of each element</p></li>
<li><p><strong>START</strong><br />
prefix string</p></li>
<li><p><strong>END</strong><br />
suffix string</p></li>
<li><p><strong>TRM</strong><br />
option to trim each element of STR of trailing spaces. Defaults to .TRUE.</p></li>
</ul>
<h2 id="returns-27">RETURNS</h2>
<ul>
<li><strong>STRING</strong><br />
CHARACTER variable composed of all of the elements of STR() appended together with the optional separator SEP placed between the elements.</li>
</ul>
<h2 id="examples-41">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>  program demo_join
  use M_strings, only: join
  implicit none
  character(len=:),allocatable  :: s(:)
  character(len=:),allocatable  :: out
  integer                       :: i
    s=[character(len=10) :: &#39;United&#39;,&#39; we&#39;,&#39; stand,&#39;, &amp;
    &amp; &#39; divided&#39;,&#39; we fall.&#39;]
    out=join(s)
    write(*,&#39;(a)&#39;) out
    write(*,&#39;(a)&#39;) join(s,trm=.false.)
    write(*,&#39;(a)&#39;) (join(s,trm=.false.,sep=&#39;|&#39;),i=1,3)
    write(*,&#39;(a)&#39;) join(s,sep=&#39;&lt;&gt;&#39;)
    write(*,&#39;(a)&#39;) join(s,sep=&#39;;&#39;,left=&#39;[&#39;,right=&#39;]&#39;)
    write(*,&#39;(a)&#39;) join(s,left=&#39;[&#39;,right=&#39;]&#39;)
    write(*,&#39;(a)&#39;) join(s,left=&#39;&gt;&gt;&#39;)
  end program demo_join
</code></pre>
<p>Expected output:</p>
<pre><code>  United we stand, divided we fall.
  United     we        stand,    divided   we fall.
  United    | we       | stand,   | divided  | we fall.
  United    | we       | stand,   | divided  | we fall.
  United    | we       | stand,   | divided  | we fall.
  United&lt;&gt; we&lt;&gt; stand,&lt;&gt; divided&lt;&gt; we fall.
  [United];[ we];[ stand,];[ divided];[ we fall.]
  [United][ we][ stand,][ divided][ we fall.]
  &gt;&gt;United&gt;&gt; we&gt;&gt; stand,&gt;&gt; divided&gt;&gt; we fall.
</code></pre>
<h2 id="author-40">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-40">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-42" class="slide section level1">
<h1>NAME</h1>
<p>lenset(3f) - [M_strings:LENGTH] return string trimmed or padded to specified length (LICENSE:PD)</p>
<h2 id="synopsis-42">SYNOPSIS</h2>
<p>function lenset(str,length) result(strout)</p>
<pre><code>    character(len=*)                     :: str
    character(len=length)                :: strout
    integer,intent(in)                   :: length
</code></pre>
<h2 id="description-42">DESCRIPTION</h2>
<p>lenset(3f) truncates a string or pads it with spaces to the specified length.</p>
<h2 id="options-35">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
input string</p></li>
<li><p><strong>length</strong><br />
output string length</p></li>
</ul>
<h2 id="returns-28">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
output string</li>
</ul>
<h2 id="examples-42">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>    program demo_lenset
     use M_strings, only : lenset
     implicit none
     character(len=10)            :: string=&#39;abcdefghij&#39;
     character(len=:),allocatable :: answer
        answer=lenset(string,5)
        write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
        answer=lenset(string,20)
        write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
    end program demo_lenset
</code></pre>
<p>Expected output:</p>
<pre><code>    [abcde]
    [abcdefghij          ]
</code></pre>
<h2 id="author-41">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-41">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-43" class="slide section level1">
<h1>NAME</h1>
<p>len_white(3f) - [M_strings:LENGTH] get length of string trimmed of whitespace. (LICENSE:PD)</p>
<h2 id="synopsis-43">SYNOPSIS</h2>
<p>integer function len_white(string)</p>
<pre><code>    character(len=*) :: string
</code></pre>
<h2 id="description-43">DESCRIPTION</h2>
<p>len_white(3f) returns the position of the last character in string that is not a whitespace character. The Fortran90 intrinsic LEN_TRIM() should be used when trailing whitespace can be assumed to always be spaces.</p>
<p>This procedure was heavily used in the past because ANSI FORTRAN 77 character objects are fixed length and blank padded and the LEN_TRIM() intrinsic did not exist. It should now be used only when whitespace characters other than blanks are likely.</p>
<h2 id="options-36">OPTIONS</h2>
<ul>
<li><strong>string</strong><br />
input string whose trimmed length is being calculated ignoring all trailing whitespace characters.</li>
</ul>
<h2 id="returns-29">RETURNS</h2>
<ul>
<li><strong>len_white</strong><br />
the number of characters in the trimmed string</li>
</ul>
<h2 id="examples-43">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_len_white

     use M_strings, only : len_white
     implicit none
     character(len=80) ::  s
     integer           :: lgth, lastnb
     intrinsic len

     s=&#39; ABCDEFG abcdefg &#39;
     lgth = len(s)
     lastnb = len_white(s)

     write(*,*) &#39;total length of variable is &#39;,lgth
     write(*,*) &#39;trimmed length of variable is &#39;,lastnb
     write(*,*) &#39;trimmed string=[&#39;,s(:lastnb),&#39;]&#39;

    end program demo_len_white
</code></pre>
<p>Results:</p>
<pre><code>    total length of variable is           80
    trimmed length of variable is           16
    trimmed string=[ ABCDEFG abcdefg]
</code></pre>
<h2 id="notes">NOTES</h2>
<ul>
<li>len_white</li>
</ul>
<!-- end list -->

<pre><code>     is a resource-intensive routine. Once the end of
     the string is found, it is probably best to keep track of it in
     order to avoid repeated calls to len_white. Because they
     might be more efficient, consider looking for vendor-supplied or
     system-optimized equivalents. For example:

        o lnblnk - Solaris f77
        o len_trim - FORTRAN 90
</code></pre>
<ul>
<li>Some compilers seem to have trouble passing a string of variable length properly. To be safe, use something like this:</li>
</ul>
<!-- end list -->

<pre><code>      subroutine message(s)
       character(len=*) :: s ! s is of variable length
          lgth=len(s)        ! get total length of variable
          ! explicitly specify a substring instead of just variable name
          lastnb = len_white(s(:lgth))
          write(*,*)&#39;error:[&#39;,s(:lastnb),&#39;]&#39;
      end subroutine messages
</code></pre>
<h2 id="author-42">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-42">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-44" class="slide section level1">
<h1>NAME</h1>
<p>listout(3f) - [M_strings:NUMERIC] expand a list of numbers where negative numbers denote range ends (1 <strong>-10</strong> means 1 thru 10) (LICENSE:PD)</p>
<h2 id="synopsis-44">SYNOPSIS</h2>
<p>subroutine listout(icurve_lists,icurve_expanded,inums,ierr)</p>
<pre><code>   integer,intent(in)    :: icurve_lists(:)
   integer,intent(out)   :: icurve_expanded(:)
   integer,intent(out)   :: inums
   integer,intent(out)   :: ierr
</code></pre>
<h2 id="description-44">DESCRIPTION</h2>
<p>expand a list of whole numbers where negative numbers indicate a range. So [10,<strong>-20</strong>] would be expanded to [10,11,12,13,14,15,16,17,18,19,20].</p>
<h2 id="options-37">OPTIONS</h2>
<ul>
<li><strong>icurve_lists(:)</strong><br />
input array</li>
</ul>
<h2 id="returns-30">RETURNS</h2>
<ul>
<li><p><strong>icurve_expanded(:)</strong><br />
output array; assumed large enough to hold returned list</p></li>
<li><p><strong>inums</strong><br />
number of icurve_expanded numbers on output</p></li>
<li><p><strong>ierr</strong><br />
zero if no error occurred</p></li>
</ul>
<h2 id="examples-44">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_listout
    use M_strings, only : listout
    implicit none
    integer,allocatable :: icurve_lists(:)
    integer :: icurve_expanded(1000)
    ! icurve_lists is input array
    integer :: inums
    ! icurve_expanded is output array
    integer :: i
    ! number of icurve_lists values on input,
    ! number of icurve_expanded numbers on output
    integer :: ierr
       icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
       inums=size(icurve_lists)
       call listout(icurve_lists,icurve_expanded,inums,ierr)
       if(ierr == 0)then
          write(*,&#39;(i0)&#39;)(icurve_expanded(i),i=1,inums)
       else
          write(*,&#39;(a,i0)&#39;)&#39;error occurred in *listout* &#39;,ierr
          write(*,&#39;(i0)&#39;)(icurve_expanded(i),i=1,inums)
       endif
    end program demo_listout
</code></pre>
<p>Results:</p>
<pre><code>    &gt; 1 20 21 22 23
    &gt; 24 25 26 27 28
    &gt; 29 30 101 100 99
    &gt; 100 101 102 103 104
    &gt; 105 106 107 108 109
    &gt; 110 111 112 113 114
    &gt; 115 116 117 118 119
    &gt; 120 222 221 220 219
    &gt; 218 217 216 215 214
    &gt; 213 212 211 210 209
    &gt; 208 207 206 205 204
    &gt; 203 202 201 200
</code></pre>
<h2 id="author-43">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-43">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-45" class="slide section level1">
<h1>NAME</h1>
<p>longest_common_substring(3f) - [M_strings:COMPARE] function that returns the longest common substring of two strings.</p>
<h2 id="synopsis-45">SYNOPSIS</h2>
<p>function longest_common_substring(a,b) result(match)</p>
<pre><code>    character(len=*),intent(in)  :: a, b
    character(len=:),allocatable :: match
</code></pre>
<h2 id="description-45">DESCRIPTION</h2>
<p>function that returns the longest common substring of two strings.</p>
<p>Note that substrings are consecutive characters within a string. This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.</p>
<p>Hence, the longest common subsequence between "thisisatest" and "testing123testing" is "tsitest", whereas the longest common substring is just "test".</p>
<h2 id="options-38">OPTIONS</h2>
<ul>
<li><strong>a,b</strong><br />
strings to search for the longest common substring.</li>
</ul>
<h2 id="returns-31">RETURNS</h2>
<ul>
<li><strong>longest_common_substring</strong><br />
the longest common substring found</li>
</ul>
<h2 id="examples-45">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>   program demo_longest_common_substring
   use M_strings, only : longest_common_substring
   implicit none
     call compare(&#39;testing123testingthing&#39;,&#39;thisis&#39;,             &#39;thi&#39;)
     call compare(&#39;testing&#39;,             &#39;sting&#39;,              &#39;sting&#39;)
     call compare(&#39;thisisatest_stinger&#39;,&#39;testing123testingthing&#39;,&#39;sting&#39;)
     call compare(&#39;thisisatest_stinger&#39;, &#39;thisis&#39;,            &#39;thisis&#39;)
     call compare(&#39;thisisatest&#39;,         &#39;testing123testing&#39;,   &#39;test&#39;)
     call compare(&#39;thisisatest&#39;,      &#39;thisisatest&#39;,     &#39;thisisatest&#39;)
   contains

   subroutine compare(a,b,answer)
   character(len=*),intent(in) :: a, b, answer
   character(len=:),allocatable :: match
   character(len=*),parameter :: g=&#39;(*(g0))&#39;
      match=longest_common_substring(a,b)
      write(*,g) &#39;comparing &quot;&#39;,a,&#39;&quot; and &quot;&#39;,b,&#39;&quot;&#39;
      write(*,g) merge(&#39;(PASSED) &quot;&#39;,&#39;(FAILED) &quot;&#39;,answer == match), &amp;
      &amp; match,&#39;&quot;; expected &quot;&#39;,answer,&#39;&quot;&#39;
   end subroutine compare

   end program demo_longest_common_substring
</code></pre>
<p>expected output</p>
<pre><code>   comparing &quot;testing123testingthing&quot; and &quot;thisis&quot;
   (PASSED) &quot;thi&quot;; expected &quot;thi&quot;
   comparing &quot;testing&quot; and &quot;sting&quot;
   (PASSED) &quot;sting&quot;; expected &quot;sting&quot;
   comparing &quot;thisisatest_stinger&quot; and &quot;testing123testingthing&quot;
   (PASSED) &quot;sting&quot;; expected &quot;sting&quot;
   comparing &quot;thisisatest_stinger&quot; and &quot;thisis&quot;
   (PASSED) &quot;thisis&quot;; expected &quot;thisis&quot;
   comparing &quot;thisisatest&quot; and &quot;testing123testing&quot;
   (PASSED) &quot;test&quot;; expected &quot;test&quot;
   comparing &quot;thisisatest&quot; and &quot;thisisatest&quot;
   (PASSED) &quot;thisisatest&quot;; expected &quot;thisisatest&quot;
</code></pre>
</div>
<div id="name-46" class="slide section level1">
<h1>NAME</h1>
<p>lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range (LICENSE:PD)</p>
<h2 id="synopsis-46">SYNOPSIS</h2>
<p>elemental pure function lower(str,begin,end) result (string)</p>
<pre><code>    character(*), intent(in) :: str
    integer,optional         :: begin, end
    character(len(str))      :: string  ! output string
</code></pre>
<h2 id="description-46">DESCRIPTION</h2>
<p>lower(string) returns a copy of the input string with all characters converted to miniscule over the specified range, assuming ASCII character sets are being used. If no range is specified the entire string is converted to miniscule.</p>
<h2 id="options-39">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
string to convert to miniscule</p></li>
<li><p><strong>begin</strong><br />
optional starting position in "str" to begin converting to miniscule</p></li>
<li><p><strong>end</strong><br />
optional ending position in "str" to stop converting to miniscule</p></li>
</ul>
<h2 id="returns-32">RETURNS</h2>
<ul>
<li><strong>lower</strong><br />
copy of the input string with all characters converted to miniscule over optionally specified range.</li>
</ul>
<h2 id="trivia">TRIVIA</h2>
<p>The terms "uppercase" and "lowercase" date back to the early days of the mechanical printing press. Individual metal alloy casts of each needed letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were stored and organized in wooden cases. The more often needed miniscule letters were placed closer to hand, in the lower cases of the work bench. The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.</p>
<h2 id="examples-46">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>      program demo_lower
      use M_strings, only: lower
      implicit none
      character(len=:),allocatable  :: s
         s=&#39; ABCDEFG abcdefg &#39;
         write(*,*) &#39;mixed-case input string is ```.&#39;,s
         write(*,*) &#39;lower-case output string is ```&#39;,lower(s)
      end program demo_lower
</code></pre>
<p>Expected output</p>
<pre><code>      mixed-case input string is ```. ABCDEFG abcdefg
      lower-case output string is ``` abcdefg abcdefg
</code></pre>
<h2 id="author-44">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-44">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-47" class="slide section level1">
<h1>NAME</h1>
<p>lpad(3f) - [M_strings:LENGTH] convert to a cropped string and then blank-pad on the left to requested length (LICENSE:PD)</p>
<h2 id="synopsis-47">SYNOPSIS</h2>
<p>function lpad(valuein,length) result(strout)</p>
<pre><code>    class*,intent(in)       :: valuein(..)
    integer,intent(in)      :: length
</code></pre>
<h2 id="description-47">DESCRIPTION</h2>
<p>lpad(3f) converts a scalar value to a cropped string and then pads it on the left with spaces to at least the specified length. If the trimmed input is longer than the requested length the string is returned trimmed of leading and trailing spaces.</p>
<h2 id="options-40">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
The input may be scalar or a vector. the input value to return as a string, padded on the left to the specified length if shorter than length. The input may be any intrinsic scalar which is converted to a cropped string much as if written with list-directed output.</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return</p></li>
</ul>
<h2 id="returns-33">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
The input string padded to the requested length on the left with spaces.</li>
</ul>
<h2 id="examples-47">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_lpad
      use M_strings, only : lpad
      implicit none
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( &#39;my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( &#39;my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( &#39;   my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( &#39;   my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( valuein=42 , length=7)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) lpad( valuein=1.0/9.0 , length=20)
     end program demo_lpad
</code></pre>
<p>Results:</p>
<pre><code>    &gt; [           my string]
    &gt; [           my string]
    &gt; [           my string]
    &gt; [           my string]
    &gt; [     42]
    &gt; [         0.111111112]
</code></pre>
<h2 id="author-45">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-45">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-48" class="slide section level1">
<h1>NAME</h1>
<p>matching_delimiter(3f) - [M_strings:QUOTES] find position of matching delimiter (LICENSE:PD)</p>
<h2 id="synopsis-48">SYNOPSIS</h2>
<p>impure elemental subroutine matching_delimiter(str,ipos,imatch)</p>
<pre><code>   character(len=*),intent(in)  :: str
   integer,intent(in)           :: ipos
   integer,intent(out)          :: imatch
</code></pre>
<h2 id="description-48">DESCRIPTION</h2>
<p>Sets imatch to the position in string of the delimiter matching the delimiter in position ipos. Allowable delimiters are (), [], {}, &lt;&gt;.</p>
<h2 id="options-41">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
input string to locate delimiter position in</p></li>
<li><p><strong>ipos</strong><br />
position of delimiter to find match for</p></li>
<li><p><strong>imatch</strong><br />
location of matching delimiter. If no match is found, zero (0) is returned.</p></li>
</ul>
<h2 id="examples-48">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_matching_delimiter
      use M_strings, only : matching_delimiter
      implicit none
      character(len=128)  :: str
      integer             :: imatch

      str=&#39; a [[[[b] and ] then ] finally ]&#39;
      write(*,*)&#39;string=&#39;,str
      call matching_delimiter(str,1,imatch)
      write(*,*)&#39;location=&#39;,imatch
      call matching_delimiter(str,4,imatch)
      write(*,*)&#39;location=&#39;,imatch
      call matching_delimiter(str,5,imatch)
      write(*,*)&#39;location=&#39;,imatch
      call matching_delimiter(str,6,imatch)
      write(*,*)&#39;location=&#39;,imatch
      call matching_delimiter(str,7,imatch)
      write(*,*)&#39;location=&#39;,imatch
      call matching_delimiter(str,32,imatch)
      write(*,*)&#39;location=&#39;,imatch

   end program demo_matching_delimiter
</code></pre>
<h2 id="author-46">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-46">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-49" class="slide section level1">
<h1>NAME</h1>
<p>merge_str(3f) - [M_strings:LENGTH] pads strings to same length and then calls MERGE(3f) (LICENSE:PD)</p>
<h2 id="synopsis-49">SYNOPSIS</h2>
<p>function merge_str(str1,str2,expr) result(strout)</p>
<pre><code>    character(len=*),intent(in),optional :: str1
    character(len=*),intent(in),optional :: str2
    logical,intent(in)              :: expr
    character(len=:),allocatable    :: strout
</code></pre>
<h2 id="description-49">DESCRIPTION</h2>
<p>merge_str(3f) pads the shorter of str1 and str2 to the longest length of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr). It trims trailing spaces off the result and returns the trimmed string. This makes it easier to call MERGE(3f) with strings, as MERGE(3f) requires the strings to be the same length.</p>
<p>NOTE: STR1 and STR2 are always required even though declared optional. this is so the call "STR_MERGE(A,B,present(A))" is a valid call. The parameters STR1 and STR2 when they are optional parameters can be passed to a procedure if the options are optional on the called procedure.</p>
<h2 id="options-42">OPTIONS</h2>
<ul>
<li><p><strong>STR1</strong><br />
string to return if the logical expression EXPR is true</p></li>
<li><p><strong>STR2</strong><br />
string to return if the logical expression EXPR is false</p></li>
<li><p><strong>EXPR</strong><br />
logical expression to evaluate to determine whether to return STR1 when true, and STR2 when false.</p></li>
</ul>
<h2 id="returns-34">RETURNS</h2>
<ul>
<li><strong>MERGE_STR</strong><br />
a trimmed string is returned that is otherwise the value of STR1 or STR2, depending on the logical expression EXPR.</li>
</ul>
<h2 id="examples-49">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>    program demo_merge_str
    use M_strings, only : merge_str
    implicit none
    character(len=:), allocatable :: answer
       answer=merge_str(&#39;first string&#39;, &amp;
        &amp; &#39;second string is longer&#39;,10 == 10)
       write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
       answer=merge_str(&#39;first string&#39;, &amp;
        &amp; &#39;second string is longer&#39;,10 /= 10)
       write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
    end program demo_merge_str
</code></pre>
<p>Expected output</p>
<pre><code>    [first string]
    [second string is longer]
</code></pre>
<h2 id="author-47">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-47">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-50" class="slide section level1">
<h1>NAME</h1>
<p>modif(3f) - [M_strings:EDITING] emulate the MODIFY command from the line editor XEDIT (LICENSE:PD)</p>
<h2 id="synopsis-50">SYNOPSIS</h2>
<p>subroutine modif(cline,cmod)</p>
<pre><code>    character(len=*) :: cline ! input string to change
    ! directive provides directions on changing string
    character(len=*) :: cmod
</code></pre>
<h2 id="description-50">DESCRIPTION</h2>
<p>MODIF(3f) Modifies the line currently pointed at using a directive that acts much like a line editor directive. Primarily used to create interactive utilities such as input history editors for interactive line-mode programs.</p>
<p>the modify directives are as follows-</p>
<h3 id="directive-explanation">DIRECTIVE EXPLANATION</h3>
<ul>
<li><p><strong>^STRING#</strong><br />
Causes the string of characters between the ^ and the next # to be inserted before the characters pointed to by the ^. an ^ or &amp; within the string is treated as a regular character. If the closing # is not specified, MODIF(3f) inserts the remainder of the line as if a # was specified after the last nonblank character.</p>
<p>There are two exceptions. the combination ^# causes a # to be inserted before the character pointed to by the ^, and an ^ as the last character of the directives causes a blank to be inserted.</p></li>
<li><p><strong>#</strong><br />
(When not the first # after an ^) causes the character above it to be deleted.</p></li>
<li><p><strong>&amp;</strong><br />
Replaces the character above it with a space.</p></li>
<li><p><strong>(SPACE)</strong><br />
A space below a character leaves it unchanged.</p></li>
</ul>
<p>Any other character replaces the character above it.</p>
<h2 id="examples-50">EXAMPLES</h2>
<p>Example input/output:</p>
<pre><code>   THE INPUT LINE```..... 10 THIS STRING  TO BE MORTIFD
   THE DIRECTIVES LINE```        ^ IS THE#        D#  ^IE
   ALTERED INPUT LINE```. 10 THIS IS THE STRING  TO BE MODIFIED
</code></pre>
<p>Sample program:</p>
<pre><code>   program demo_modif
   use M_strings, only : modif
   implicit none
   character(len=256)           :: line
   integer                      :: ios
   integer                      :: count
   integer                      :: COMMAND_LINE_LENGTH
   character(len=:),allocatable :: COMMAND_LINE
      ! get command name length
      call get_command_argument(0,length=count)
      ! get command line length
      call get_command(length=COMMAND_LINE_LENGTH)
      ! allocate string big enough to hold command line
      allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
      ! get command line as a string
      call get_command(command=COMMAND_LINE)
      ! trim leading spaces just in case
      COMMAND_LINE=adjustl(COMMAND_LINE)
      ! remove command name
      COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
      INFINITE: do
         read(*,&#39;(a)&#39;,iostat=ios)line
         if(ios /= 0)exit
         call modif(line,COMMAND_LINE)
         write(*,&#39;(a)&#39;)trim(line)
      enddo INFINITE
   end program demo_modif
</code></pre>
<h2 id="author-48">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-48">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-51" class="slide section level1">
<h1>NAME</h1>
<p>msg(3f) - [M_strings:TYPE] converts any standard scalar type to a string (LICENSE:PD)</p>
<h2 id="synopsis-51">SYNOPSIS</h2>
<p>function msg(g1,g2g3,g4,g5,g6,g7,g8,g9,sep)</p>
<pre><code>     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
     character(len=*),intent(in),optional :: sep
     character(len=:),allocatable :: msg
</code></pre>
<h2 id="description-51">DESCRIPTION</h2>
<p>msg(3f) builds a space-separated string from up to nine scalar values.</p>
<h2 id="options-43">OPTIONS</h2>
<ul>
<li><p><strong>g[1-9]</strong><br />
optional value to print the value of after the message. May be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.</p></li>
<li><p><strong>sep</strong><br />
separator between values. Defaults to a space</p></li>
</ul>
<h2 id="returns-35">RETURNS</h2>
<ul>
<li><strong>msg</strong><br />
description to print</li>
</ul>
<h2 id="examples-51">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>       program demo_msg
       use M_strings, only : msg
       implicit none
       character(len=:),allocatable :: pr
       character(len=:),allocatable :: frmt
       integer                      :: biggest

       pr=msg(&#39;HUGE(3f) integers&#39;,huge(0),&amp;
       &amp; &#39;and real&#39;,huge(0.0),&#39;and double&#39;,huge(0.0d0))
       write(*,&#39;(a)&#39;)pr
       pr=msg(&#39;real            :&#39;,&amp;
        &amp; huge(0.0),0.0,12345.6789,tiny(0.0) )
       write(*,&#39;(a)&#39;)pr
       pr=msg(&#39;doubleprecision :&#39;,&amp;
        &amp; huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
       write(*,&#39;(a)&#39;)pr
       pr=msg(&#39;complex         :&#39;,&amp;
        &amp; cmplx(huge(0.0),tiny(0.0)) )
       write(*,&#39;(a)&#39;)pr

       ! create a format on the fly
       biggest=huge(0)
       ! +0 for gfortran-11 bug
       frmt=msg(&#39;(*(i&#39;,int(log10(real(biggest)))+0,&#39;:,1x))&#39;,sep=&#39;&#39;)
       write(*,*)&#39;format=&#39;,frmt

       ! although it will often work, using msg(3f) in an I/O statement
       ! is not recommended
       write(*,*)msg(&#39;program will now stop&#39;)

       end program demo_msg
</code></pre>
<p>Output</p>
<pre><code>      HUGE(3f) integers 2147483647 and real 3.40282347E+38
      and double 1.7976931348623157E+308
      real            : 3.40282347E+38 0.00000000
      12345.6787 1.17549435E-38
      doubleprecision : 1.7976931348623157E+308 0.0000000000000000
      12345.678900000001 2.2250738585072014E-308
      complex         : (3.40282347E+38,1.17549435E-38)
       format=(*(i9:,1x))
       program will now stop
</code></pre>
<h2 id="author-49">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-49">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-52" class="slide section level1">
<h1>NAME</h1>
<p>M_strings(3f) - [M_strings::INTRO] Fortran string module</p>
<h2 id="description-52">DESCRIPTION</h2>
<p>The M_strings(3fm) module is a collection of Fortran procedures that supplement the built-in intrinsic string routines. Routines for parsing, tokenizing, changing case, substituting new strings for substrings, locating strings with simple wildcard expressions, removing tabs and line terminators and other string manipulations are included.</p>
<p>M_strings__oop(3fm) is a companion module that provides an OOP interface to the M_strings module.</p>
<h2 id="synopsis-52">SYNOPSIS</h2>
<p>public entities:</p>
<pre><code>     use M_strings,only : split, slice, sep, delim, chomp, strtok
     use M_strings,only : split2020, find_field
     use M_strings,only : substitute, change, modif, transliterate, &amp;
             &amp; reverse, squeeze
     use M_strings,only : replace, join
     use M_strings,only : upper, lower, upper_quoted
     use M_strings,only : rotate13, percent_encode
     use M_strings,only : adjustc, compact, nospace, indent
     use M_strings,only : crop, clip, unquote, quote, matching_delimiter
     use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &amp;
             &amp; stretch, lenset, merge_str
     use M_strings,only : switch, s2c, c2s
     use M_strings,only : noesc, notabs, dilate, expand, visible
     use M_strings,only : longest_common_substring
     use M_strings,only : string_to_value, string_to_values, s2v, s2vs
     use M_strings,only : int, real, dble, nint
     use M_strings,only : atoi, atol, aton
     use M_strings,only : value_to_string, v2s, msg
     use M_strings,only : listout, getvals
     use M_strings,only : glob, ends_with
     use M_strings,only : paragraph
     use M_strings,only : base, decodebase, codebase, base2
     use M_strings,only : isalnum, isalpha, iscntrl, isdigit
     use M_strings,only : isgraph, islower, isprint, ispunct
     use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
     use M_strings,only : isnumber
     use M_strings,only : fortran_name
     use M_strings,only : describe
     use M_strings,only : edit_distance
     use M_strings,only : bundle
</code></pre>
<h3 id="tokens">TOKENS</h3>
<ul>
<li><p><strong>split</strong><br />
subroutine parses string using specified delimiter characters and stores tokens into an array</p></li>
<li><p><strong>sep</strong><br />
function interface to split(3f)</p></li>
<li><p><strong>slice</strong><br />
subroutine parses string using specified delimiter characters and stores beginning and ending positions in arrays</p></li>
<li><p><strong>delim</strong><br />
subroutine parses string using specified delimiter characters and store tokens into an array and records beginning and end</p></li>
<li><p><strong>chomp</strong><br />
function consumes input line as it returns next token in a string using specified delimiters</p></li>
<li><p><strong>paragraph</strong><br />
convert a string into a paragraph</p></li>
<li><p><strong>strtok</strong><br />
tokenize a string like C strtok(3c) routine</p></li>
</ul>
<h3 id="contributions">CONTRIBUTIONS</h3>
<ul>
<li><p><strong>split2020</strong><br />
split a string using prototype of proposed standard procedure</p></li>
<li><p><strong>find_field</strong><br />
token a string</p></li>
</ul>
<h3 id="editing">EDITING</h3>
<ul>
<li><p><strong>substitute</strong><br />
subroutine non-recursively globally replaces old substring with new substring</p></li>
<li><p><strong>replace</strong><br />
function non-recursively globally replaces old substring with new substring using allocatable string (version of substitute(3f) without limitation on length of output string)</p></li>
<li><p><strong>change</strong><br />
subroutine non-recursively globally replaces old substring with new substring with a directive like line editor</p></li>
<li><p><strong>modif</strong><br />
subroutine modifies a string with a directive like the XEDIT line editor MODIFY command</p></li>
<li><p><strong>transliterate</strong><br />
replace characters found in set one with characters from set two</p></li>
<li><p><strong>reverse</strong><br />
reverse character order in a string</p></li>
<li><p><strong>join</strong><br />
join an array of CHARACTER variables with specified separator</p></li>
<li><p><strong>rotate13</strong><br />
apply trivial encryption algorithm ROT13 to a string percent_encode apply percent-encryption (aka. URL encryption) to characters</p></li>
<li><p><strong>squeeze</strong><br />
delete adjacent duplicate characters from a string</p></li>
</ul>
<h3 id="case">CASE</h3>
<ul>
<li><p><strong>upper</strong><br />
function converts string to uppercase</p></li>
<li><p><strong>lower</strong><br />
function converts string to miniscule</p></li>
<li><p><strong>upper_quoted</strong><br />
function converts string to uppercase skipping strings quoted per Fortran rules</p></li>
</ul>
<h3 id="string-length-and-padding">STRING LENGTH AND PADDING</h3>
<ul>
<li><p><strong>len_white</strong><br />
find location of last non-whitespace character</p></li>
<li><p><strong>lenset</strong><br />
return a string of specified length</p></li>
<li><p><strong>pad</strong><br />
return a string of at least specified length</p></li>
<li><p><strong>zpad</strong><br />
pad integer or string to length with zero characters on left</p></li>
<li><p><strong>lpad</strong><br />
convert scalar intrinsic to a string padded on left to specified length</p></li>
<li><p><strong>cpad</strong><br />
convert scalar intrinsic to a centered string of the specified length</p></li>
<li><p><strong>rpad</strong><br />
convert scalar intrinsic to a string padded on right to specified length</p></li>
<li><p><strong>stretch</strong><br />
return a string of at least specified length with suffix</p></li>
<li><p><strong>merge_str</strong><br />
make strings of equal length and then call MERGE(3f) intrinsic</p></li>
</ul>
<h3 id="white-space">WHITE SPACE</h3>
<ul>
<li><p><strong>adjustc</strong><br />
elemental function centers text within the length of the input string</p></li>
<li><p><strong>compact</strong><br />
left justify string and replace duplicate whitespace with single characters or nothing</p></li>
<li><p><strong>nospace</strong><br />
function replaces whitespace with nothing</p></li>
<li><p><strong>indent</strong><br />
find number of leading spaces</p></li>
<li><p><strong>crop</strong><br />
function trims leading and trailing spaces and control characters</p></li>
<li><p><strong>clip</strong><br />
function trims leading and trailing spaces</p></li>
</ul>
<p>See Also: squeeze</p>
<h3 id="quotes">QUOTES</h3>
<ul>
<li><p><strong>matching_delimiter</strong><br />
find position of matching delimiter</p></li>
<li><p><strong>unquote</strong><br />
remove quotes from string as if read with list-directed input</p></li>
<li><p><strong>quote</strong><br />
add quotes to string as if written with list-directed output</p></li>
</ul>
<h3 id="character-array-versus-string">CHARACTER ARRAY VERSUS STRING</h3>
<ul>
<li><p><strong>switch</strong><br />
switch between a string and an array of single characters</p></li>
<li><p><strong>s2c</strong><br />
convert string to array of single characters and add null terminator for passing to C</p></li>
<li><p><strong>c2s</strong><br />
convert null-terminated array of single characters to string for converting strings returned from C</p></li>
</ul>
<h3 id="nonalpha">NONALPHA</h3>
<ul>
<li><p><strong>noesc</strong><br />
convert non-printable ASCII8 characters to a space</p></li>
<li><p><strong>notabs</strong><br />
convert tabs to spaces while maintaining columns, assuming tabs are set every 8 characters</p></li>
<li><p><strong>dilate</strong><br />
function to convert tabs to spaces assuming tabs are set every 8 characters</p></li>
<li><p><strong>expand</strong><br />
expand escape sequences in a string</p></li>
<li><p><strong>visible</strong><br />
expand escape sequences in a string to "control" and meta-control representations</p></li>
</ul>
<h3 id="numeric-strings">NUMERIC STRINGS</h3>
<ul>
<li><p><strong>string_to_value</strong><br />
generic subroutine returns numeric value (REAL, DOUBLEPRECISION, INTEGER) from string</p></li>
<li><p><strong>string_to_values</strong><br />
subroutine reads an array of numbers from a string</p></li>
<li><p><strong>getvals</strong><br />
subroutine reads a relatively arbitrary number of values from a string using list-directed read</p></li>
<li><p><strong>s2v</strong><br />
function returns DOUBLEPRECISION numeric value from string</p></li>
<li><p><strong>s2vs</strong><br />
function returns a DOUBLEPRECISION array of numbers from a string</p></li>
<li><p><strong>s2vs</strong><br />
function returns a DOUBLEPRECISION array of numbers from a string</p></li>
<li><p><strong>atoi</strong><br />
function returns INTEGER(kind=int32) from a string</p></li>
<li><p><strong>atol</strong><br />
function returns INTEGER(kind=int64) from a string</p></li>
<li><p><strong>aton</strong><br />
changes string to numeric value</p></li>
<li><p><strong>msg</strong><br />
append the values of up to nine values into a string</p></li>
<li><p><strong>value_to_string</strong><br />
generic subroutine returns string given numeric value (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )</p></li>
<li><p><strong>v2s</strong><br />
generic function returns string from numeric value (REAL, DOUBLEPRECISION, INTEGER )</p></li>
<li><p><strong>listout</strong><br />
expand a list of numbers where negative numbers denote range ends (1 <strong>-10</strong> means 1 thru 10)</p></li>
<li><p><strong>isnumber</strong><br />
determine if string represents a number</p></li>
</ul>
<h3 id="character-tests">CHARACTER TESTS</h3>
<ul>
<li><p><strong>glob</strong><br />
compares given string for match to pattern which may contain wildcard characters</p></li>
<li><p><strong>ends_with</strong><br />
test whether strings ends with one of the specified suffixes</p></li>
</ul>
<!-- end list -->

<ul>
<li><p>isalnum returns .true. if character is a letter or digit</p></li>
<li><p>isalpha returns .true. if character is a letter and ï¿½false. otherwise</p></li>
<li><p>iscntrl returns .true. if character is a delete character or ordinary control character</p></li>
<li><p>isdigit returns .true. if character is a digit (0,1,```,9) and .false. otherwise</p></li>
<li><p>isgraph returns .true. if character is a printable character except a space is considered non-printable</p></li>
<li><p>islower returns .true. if character is a miniscule letter (a-z)</p></li>
<li><p>isprint returns .true. if character is an ASCII printable character</p></li>
<li><p>ispunct returns .true. if character is a printable punctuation character</p></li>
<li><p>isspace returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed</p></li>
<li><p>isupper returns .true. if character is an uppercase letter (A-Z)</p></li>
<li><p>isascii returns .true. if the character is in the range char(0) to char(127)</p></li>
<li><p>isblank returns .true. if character is a blank character (space or horizontal tab.</p></li>
<li><p>isxdigit returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).</p></li>
</ul>
<!-- end list -->

<ul>
<li><strong>fortran_name</strong><br />
returns .true. if input string is a valid Fortran name</li>
</ul>
<h3 id="base-conversion">BASE CONVERSION</h3>
<ul>
<li><p><strong>base</strong><br />
convert whole number string in base [2-36] to string in alternate base [2-36]</p></li>
<li><p><strong>base2</strong><br />
convert INTEGER to a string representing a binary value</p></li>
<li><p><strong>codebase</strong><br />
convert whole number string in base [2-36] to base 10 number decodebase convert whole number in base 10 to string in base [2-36]</p></li>
</ul>
<h3 id="miscellaneous">MISCELLANEOUS</h3>
<ul>
<li><p><strong>bundle</strong><br />
return up to twenty strings of arbitrary length as an array</p></li>
<li><p><strong>describe</strong><br />
returns a string describing the name of a single character</p></li>
<li><p><strong>edit_distance</strong><br />
returns a naive edit distance using the Levenshtein distance algorithm</p></li>
<li><p><strong>longest_common_substring</strong><br />
function that returns the longest common substring of two strings.</p></li>
</ul>
<h3 id="intrinsics">INTRINSICS</h3>
<p>The M_strings(3fm) module supplements and works in combination with the Fortran built-in intrinsics. Stand-alone Fortran lets you access the characters in a string using ranges much like they are character arrays, assignment, comparisons with standard operators, supports dynamically allocatable strings and supports concatenation using the // operator, as well as a number of intrinsic string routines:</p>
<pre><code>       adjustl             Left adjust a string
       adjustr             Right adjust a string
       index               Position of a substring within a string
       repeat              Repeated string concatenation
       scan                Scan a string for the presence of a set
                           of characters
       trim                Remove trailing blank characters of a string
       verify              Scan a string for the absence of a set of
                           characters
       len                 It returns the length of a character string
       achar               converts an integer into a character
       iachar              converts a character into an integer
       len_trim            finds length of string with trailing spaces
                           ignored
       new_line            Newline character
       selected_char_kind  Choose character kind
       lge                 Lexical greater than or equal
       lgt                 Lexical greater than
       lle                 Lexical less than or equal
       llt                 Lexical less than
</code></pre>
<h3 id="oops-interface">OOPS INTERFACE</h3>
<p>The M_strings__oop(3fm) module (included with the M_strings(3fm) module) provides an OOP (Object-Oriented Programming) interface to the M_strings(3fm) module.</p>
<h2 id="see-also">SEE ALSO</h2>
<p>There are additional routines in other GPF modules for working with expressions (M_calculator), time strings (M_time), random strings (M_random, M_uuid), lists (M_list), and interfacing with the C regular expression library (M_regex).</p>
<h2 id="examples-52">EXAMPLES</h2>
<p>Each of the procedures includes an [example](example/) program in the corresponding man(1) page for the function.</p>
<h2 id="author-50">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-50">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-53" class="slide section level1">
<h1>NAME</h1>
<p>M_strings__oop(3f) - [M_strings::INTRO::OOPS] OOP Fortran string module</p>
<h2 id="synopsis-53">SYNOPSIS</h2>
<p>use M_strings__oop</p>
<h2 id="description-53">DESCRIPTION</h2>
<p>The M_strings(3fm) module is a collection of Fortran procedures that supplement the built-in intrinsic string routines. Routines for parsing, tokenizing, changing case, substituting new strings for substrings, locating strings with simple wildcard expressions, removing tabs and line terminators and other string manipulations are included.</p>
<p>M_strings__oop(3fm) is a companion module that provides an OOP interface to the M_strings module.</p>
<h2 id="see-also-1">SEE ALSO</h2>
<p>There are additional routines in other GPF modules for working with expressions (M_calculator), time strings (M_time), random strings (M_random, M_uuid), lists (M_list), and interfacing with the C regular expression library (M_regex).</p>
<h2 id="examples-53">EXAMPLES</h2>
<p>Each of the procedural functions in M_strings(3fm) includes an example program in the corresponding man(1) page for the function. The object-oriented interface does not have individual man(1) pages, but is instead demonstrated using the following example program:</p>
<pre><code>    program demo_M_strings__oop
    !
    ! This is an example using the object-oriented class/type model
    ! defined in M_strings__oop
    !
    ! This is essentially the same functionality as the procedures
    ! combined with several Fortran intrinsics and overloaded operators
    !
    use M_strings__oop,only : string, p
    implicit none
    TYPE(string) :: str1, str2, str3, str4

      write(*,*)&#39;Call methods of type(STRING)&#39;

      ! define TYPE(STRING) with constructor
      str2=string(&#39;   This  is  a  String!       &#39;)
      str4=string(&#39; a  String &#39;)

      write(*,101)&#39;str2%str is ```............. &#39;, &amp;
       &amp; str2%str                      ! print string member of type
      write(*,202)&#39;len ```..................... &#39;, &amp;
       &amp; str2%len()                    ! same as intrinsic LEN()
      write(*,202)&#39;len_trim ```................ &#39;, &amp;
       &amp; str2%len_trim()               ! same as intrinsic LEN_TRIM()
      write(*,202)&#39;index(&quot;is&quot;)```.............. &#39;, &amp;
       &amp; str2%index(&quot;is&quot;)              ! same as intrinsic INDEX()
      write(*,202)&#39;index(&quot;is&quot;,back=.T.) ```.... &#39;, &amp;
       &amp; str2%index(&quot;is&quot;,back=.TRUE.)  ! same as intrinsic INDEX()
      write(*,101)&#39;upper ```................... &#39;, &amp;
       &amp; p(str2%upper())               ! call upper()
      write(*,101)&#39;lower ```................... &#39;, &amp;
       &amp; p(str2%lower())               ! call lower()
      write(*,101)&#39;reverse ```................. &#39;, &amp;
       &amp; p(str2%reverse())             ! call reverse()
      write(*,101)&#39;adjustl ```................. &#39;, &amp;
       &amp; p(str2%adjustl())             ! same as intrinsic ADJUSTL()
      write(*,101)&#39;adjustr ```................. &#39;, &amp;
       &amp; p(str2%adjustr())             ! same as intrinsic ADJUSTR()
      write(*,101)&#39;adjustc ```................. &#39;, &amp;
       &amp; p(str2%adjustc())             ! center string in current string length
      write(*,101)&#39;adjustc(40) ```............. &#39;, &amp;
       &amp; p(str2%adjustc(40))           ! center string in string length of NN
      write(*,101)&#39;lenset(40) ```.............. &#39;, &amp;
       &amp; p(str2%lenset(40))            ! call pad() to force minimal string length
      write(*,101)&#39;trim ```.................... &#39;, &amp;
       &amp; p(str2%trim())                ! same as intrinsic TRIM()
      write(*,101)&#39;crop ```.................... &#39;, &amp;
       &amp; p(str2%crop())                ! trim leading and trailing spaces
      write(*,101)&#39;substitute(&quot;This&quot;,&quot;Here&quot;) .. &#39;, &amp;
       &amp; p(str2%substitute(&quot;This&quot;,&quot;Here&quot;)) ! call SUBSTITUTE()
      write(*,101)&#39;compact ```................. &#39;, &amp;
       &amp; p(str2%compact())                 ! call COMPACT()
      write(*,101)&#39;compact(&quot;&quot;) ```............. &#39;, &amp;
       &amp; p(str2%compact(&quot;&quot;))
      write(*,101)&#39;compact(&quot;:&quot;) ```............ &#39;, &amp;
       &amp; p(str2%compact(&quot;:&quot;))
      ! calls M_strings procedure TRANSLITERATE()
      write(*,101)&#39;transliterate(&quot;aei&quot;,&quot;VWX&quot;) . &#39;, &amp;
       &amp; p(str2%transliterate(&quot;aei&quot;,&quot;VWX&quot;))
      write(*,101)&#39;transliterate(&quot;aeiou&quot;,&quot; &quot;) . &#39;, &amp;
       &amp; p(str2%transliterate(&quot;aeiou&quot;,&quot; &quot;))
      write(*,101)&#39;transliterate(&quot;aeiou&quot;,&quot;&quot;) .. &#39;, &amp;
       &amp; p(str2%transliterate(&quot;aeiou&quot;,&quot;&quot;))
      write(*,101)&#39;transliterate(&quot; aeiou&quot;,&quot;&quot;) . &#39;, &amp;
       &amp; p(str2%transliterate(&quot; aeiou&quot;,&quot;&quot;))
      write(*,404)&#39;chars ```................. . &#39;, &amp;
       &amp; str4%chars()                   ! call SWITCH()

      str2%str=&#39;\t\tSome tabs\t   x\bX &#39;
      write(*,101)&#39;str2%str ```................ &#39;,str2%str
      write(*,101)&#39;expand ```.................. &#39;, &amp;
       &amp; p(str2%expand())
      str2=str2%expand()
      write(*,101)&#39;notabs ```.................. &#39;, &amp;
       &amp; p(str2%notabs())               ! calls NOTABS()
      write(*,101)&#39;noesc ```................... &#39;, &amp;
       &amp; p(str2%noesc())                ! calls NOESC()

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;Casting to numeric variables&#39;
      str3=string(&#39;   12.345678901234567e1        &#39;)
      write(*,101)&#39;str3%str ```................ &#39;,str3%str
      ! calls to M_strings procedure STRING_TO_VALUE()
      write(*,*)&#39;int  ```.................... &#39;, str3%int()
      write(*,*)&#39;nint ```.................... &#39;, str3%nint()
      write(*,*)&#39;real ```.................... &#39;, str3%real()
      write(*,*)&#39;dble ```.................... &#39;, str3%dble()

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;Matching simple globbing patterns&#39;
      str3=string(&#39;   12.345678901234567e1        &#39;)
      str3=string(&#39;Four score and seven years ago&#39;)
      write(*,101)&#39;str3%str ```................ &#39;,str3%str
      ! %match calls M_strings procedure GLOB
      write(*,*)&#39;match(&quot;Fo*&quot;) ```............ &#39;, str3%match(&quot;Fo*&quot;)
      write(*,*)&#39;match(&quot;and&quot;) ```............ &#39;, str3%match(&quot;and&quot;)
      write(*,*)&#39;match(&quot;*and*&quot;) ```.......... &#39;, str3%match(&quot;*and*&quot;)

      101 format(1x,a,&quot;[&quot;,a,&quot;]&quot;)
      202 format(1x,a,i0)
      303 format(1x,*(l3))
      404 format(1x,a,*(&quot;[&quot;,a1,&quot;]&quot;:))

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))&#39;
      str1%str=&#39;123.456&#39;
      str2%str=&#39;AaBbCcDdEeFfGgHhIi AaBbCcDdEeFfGgHhIi&#39;
      write(*,101)&#39;str1%str ```................ &#39;,str1%str
      write(*,101)&#39;str2%str ```................ &#39;,str2%str
      write(*,*)&#39;str1 + str2 ```............. &#39;,p(str1 + str2)
      ! a string that looks like a numeric value can have a value added
      write(*,*)&#39;str1 + 20000 ```............ &#39;,p(str1 +20000)
      write(*,*)&#39;str1 - 20.0 ```............. &#39;,p(str1 -20.0)
      write(*,*)&#39;str2 - &quot;Aa&quot; (removes ALL) .. &#39;,p(str2 - &#39;Aa&#39;)

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;OVERLOADED OPERATORS (multiply,return TYPE(STRING))&#39;
      str1%str=&#39;AaBbCcDdEeFfGgHhIi&#39;
      write(*,101)&#39;str1%str ```................ &#39;,str1%str
      write(*,*)&#39;str1 * 2 ```................ &#39;,p(str1 * 2)

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;OVERLOADED OPERATORS (//,return TYPE(STRING))&#39;
      str1%str=&#39;String one:&#39;
      str2%str=&#39;String two:&#39;
      write(*,101)&#39;str1%str ```................ &#39;,str1%str
      write(*,101)&#39;str2%str ```................ &#39;,str2%str
      write(*,*)&#39;str1 // str2 ```............. &#39;,p(str1 // str2)
      ! numeric values are converted to strings
      write(*,*)&#39;str1 // 20000 ```............ &#39;,p(str1 // 20000)
      write(*,*)&#39;str1 // 20.0 ```............. &#39;,p(str1 // 20.0)

      write(*,*)repeat(&#39;=&#39;,68)
      write(*,*)&#39;OVERLOADED OPERATORS (logical comparisons,return logical)&#39;
      ! NOTE: comparisons are performed on the character variable members
      !       of the type(string)
      str1%str=&#39;abcdefghij&#39;
      str2%str=&#39;klmnopqrst&#39;
      write(*,101)&#39;str1%str ```................ &#39;,str1%str
      write(*,101)&#39;str2%str ```................ &#39;,str2%str
      write(*,*)&#39;: EQ LT GT LE GE NE&#39;
      write(*,*)&#39;compare str1 to str1&#39;
      write(*,303)str1 == str1  ,str1 &lt; str1  ,str1 &gt; str1  ,str1 &lt;= str1 &amp;
                 &amp; ,str1 &gt;= str1  ,str1 /= str1
      write(*,*)&#39;compare str1 to str2&#39;
      write(*,303)str1 == str2  ,str1 &lt; str2  ,str1 &gt; str2  ,str1 &lt;= str2 &amp;
                 &amp; ,str1 &gt;= str2  ,str1 /= str2
      write(*,*)&#39;compare str2 to str1&#39;
      write(*,303)str2 == str1  ,str2 &lt; str1  ,str2 &gt; str1  ,str2 &lt;= str1 &amp;
                 &amp; ,str2 &gt;= str1  ,str2 /= str1

      write(*,*)repeat(&#39;=&#39;,68)

    end program demo_M_strings__oop
</code></pre>
<p>Expected output</p>
<pre><code>  exercise the M_STRING_OOP module interface
  ===================================================================
  Call methods of type(STRING)
  ===================================================================
  str2%str is ```............. [   This  is  a  String!             ]
  len ```..................... 36
  len_trim ```................ 23
  index(&quot;is&quot;)```.............. 6
  index(&quot;is&quot;,back=.T.) ```.... 10
  upper ```................... [   THIS  IS  A  STRING!             ]
  lower ```................... [   this  is  a  string!             ]
  reverse ```................. [             !gnirtS  a  si  sihT   ]
  adjustl ```................. [This  is  a  String!                ]
  adjustr ```................. [                This  is  a  String!]
  adjustc ```................. [        This  is  a  String!        ]
  adjustc(40) ```............. [              This  is  a  String!      ]
  lenset(40) ```.............. [   This  is  a  String!                 ]
  trim ```.................... [   This  is  a  String!]
  crop ```.................... [This  is  a  String!]
  substitute(&quot;This&quot;,&quot;Here&quot;) .. [   Here  is  a  String!             ]
  compact ```................. [This is a String!]
  compact(&quot;&quot;) ```............. [ThisisaString!]
  compact(&quot;:&quot;) ```............ [This:is:a:String!]
  transliterate(&quot;aei&quot;,&quot;VWX&quot;) . [   ThXs  Xs  V  StrXng!             ]
  transliterate(&quot;aeiou&quot;,&quot; &quot;) . [   Th s   s     Str ng!             ]
  transliterate(&quot;aeiou&quot;,&quot;&quot;) .. [   Ths  s    Strng!                 ]
  transliterate(&quot; aeiou&quot;,&quot;&quot;) . [ThssStrng!                          ]
  chars ```................. . [ ][a][ ][s][t][r][i][n][g][ ]
  ===================================================================
  str2%str ```................ [\t\tSome tabs\t   x\bX ]
  expand ```.................. [         Some tabs          x   X]
  notabs ```.................. [                Some tabs          x    X]
  noesc ```................... [  Some tabs    x X]
  ===================================================================
  Casting to numeric variables
  str3%str ```................ [   12.345678901234567e1        ]
  int  ```....................          123
  real ```....................    123.456787
  dble ```....................    123.45678901234567
  ===================================================================
  Matching simple globbing patterns
  str3%str ```................ [Four score and seven years ago]
  match(&quot;Fo*&quot;) ```............  T
  match(&quot;and&quot;) ```............  F
  match(&quot;*and*&quot;) ```..........  T
  ====================================================================
  OVERLOADED OPERATORS (add and subtract, return TYPE(STRING))
  str1%str ```............... [123.456]
  str2%str ```............... [AaBbCcDdEeFfGgHhIi AaBbCcDdEeFfGgHhIi]
  str1 + str2 ```............ 123.456 AaBbCcDdEeFfGgHhIi AaBbCcDdEeFfGgHhIi
  str1 + 20000 ```........... 20123.455999999998
  str1 - 20.0 ```............ -103.456
  str2 - &quot;Aa&quot; (removes ALL) . BbCcDdEeFfGgHhIi BbCcDdEeFfGgHhIi
  ===================================================================
  OVERLOADED OPERATORS (multiply, return TYPE(STRING))
  str1%str ```................ [AaBbCcDdEeFfGgHhIi]
  str1 * 2 ```................ AaBbCcDdEeFfGgHhIiAaBbCcDdEeFfGgHhIi
  ===================================================================
  OVERLOADED OPERATORS (//, return TYPE(STRING))
  str1%str ```................ [String one:]
  str2%str ```................ [String two:]
  str1 // str2 ```............ String one:String two:
  str1 // 20000 ```........... String one:20000
  str1 // 20.0 ```............ String one:20.0
  ===================================================================
  OVERLOADED OPERATORS (logical comparisons, return logical)
  str1%str ```................ [abcdefghij]
  str2%str ```................ [klmnopqrst]
  : EQ LT GT LE GE NE
  compare str1 to str1
  :  T  F  F  T  T  F
  compare str1 to str2
  :  F  T  F  T  F  T
  compare str2 to str1
  :  F  F  T  F  T  T
  ===================================================================
</code></pre>
<h2 id="author-51">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-51">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-54" class="slide section level1">
<h1>NAME</h1>
<p>nint(3f) - [M_strings:TYPE] overloads NINT(3f) so it can handle character arguments (LICENSE:PD)</p>
<h2 id="synopsis-54">SYNOPSIS</h2>
<p>impure elemental function nint(string)</p>
<pre><code>    character(len=*) :: string
    integer          :: nint
</code></pre>
<h2 id="description-54">DESCRIPTION</h2>
<p>nint(3f) returns an integer when given a numeric representation of a numeric value. This overloads the NINT(3f) intrinsic so that CHARACTER arguments assumed to represent a numeric value may be input.</p>
<h2 id="options-44">OPTIONS</h2>
<ul>
<li><strong>STRING</strong><br />
input string to be converted to an integer</li>
</ul>
<h2 id="returns-36">RETURNS</h2>
<ul>
<li><strong>NINT</strong><br />
integer represented by input string</li>
</ul>
<h2 id="examples-54">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_nint
     use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
     use M_strings, only: nint
     implicit none
     character(len=*),parameter :: g=&#39;(*(g0,1x))&#39;
        write(*,g)nint(&#39;100&#39;),nint(&#39;20.4&#39;)
        write(*,g)&#39;intrinsic nint(3f) still works&#39;,nint(20.4)
        write(*,g)&#39;elemental&#39;,&amp;
        &amp; nint([character(len=23) :: &#39;10&#39;,&#39;20.3&#39;,&#39;20.5&#39;,&#39;20.6&#39;])
     end program demo_nint
</code></pre>
<p>Results:</p>
<pre><code>    &gt; 100 20
    &gt; intrinsic nint(3f) still works 20
    &gt; elemental 10 20 21 21
</code></pre>
<h2 id="author-52">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-52">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-55" class="slide section level1">
<h1>NAME</h1>
<p>noesc(3f) - [M_strings:NONALPHA] convert non-printable characters to a space (LICENSE:PD)</p>
<h2 id="synopsis-55">SYNOPSIS</h2>
<p>elemental function noesc(INSTR)</p>
<pre><code>    character(len=*),intent(in) :: INSTR
    character(len=len(instr))   :: noesc
</code></pre>
<h2 id="description-55">DESCRIPTION</h2>
<p>Convert non-printable characters to a space.</p>
<h2 id="examples-55">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_noesc

    use M_strings, only : noesc
    implicit none
    character(len=128) :: ascii
    character(len=128) :: cleared
    integer            :: i
    ! fill variable with base ASCII character set
    do i=1,128
       ascii(i:i)=char(i-1)
    enddo
    cleared=noesc(ascii)
    write(*,*)&#39;characters and their ADE (ASCII Decimal Equivalent)&#39;
    call ade(ascii)
    write(*,*)&#39;Cleared of non-printable characters&#39;
    call ade(cleared)
    write(*,*)&#39;Cleared string:&#39;
    write(*,*)cleared
    contains
      subroutine ade(string)
      implicit none
      ! the string to print
      character(len=*),intent(in) :: string
      ! number of characters in string to print
      integer :: lgth
      ! counter used to step thru string
      integer :: i
         ! get trimmed length of input string
         lgth=len_trim(string(:len(string)))

         ! replace lower unprintable characters with spaces
         write(*,101)(merge(string(i:i),&#39; &#39;,&amp;
         &amp; iachar(string(i:i)) &gt;= 32        &amp;
         &amp; .and.                            &amp;
         &amp; iachar(string(i:i)) &lt;= 126)      &amp;
         &amp; ,i=1,lgth)

         ! print ADE value of character underneath it
         write(*,202)     (iachar(string(i:i))/100,    i=1,lgth)
         write(*,202)(mod( iachar(string(i:i)),100)/10,i=1,lgth)
         write(*,202)(mod((iachar(string(i:i))),10),   i=1,lgth)
      ! format for printing string characters
      101   format(*(a1:))
      ! format for printing ADE values
      202   format(*(i1:))
      end subroutine ade
    end program demo_noesc

   Expected output

   The string is printed with the ADE value vertically beneath.
   The original string has all the ADEs from 000 to 127. After
   NOESC(3f) is called on the string all the &quot;non-printable&quot;
   characters are replaced with a space (ADE of 032).
</code></pre>
<p>characters and their ADE (ASCII Decimal Equivalent)</p>
<pre><code>   &gt;                                 !&quot;#$%&amp;&#39;()*+,-./0123456789
   :;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
   &gt;0000000000000000000000000000000000000000000000000000000000
   0000000000000000000000000000000000000000001111111111111111111111111111
   &gt;00000000001111111111222222222233333333334444444444555555555566666666
   667777777777888888888899999999990000000000111111111122222222
   &gt;012345678901234567890123456789012345678901234567890123456789012345678
   90123456789012345678901234567890123456789012345678901234567
</code></pre>
<p>Cleared of non-printable characters</p>
<pre><code>   &gt;                                 !&quot;#$%&amp;&#39;()*+,-./0123456789
   :;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
   &gt;0000000000000000000000000000000000000000000000000000000000
   000000000000000000000000000000000000000000111111111111111111111111111
   &gt;3333333333333333333333333333333333333333444444444455555555
   556666666666777777777788888888889999999999000000000011111111112222222
   &gt;2222222222222222222222222222222223456789012345678901234567
   890123456789012345678901234567890123456789012345678901234567890123456
</code></pre>
<p>Cleared string:</p>
<pre><code>   &gt;                                  !&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@
   ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<h2 id="author-53">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-53">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-56" class="slide section level1">
<h1>NAME</h1>
<p>nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from input string (LICENSE:PD)</p>
<h2 id="synopsis-56">SYNOPSIS</h2>
<p>function nospace(str) - remove all whitespace from input string</p>
<pre><code>    character(len=*),intent(in)          :: str
    character(len=:),allocatable         :: nospace
</code></pre>
<h2 id="description-56">DESCRIPTION</h2>
<p>nospace(3f) removes space, tab, carriage return, new line, vertical tab, formfeed and null characters (called "whitespace"). The output is returned trimmed.</p>
<h2 id="examples-56">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_nospace
    use M_strings, only: nospace
    implicit none
    character(len=:),allocatable  :: s
       s=&#39;  This     is      a     test  &#39;
       write(*,*) &#39;original input string is ```.&#39;,s
       write(*,*) &#39;processed output string is ```&#39;,nospace(s)
       if(nospace(s) == &#39;Thisisatest&#39;)then
          write(*,*)&#39;nospace test passed&#39;
       else
          write(*,*)&#39;nospace test error&#39;
       endif
    end program demo_nospace
</code></pre>
<p>Expected output</p>
<pre><code>    original input string is ```.  This     is      a     test
    processed output string is ```Thisisatest
    nospace test passed
</code></pre>
<h2 id="author-54">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-54">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-57" class="slide section level1">
<h1>NAME</h1>
<p>notabs(3f) - [M_strings:NONALPHA] expand tab characters (LICENSE:PD)</p>
<h2 id="synopsis-57">SYNOPSIS</h2>
<p>subroutine notabs(INSTR,OUTSTR,lgth)</p>
<pre><code>    character(len=*),intent=(in)  :: INSTR
    character(len=*),intent=(out) :: OUTSTR
    integer,intent=(out)          :: lgth
</code></pre>
<h2 id="description-57">DESCRIPTION</h2>
<p>NOTABS() converts tabs in INSTR to spaces in OUTSTR while maintaining columns. It assumes a tab is set every 8 characters. Trailing spaces are removed.</p>
<p>In addition, trailing carriage returns and line feeds are removed (they are usually a problem created by going to and from MSWindows).</p>
<p>What are some reasons for removing tab characters from an input line? Some Fortran compilers have problems with tabs, as tabs are not part of the Fortran character set. Some editors and printers will have problems with tabs. It is often useful to expand tabs in input files to simplify further processing such as tokenizing an input line.</p>
<h2 id="options-45">OPTIONS</h2>
<ul>
<li><strong>instr</strong><br />
Input line to remove tabs from</li>
</ul>
<h2 id="returns-37">RETURNS</h2>
<ul>
<li><p><strong>outstr</strong><br />
Output string with tabs expanded. Assumed to be of sufficient length</p></li>
<li><p><strong>lgth</strong><br />
Significant length of returned string</p></li>
</ul>
<h2 id="examples-57">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_notabs

   !  test filter to remove tabs and trailing white space from input
   !  on files up to 1024 characters wide
   use M_strings, only : notabs
   character(len=1024) :: in,out
   integer             :: ios,iout
      do
         read(*,&#39;(A)&#39;,iostat=ios)in
         if(ios /= 0) exit
         call notabs(in,out,iout)
         write(*,&#39;(a)&#39;)out(:iout)
      enddo
   end program demo_notabs
</code></pre>
<h2 id="see-also-2">SEE ALSO</h2>
<p>GNU/Unix commands expand(1) and unexpand(1)</p>
<h2 id="author-55">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-55">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-58" class="slide section level1">
<h1>NAME</h1>
<p>pad(3f) - [M_strings:LENGTH] return string padded to at least specified length (LICENSE:PD)</p>
<h2 id="synopsis-58">SYNOPSIS</h2>
<p>function pad(str,length,pattern,right,clip) result(strout)</p>
<pre><code>   character(len=*)                           :: str
   integer,intent(in)                         :: length
   character(len=max(length,len(trim(line)))) :: strout
   character(len=*),intent(in),optional       :: pattern
   logical,intent(in),optional                :: right
   logical,intent(in),optional                :: clip
</code></pre>
<h2 id="description-58">DESCRIPTION</h2>
<p>pad(3f) pads a string with a pattern to at least the specified length. If the trimmed input string is longer than the requested length the trimmed string is returned.</p>
<h2 id="options-46">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
the input string to return trimmed, but then padded to the specified length if shorter than length</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return</p></li>
<li><p><strong>pattern</strong><br />
optional string to use as padding. Defaults to a space.</p></li>
<li><p><strong>right</strong><br />
if true pads string on the right, else on the left</p></li>
<li><p><strong>clip</strong><br />
trim spaces from input string but otherwise retain length. Except for simple cases you typically would trim the input yourself.</p></li>
</ul>
<h2 id="returns-38">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
The input string padded to the requested length or the trimmed input string if the input string is longer than the requested length.</li>
</ul>
<h2 id="examples-58">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_pad
    use M_strings, only : pad
    implicit none
    character(len=10)            :: string=&#39;abcdefghij&#39;
    character(len=:),allocatable :: answer
    integer                      :: i
    character(len=*),parameter   :: g=&#39;(*(g0))&#39;
       answer=pad(string,5)
       write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
       answer=pad(string,20)
       write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
       i=30
       write(*,g)
       write(*,&#39;(1x,a,1x,i0)&#39;) &amp;
        &amp; pad(&#39;CHAPTER 1 : The beginning &#39;,i,&#39;.&#39;), 1   , &amp;
        &amp; pad(&#39;CHAPTER 2 : The end &#39;,i,&#39;.&#39;),       1234, &amp;
        &amp; pad(&#39;APPENDIX &#39;,i,&#39;.&#39;),                  1235
       write(*,*)
       write(*,&#39;(1x,a,i7)&#39;) &amp;
        &amp; pad(&#39;CHAPTER 1 : The beginning &#39;,i,&#39;.&#39;), 1   , &amp;
        &amp; pad(&#39;CHAPTER 2 : The end &#39;,i,&#39;.&#39;),       1234, &amp;
        &amp; pad(&#39;APPENDIX &#39;,i,&#39;.&#39;),                  1235

        write(*,g)pad(&#39;12&#39;,5,&#39;0&#39;,right=.false.)

        write(*,g)pad(&#39;12345 &#39;,30,&#39;_&#39;,right=.false.)
        write(*,g)pad(&#39;12345 &#39;,30,&#39;_&#39;,right=.false.,clip=.true.)
        write(*,g)pad(&#39;12345 &#39;,7,&#39;_&#39;,right=.false.)
        write(*,g)pad(&#39;12345 &#39;,7,&#39;_&#39;,right=.false.,clip=.true.)
        write(*,g)pad(&#39;12345 &#39;,6,&#39;_&#39;,right=.false.)
        write(*,g)pad(&#39;12345 &#39;,6,&#39;_&#39;,right=.false.,clip=.true.)
        write(*,g)pad(&#39;12345 &#39;,5,&#39;_&#39;,right=.false.)
        write(*,g)pad(&#39;12345 &#39;,5,&#39;_&#39;,right=.false.,clip=.true.)
        write(*,g)pad(&#39;12345 &#39;,4,&#39;_&#39;,right=.false.)
        write(*,g)pad(&#39;12345 &#39;,4,&#39;_&#39;,right=.false.,clip=.true.)
   end program demo_pad
</code></pre>
<p>Results:</p>
<p>&gt; [abcdefghij]</p>
<ul>
<li><p><strong>&gt; [abcdefghij</strong><br />
&gt;</p></li>
<li><p><strong>&gt;</strong><br />
CHAPTER 1 : The beginning ```. 1</p></li>
<li><p><strong>&gt;</strong><br />
CHAPTER 2 : The end ```....... 1234</p></li>
<li><p><strong>&gt;</strong><br />
APPENDIX ```.................. 1235 &gt;</p></li>
<li><p><strong>&gt;</strong><br />
CHAPTER 1 : The beginning ```. 1</p></li>
<li><p><strong>&gt;</strong><br />
CHAPTER 2 : The end ```....... 1234</p></li>
<li><p><strong>&gt;</strong><br />
APPENDIX ```.................. 1235 &gt; 00012 &gt; ________________________12345 &gt; _________________________12345 &gt; _12345 &gt; __12345 &gt; 12345 &gt; _12345 &gt; 12345 &gt; 12345 &gt; 12345 &gt; 12345</p></li>
</ul>
<h2 id="see-also-3">SEE ALSO</h2>
<p>adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f)</p>
<p>adjustc(3f), stretch(3f), lpad(3f), rpad(3f), cpad(3f), zpad(3f), lenset(3f)</p>
<h2 id="author-56">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-56">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-59" class="slide section level1">
<h1>NAME</h1>
<p>paragraph(3f) - [M_strings:TOKENS] break a long line into a paragraph (LICENSE:PD)</p>
<h2 id="synopsis-59">SYNOPSIS</h2>
<p>function paragraph(source_string,length)</p>
<pre><code>   character(len=*),intent(in)       :: source_string
   integer,intent(in)                :: length
   character(allocatable(len=length)    :: paragraph(:)
</code></pre>
<h2 id="description-59">DESCRIPTION</h2>
<p>paragraph(3f) breaks a long line into a simple paragraph of specified line length.</p>
<p>Given a long string break it on spaces into an array such that no variable is longer than the specified length. Individual words longer than LENGTH will be placed in variables by themselves.</p>
<h2 id="options-47">OPTIONS</h2>
<ul>
<li><p><strong>SOURCE_STRING</strong><br />
input string to break into an array of shorter strings on blank delimiters</p></li>
<li><p><strong>LENGTH</strong><br />
length of lines to break the string into.</p></li>
</ul>
<h2 id="returns-39">RETURNS</h2>
<ul>
<li><strong>PARAGRAPH</strong><br />
character array filled with data from source_string broken at spaces into variables of length LENGTH.</li>
</ul>
<h2 id="examples-59">EXAMPLES</h2>
<p>sample program</p>
<pre><code>   program demo_paragraph
   use M_strings, only : paragraph
   implicit none
   character(len=:),allocatable :: paragrph(:)
   character(len=*),parameter    :: string= &#39;&amp;
    &amp;one two three four five &amp;
    &amp;six seven eight &amp;
    &amp;nine ten eleven twelve &amp;
    &amp;thirteen fourteen fifteen sixteen &amp;
    &amp;seventeen&#39;

   write(*,*)&#39;LEN=&#39;,len(string)
   write(*,*)&#39;INPUT:&#39;
   write(*,*)string

   paragrph=paragraph(string,40)
   write(*,*)&#39;LEN=&#39;,len(paragrph),&#39; SIZE=&#39;,size(paragrph)
   write(*,*)&#39;OUTPUT:&#39;
   write(*,&#39;(a)&#39;)paragrph

   write(*,&#39;(a)&#39;)paragraph(string,0)
   write(*,&#39;(3x,a)&#39;)paragraph(string,47)

   end program demo_paragraph
</code></pre>
<p>Results:</p>
<pre><code>    LEN=         106
    INPUT:
    one two three four five six seven eight nine ten eleven twelve
    thirteen fourteen fifteen sixteen seventeen
    LEN=          40  SIZE=           3
    OUTPUT:
</code></pre>
<p>one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen</p>
<h2 id="author-57">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-57">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-60" class="slide section level1">
<h1>NAME</h1>
<p>percent_encode(3f) - [M_strings:ENCODE] percent-encode strings and character arrays (LICENSE:PD)</p>
<h2 id="synopsis-60">SYNOPSIS</h2>
<p>function percent_encode(text)</p>
<pre><code>     character(len=1),intent(in)  :: text(:)
     character(len=;),allocatable :: percent_encode
</code></pre>
<p>or</p>
<p>function percent_encode(text)</p>
<pre><code>     character(len=*),intent(in)  :: text
     character(len=;),allocatable :: percent_encode
</code></pre>
<h2 id="description-60">DESCRIPTION</h2>
<p>This function percent-encodes ASCII strings or ASCII character arrays. "Reserved" characters are encoded.</p>
<p>URI containing spaces or most other non-alphanumeric characters must be encoded using percent encoding (aka. URL encoding).</p>
<p>The characters allowed in a URI are either reserved or unreserved (or a percent character as part of a percent-encoding). Reserved characters are those characters that sometimes have special meaning, while unreserved characters have no such meaning. Using percent-encoding, characters which otherwise would not be allowed are represented using allowed characters. The sets of reserved and unreserved characters and the circumstances under which certain reserved characters have special meaning have changed slightly with each revision of specifications that govern URIs and URI schemes.</p>
<p>According to RFC 3986, the characters in a URL have to be taken from a defined set of unreserved and reserved ASCII characters. Any other characters are not allowed in a URL.</p>
<p>The unreserved characters can be encoded, but should not be. The unreserved characters are:</p>
<pre><code>      &gt; ABCDEFGHIJKLMNOPQRSTUVWXYZ
      &gt; abcdefghijklmnopqrstuvwxyz
      &gt; 0123456789-_.~
</code></pre>
<p>The reserved characters have to be encoded only under certain circumstances. The reserved characters are:</p>
<pre><code>      &gt;  * &#39; ( ) ; : @ &amp; = + $ , / ? % # [ ]
</code></pre>
<h2 id="options-48">OPTIONS</h2>
<ul>
<li><strong>SOURCE_STRING</strong><br />
string or character array to encode</li>
</ul>
<h2 id="returns-40">RETURNS</h2>
<ul>
<li><strong>percent_encode</strong><br />
a string holding a percent-encoded copy of the input</li>
</ul>
<h2 id="examples-60">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_percent_encode
   use M_strings, only : percent_encode
   use, intrinsic :: iso_fortran_env, only : stdout=&gt;output_unit
   implicit none
      write(*,*)percent_encode(&#39;[this is a string]&#39;)
   end program demo_percent_encode
</code></pre>
<p>Results:</p>
<pre><code> &gt;  %5Bthis%20is%20a%20string%5D
</code></pre>
<h2 id="author-58">AUTHOR</h2>
<p>John S. Urban</p>
</div>
<div id="name-61" class="slide section level1">
<h1>NAME</h1>
<p>quote(3f) - [M_strings:QUOTES] add quotes to string as if written with list-directed output (LICENSE:PD)</p>
<h2 id="synopsis-61">SYNOPSIS</h2>
<p>function quote(str,mode,clip) result (quoted_str)</p>
<pre><code>   character(len=*),intent(in)          :: str
   character(len=*),optional,intent(in) :: mode
   logical,optional,intent(in)          :: clip
   character(len=:),allocatable         :: quoted_str
</code></pre>
<h2 id="description-61">DESCRIPTION</h2>
<p>Add quotes to a CHARACTER variable as if it was written using list-directed output. This is particularly useful for processing strings to add to CSV files.</p>
<h2 id="options-49">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
input string to add quotes to, using the rules of list-directed output (single quotes are replaced by two adjacent quotes)</p></li>
<li><p><strong>mode</strong><br />
alternate quoting methods are supported:</p></li>
</ul>
<!-- end list -->

<pre><code>            DOUBLE   default. replace quote with double quotes
            ESCAPE   replace quotes with backslash-quote instead of
                     double quotes
</code></pre>
<ul>
<li><strong>clip</strong><br />
default is to trim leading and trailing spaces from the string. If CLIP is .FALSE. spaces are not trimmed</li>
</ul>
<h2 id="returns-41">RETURNS</h2>
<ul>
<li><strong>quoted_str</strong><br />
The output string, which is based on adding quotes to STR.</li>
</ul>
<h2 id="examples-61">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_quote
   use M_strings, only : quote
   implicit none
   integer                      :: i
   character(len=*),parameter   :: f=&#39;(*(g0))&#39;
   character(len=:),allocatable :: str
   character(len=80),parameter  :: data(3)=[character(len=80)::&amp;
      &#39;test string&#39;,&amp;
      &#39;quote=&quot;&#39;,&amp;
      &#39;&quot;word1&quot; &quot;word2&quot;&#39;]
      do i=1,size(data)
         ! the original string
         write(*,&#39;(a)&#39;)&#39;ORIGINAL      &#39;//trim(data(i))

         ! the string processed by quote(3f)
         str=quote(data(i))
         write(*,&#39;(a)&#39;)&#39;QUOTED        &#39;//str

         ! write the string list-directed to compare the results
         write(*,f,advance=&#39;no&#39;) &#39;LIST DIRECTED&#39;
         ! default is often NONE or APOSTROPHE
         write(*,*,delim=&#39;quote&#39;) trim(data(i))
      enddo
   end program demo_quote
</code></pre>
<p>Results:</p>
<pre><code> &gt; ORIGINAL      test string
 &gt; QUOTED        &quot;test string&quot;
 &gt; LIST DIRECTED &quot;test string&quot;
 &gt; ORIGINAL      quote=&quot;
 &gt; QUOTED        &quot;quote=&quot;&quot;&quot;
 &gt; LIST DIRECTED &quot;quote=&quot;&quot;&quot;
 &gt; ORIGINAL      &quot;word1&quot; &quot;word2&quot;
 &gt; QUOTED        &quot;&quot;&quot;word1&quot;&quot; &quot;&quot;word2&quot;&quot;&quot;
 &gt; LIST DIRECTED &quot;&quot;&quot;word1&quot;&quot; &quot;&quot;word2&quot;&quot;&quot;
</code></pre>
<h2 id="author-59">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-58">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-62" class="slide section level1">
<h1>NAME</h1>
<p>real(3f) - [M_strings:TYPE] overloads REAL(3f) so it can handle character arguments (LICENSE:PD)</p>
<h2 id="synopsis-62">SYNOPSIS</h2>
<p>impure elemental function real(string)</p>
<pre><code>    character(len=*) :: string
    integer          :: real
</code></pre>
<h2 id="description-62">DESCRIPTION</h2>
<p>real(3f) returns a REAL value when given a numeric representation of a numeric value. This overloads the REAL(3f) intrinsic so that CHARACTER arguments assumed to represent a numeric value may be input.</p>
<h2 id="options-50">OPTIONS</h2>
<ul>
<li><strong>STRING</strong><br />
input string to be converted to a real value</li>
</ul>
<h2 id="returns-42">RETURNS</h2>
<ul>
<li><strong>REAL</strong><br />
real value represented by input string</li>
</ul>
<h2 id="examples-62">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_real
     use M_strings, only: real
     implicit none
     write(*,*)real(&#39;100&#39;),real(&#39;20.4&#39;)
     write(*,*)&#39;real still works&#39;,real(20)
     write(*,*)&#39;elemental&#39;,&amp;
     &amp; real([character(len=23) :: &#39;10&#39;,&#39;20.3&#39;,&#39;20.5&#39;,&#39;20.6&#39;])
     end program demo_real
</code></pre>
<p>Results:</p>
<pre><code>     &gt;    100.000000       20.3999996
     &gt;  real still works   20.0000000
     &gt;  elemental   10.0000000  20.2999992  20.5000000  20.6000004
</code></pre>
<h2 id="author-60">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-59">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-63" class="slide section level1">
<h1>NAME</h1>
<p>replace(3f) - [M_strings:EDITING] function replaces one substring for another in string (LICENSE:PD)</p>
<h2 id="synopsis-63">SYNOPSIS</h2>
<p>syntax:</p>
<pre><code>     function replace(targetline,old,new,cmd,&amp;
      &amp; occurrence, &amp;
      &amp; repeat, &amp;
      &amp; ignorecase, &amp;
      &amp; ierr) result (newline)
     character(len=*)                       :: targetline
     character(len=*),intent(in),optional   :: old
     character(len=*),intent(in),optional   :: new
     character(len=*),intent(in),optional   :: cmd
     integer,intent(in),optional            :: occurrence
     integer,intent(in),optional            :: repeat
     logical,intent(in),optional            :: ignorecase
     integer,intent(out),optional           :: ierr
     character(len=:),allocatable           :: newline
</code></pre>
<h2 id="description-63">DESCRIPTION</h2>
<p>Replace one substring for another in string. Either CMD or OLD and NEW must be specified.</p>
<h2 id="options-51">OPTIONS</h2>
<ul>
<li><p><strong>targetline</strong><br />
input line to be changed</p></li>
<li><p><strong>old</strong><br />
old substring to replace</p></li>
<li><p><strong>new</strong><br />
new substring</p></li>
<li><p><strong>cmd</strong><br />
alternate way to specify old and new string, in the form c/old/new/; where "/" can be any character not in "old" or "new".</p></li>
<li><p><strong>occurrence</strong><br />
if present, start changing at the Nth occurrence of the OLD string. If negative start replacing from the left end of the string.</p></li>
<li><p><strong>repeat</strong><br />
number of replacements to perform. Defaults to a global replacement.</p></li>
<li><p><strong>ignorecase</strong><br />
whether to ignore ASCII case or not. Defaults to .false. .</p></li>
</ul>
<h2 id="returns-43">RETURNS</h2>
<ul>
<li><p><strong>newline</strong><br />
allocatable string returned</p></li>
<li><p><strong>ierr</strong><br />
error code. iF ier = <strong>-1</strong> bad directive, &gt;= 0 then count of changes made.</p></li>
</ul>
<h2 id="examples-63">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_replace
   use M_strings, only : replace
   implicit none
   character(len=:),allocatable :: line

   write(*,*)replace(&#39;Xis is Xe string&#39;,&#39;X&#39;,&#39;th&#39;)
   write(*,*)replace(&#39;Xis is xe string&#39;,&#39;x&#39;,&#39;th&#39;,ignorecase=.true.)
   write(*,*)replace(&#39;Xis is xe string&#39;,&#39;X&#39;,&#39;th&#39;,ignorecase=.false.)

   ! a null old substring means &quot;at beginning of line&quot;
   write(*,*) replace(&#39;my line of text&#39;,&#39;&#39;,&#39;BEFORE:&#39;)

   ! a null new string deletes occurrences of the old substring
   write(*,*) replace(&#39;I wonder i ii iii&#39;,&#39;i&#39;,&#39;&#39;)

   ! Examples of the use of RANGE

   line=replace(&#39;aaaaaaaaa&#39;,&#39;a&#39;,&#39;A&#39;,occurrence=1,repeat=1)
   write(*,*)&#39;replace first a with A [&#39;//line//&#39;]&#39;

   line=replace(&#39;aaaaaaaaa&#39;,&#39;a&#39;,&#39;A&#39;,occurrence=3,repeat=3)
   write(*,*)&#39;replace a with A for 3rd to 5th occurrence [&#39;//line//&#39;]&#39;

   line=replace(&#39;ababababa&#39;,&#39;a&#39;,&#39;&#39;,occurrence=3,repeat=3)
   write(*,*)&#39;replace a with null instances 3 to 5 [&#39;//line//&#39;]&#39;

   line=replace( &amp;
    &amp; &#39;a b ab baaa aaaa aa aa a a a aa aaaaaa&#39;,&amp;
    &amp; &#39;aa&#39;,&#39;CCCC&#39;,occurrence=-1,repeat=1)
   write(*,*)&#39;replace lastaa with CCCC [&#39;//line//&#39;]&#39;

   write(*,*)replace(&#39;myf90stuff.f90.f90&#39;,&#39;f90&#39;,&#39;for&#39;,occurrence=-1,repeat=1)
   write(*,*)replace(&#39;myf90stuff.f90.f90&#39;,&#39;f90&#39;,&#39;for&#39;,occurrence=-2,repeat=2)

   end program demo_replace
</code></pre>
<p>Results:</p>
<pre><code>    this is the string
    this is the string
    this is xe string
    BEFORE:my line of text
    I wonder
    replace first a with A [Aaaaaaaaa]
    replace a with A for 3rd to 5th occurrence [aaAAAaaaa]
    replace a with null instances 3 to 5 [ababbb]
    replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC]
    myf90stuff.f90.for
    myforstuff.for.f90
</code></pre>
<h2 id="author-61">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-60">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-64" class="slide section level1">
<h1>NAME</h1>
<p>reverse(3f) - [M_strings:EDITING] Return a string reversed (LICENSE:PD)</p>
<h2 id="synopsis-64">SYNOPSIS</h2>
<p>elemental pure function reverse(str) result (string)</p>
<pre><code>    character(*), intent(in) :: str
    character(len(str))      :: string
</code></pre>
<h2 id="description-64">DESCRIPTION</h2>
<p>reverse(string) returns a copy of the input string with all characters reversed from right to left.</p>
<h2 id="examples-64">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>      program demo_reverse
      use M_strings, only: reverse
      implicit none
      character(len=:),allocatable  :: s
         write(*,*)&#39;REVERSE STRINGS:&#39;,reverse(&#39;Madam, I&#39;&#39;m Adam&#39;)
         s=&#39;abcdefghijklmnopqrstuvwxyz&#39;
         write(*,*) &#39;original input string is ```.&#39;,s
         write(*,*) &#39;reversed output string is ```&#39;,reverse(s)
      end program demo_reverse
</code></pre>
<p>Results:</p>
<pre><code>     &gt;  REVERSE STRINGS:madA m&#39;I ,madaM
     &gt;  original input string is ```.abcdefghijklmnopqrstuvwxyz
     &gt;  reversed output string is ```zyxwvutsrqponmlkjihgfedcba
</code></pre>
<h2 id="author-62">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-61">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-65" class="slide section level1">
<h1>NAME</h1>
<p>rotate13(3f) - [M_strings:ENCODE] apply trivial ROT13 encryption to a string (LICENSE:PD)</p>
<h2 id="synopsis-65">SYNOPSIS</h2>
<p>rotate13(input) result(output)</p>
<pre><code>    character(len=*),intent(in) :: input
    character(len=len(input))   :: output
</code></pre>
<h2 id="description-65">DESCRIPTION</h2>
<p>ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet; wrapping around if necessary.</p>
<p>The transformation can be done using a lookup table, such as the following:</p>
<pre><code>      Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
      Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
</code></pre>
<p>ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. ROT13 has inspired a variety of letter and word games on-line, and is frequently mentioned in newsgroup conversations.</p>
<p>The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.</p>
<p>ROT13 is a special case of the Caesar cipher which was developed in ancient Rome.</p>
<h3 id="algorithm">ALGORITHM</h3>
<p>Applying ROT13 to a piece of text merely requires examining its alphabetic characters and replacing each one by the letter 13 places further along in the alphabet, wrapping back to the beginning if necessary. A becomes N, B becomes O, and so on up to M, which becomes Z, then the sequence continues at the beginning of the alphabet: N becomes A, O becomes B, and so on to Z, which becomes M. Only those letters which occur in the English alphabet are affected; numbers, symbols, whitespace, and all other characters are left unchanged.</p>
<h3 id="same-algorithm-for-encoding-and-decoding">SAME ALGORITHM FOR ENCODING AND DECODING</h3>
<p>Because there are 26 letters in the English alphabet and 26 = 2 x 13, the ROT13 function is its own inverse: so the same action can be used for encoding and decoding. In other words, two successive applications of ROT13 restore the original text (in mathematics, this is sometimes called an involution; in cryptography, a reciprocal cipher).</p>
<h3 id="trivial-security">TRIVIAL SECURITY</h3>
<p>The use of a constant shift means that the encryption effectively has no key, and decryption requires no more knowledge than the fact that ROT13 is in use. Even without this knowledge, the algorithm is easily broken through frequency analysis.</p>
<p>In encrypted normal English-language text of any significant size, ROT13 is recognizable from some letter/word patterns. The words "n", "V" (capitalized only), and "gur" (ROT13 for "a", "I", and "the"), and words ending in "yl" ("ly") are examples.</p>
<h2 id="references-1">REFERENCES</h2>
<p>Wikipedia, the free encyclopedia</p>
<h2 id="examples-65">EXAMPLES</h2>
<p>Sample program</p>
<pre><code>   program demo_rotate13
   use M_strings, only : rotate13
   implicit none
   character(len=256) :: line
   integer            :: ios
   do
      read(*,&#39;(a)&#39;,iostat=ios)line
      if(ios /= 0)exit
      write(*,&#39;(a)&#39;)rotate13(line)
   enddo
   end program demo_rotate13
</code></pre>
<p>Sample usage:</p>
<pre><code>   demo_rotate13
   United we stand, divided we fall.
   Havgrq jr fgnaq, qvivqrq jr snyy.
</code></pre>
<h2 id="author-63">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-62">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-66" class="slide section level1">
<h1>NAME</h1>
<p>rpad(3f) - [M_strings:LENGTH] convert to a string and pad on the right to requested length (LICENSE:PD)</p>
<h2 id="synopsis-66">SYNOPSIS</h2>
<p>function rpad(valuein,length) result(strout)</p>
<pre><code>    class*,intent(in)       :: valuein(..)
    integer,intent(in)      :: length
</code></pre>
<h2 id="description-66">DESCRIPTION</h2>
<p>rpad(3f) converts a scalar intrinsic value to a string and then pads it on the right with spaces to at least the specified length. If the trimmed input string is longer than the requested length the string is returned trimmed of leading and trailing spaces.</p>
<h2 id="options-52">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
The input may be scalar or a vector. the input value to return as a string, padded on the left to the specified length if shorter than length. The input may be any intrinsic scalar which is converted to a cropped string much as if written with list-directed output.</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return</p></li>
</ul>
<h2 id="returns-44">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
The input string padded to the requested length on the right with spaces.</li>
</ul>
<h2 id="examples-66">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_rpad
      use M_strings, only : rpad
      implicit none
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( &#39;my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( &#39;my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( &#39;   my string&#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( &#39;   my string   &#39;, 20)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( valuein=42 , length=7)
         write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) rpad( valuein=1.0/9.0 , length=20)
     end program demo_rpad
</code></pre>
<p>Results:</p>
<pre><code>     &gt; [my string           ]
     &gt; [my string           ]
     &gt; [my string           ]
     &gt; [my string           ]
     &gt; [42     ]
     &gt; [0.111111112         ]
</code></pre>
<h2 id="author-64">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-63">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-67" class="slide section level1">
<h1>NAME</h1>
<p>s2c(3f) - [M_strings:ARRAY] convert character variable to array of characters with last element set to null (LICENSE:PD)</p>
<h2 id="synopsis-67">SYNOPSIS</h2>
<p>function s2c(string)</p>
<pre><code>    character(len=*),intent=(in)  :: string
    character(len=1),allocatable  :: s2c(:)
</code></pre>
<h2 id="description-67">DESCRIPTION</h2>
<p>Given a character variable convert it to an array of single-character character variables with the last element set to a null character. This is generally used to pass character variables to C procedures.</p>
<h2 id="examples-67">EXAMPLES</h2>
<p>character(len=3),allocatable :: array(:)</p>
<ul>
<li><p><strong>integer</strong><br />
:: i ! put one character into each 3-character element of array array = [(string(i:i),i=1,len(string))] ! write array with ASCII Decimal Equivalent below it except show ! unprintable characters like NULL as "XXX" write(*,g) merge('XXX',array,iachar(array(:)(1:1)) &lt; 32) write(*,g) iachar(array(:)(1:1))</p>
<p>Sample Program:</p>
<pre><code>    program demo_s2c
    use M_strings, only : s2c
    implicit none
    character(len=*),parameter   :: string=&quot;single string&quot;
    character(len=*),parameter   :: g= &#39;(1x,*(&quot;[&quot;,g3.3,&quot;]&quot;:))&#39;
    character(len=3),allocatable :: array(:)
       write(*,*)&#39;INPUT STRING &#39;,trim(string)
       ! put one character into each 3-character element of array
       array=s2c(string)
       ! write array with ASCII Decimal Equivalent below it except show
       ! unprintable characters like NULL as &quot;XXX&quot;
       write(*,g) merge(&#39;XXX&#39;,array,iachar(array(:)(1:1)) &lt; 32)
       write(*,g) iachar(array(:)(1:1))
    end program demo_s2c
</code></pre>
<p>Expected output:</p>
<pre><code>   INPUT STRING single string
   [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
   [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
</code></pre></li>
</ul>
<h2 id="author-65">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-64">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-68" class="slide section level1">
<h1>NAME</h1>
<p>s2v(3f) - [M_strings:TYPE] function returns doubleprecision numeric value from a string (LICENSE:PD)</p>
<h2 id="synopsis-68">SYNOPSIS</h2>
<p>function s2v(string[,ierr][,onerr])</p>
<pre><code>    character(len=*)             :: string
    doubleprecision              :: s2v
    integer,intent(out),optional :: ierr
    class(*),intent(in),optional :: onerr
</code></pre>
<h2 id="description-68">DESCRIPTION</h2>
<p>This function converts a string to a DOUBLEPRECISION numeric value.</p>
<p>The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take CHARACTER variables. The KIND= keyword is not supported on the extensions.</p>
<h2 id="options-53">OPTIONS</h2>
<ul>
<li><p><strong>string</strong><br />
holds string assumed to represent a numeric value</p></li>
<li><p><strong>ierr</strong><br />
If an error occurs the program is stopped if the optional parameter IERR is not present. If IERR returns a non-zero value an error occurred.</p></li>
<li><p><strong>onerr</strong><br />
The value to return on error. A value of NaN is returned on error by default.</p></li>
</ul>
<h2 id="returns-45">RETURNS</h2>
<ul>
<li><strong>s2v</strong><br />
numeric value read from string</li>
</ul>
<h2 id="examples-68">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_s2v

    use M_strings, only: s2v, int, real, dble
    implicit none
    character(len=8)              :: s=&#39; 10.345 &#39;
    integer                       :: i
    character(len=14),allocatable :: strings(:)
    doubleprecision               :: dv
    integer                       :: errnum

    ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
    strings=[&amp;
    &amp;&#39; 10.345       &#39;,&amp;
    &amp;&#39;+10           &#39;,&amp;
    &amp;&#39;    -3        &#39;,&amp;
    &amp;&#39;    -4.94e-2  &#39;,&amp;
    &amp;&#39;0.1           &#39;,&amp;
    &amp;&#39;12345.678910d0&#39;,&amp;
    &amp;&#39;              &#39;,&amp; ! Note: will return zero without an error message
    &amp;&#39;1 2 1 2 1 . 0 &#39;,&amp; ! Note: spaces will be ignored
    &amp;&#39;WHAT?         &#39;]  ! Note: error messages will appear, zero returned

    ! a numeric value is returned,
    ! so it can be used in numeric expression
    write(*,*) &#39;1/2 value of string is &#39;,s2v(s)/2.0d0
    write(*,*)
    write(*,*)&#39; STRING            VALUE                    ERROR_NUMBER&#39;
    do i=1,size(strings)
       ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
       ! as it does I/O when errors occur, so called on a separate line
       dv=s2v(strings(i),errnum)
       write(*,*) strings(i)//&#39;=&#39;,dv,errnum
    enddo
    write(*,*)&quot;Extended intrinsics&quot;
    write(*,*)&#39;given inputs:&#39;,s,strings(:8)
    write(*,*)&#39;INT(3f):&#39;,int(s),int(strings(:8))
    write(*,*)&#39;REAL(3f):&#39;,real(s),real(strings(:8))
    write(*,*)&#39;DBLE(3f):&#39;,dble(s),dble(strings(:8))
    write(*,*)&quot;That&#39;s all folks!&quot;

    end program demo_s2v

   Expected output

    &gt;1/2 value of string is    5.1725000000000003
    &gt;
    &gt; STRING            VALUE                    ERROR_NUMBER
    &gt; 10.345       =   10.345000000000001                0
    &gt;+10           =   10.000000000000000                0
    &gt;    -3        =  -3.0000000000000000                0
    &gt;    -4.94e-2  =  -4.9399999999999999E-002           0
    &gt;0.1           =  0.10000000000000001                0
    &gt;12345.678910d0=   12345.678910000001                0
    &gt;              =   0.0000000000000000                0
    &gt;1 2 1 2 1 . 0 =   12121.000000000000                0
    &gt;*a2d* - cannot produce number from string [WHAT?]
    &gt;*a2d* - [Bad value during floating point read]
    &gt;WHAT?         =   0.0000000000000000             5010
    &gt;Extended intrinsics
    &gt;given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1
    12345.678910d0 1 2 1 2 1 . 0
    &gt;INT(3f): 10 10 10 -3 0 0 12345 0 12121
    &gt;REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000
    -4.94000018E-02
    &gt;          0.100000001 12345.6787 0.00000000 12121.0000
    &gt;DBLE(3f): 10.345000000000001 10.345000000000001
    10.000000000000000
    &gt;          -3.0000000000000000 -4.9399999999999999E-002
    0.10000000000000001
    &gt;          12345.678910000001 0.0000000000000000
    12121.000000000000
    &gt;That&#39;s all folks!
</code></pre>
<h2 id="author-66">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-65">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-69" class="slide section level1">
<h1>NAME</h1>
<p>s2vs(3f) - [M_strings:TYPE] given a string representing numbers return a numeric array (LICENSE:PD)</p>
<h2 id="synopsis-69">SYNOPSIS</h2>
<p>function s2vs(line[,delim])</p>
<pre><code>       character(len=*) :: line
       doubleprecision,allocatable :: s2vs(:)
</code></pre>
<h2 id="description-69">DESCRIPTION</h2>
<p>The function S2VS(3f) takes a string representing a series of numbers and converts it to a numeric doubleprecision array. The string values may be delimited by spaces, semi-colons, and commas by default.</p>
<h2 id="options-54">OPTIONS</h2>
<ul>
<li><p><strong>LINE</strong><br />
Input string containing numbers</p></li>
<li><p><strong>DELIM</strong><br />
optional list of delimiter characters. If a space is included, it should appear as the left-most character in the list. The default is " ;," (spaces, semi-colons, and commas).</p></li>
</ul>
<h2 id="returns-46">RETURNS</h2>
<ul>
<li><strong>S2VS</strong><br />
doubleprecision array</li>
</ul>
<h2 id="examples-69">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_s2vs
     use M_strings, only : s2vs
     implicit none
     character(len=80) :: s=&#39; 10 20e3;3.45 -400.3e-2;1234; 5678 &#39;
     real,allocatable :: values(:)
     integer,allocatable :: ivalues(:)
     integer :: ii

     values=s2vs(s)
     ivalues=int(s2vs(s))
     call reportit()

     contains
       subroutine reportit()
         write(*,*)&#39;S2VS:&#39;
         write(*,*)&#39;input string```..........&#39;,&amp;
          &amp; trim(s)
         write(*,*)&#39;number of values found```&#39;,&amp;
          &amp; size(values)
         write(*,*)&#39;values```................&#39;,&amp;
          &amp; (values(ii),ii=1,size(values))
         write(*,&#39;(*(g0,1x))&#39;)&#39;ivalues```...............&#39;,&amp;
          &amp; (ivalues(ii),ii=1,size(values))
       end subroutine reportit
     end program demo_s2vs
</code></pre>
<p>Expected output</p>
<pre><code>    S2VS:
    input string```.......... 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found```           6
    values```................   10.0000000 20000.0000 3.45000005
    -4.00299978 1234.00000 5678.00000
</code></pre>
<p>ivalues```............... 10 20000 3 <strong>-4</strong> 1234 5678</p>
<h2 id="author-67">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-66">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-70" class="slide section level1">
<h1>NAME</h1>
<p>sep(3f) - [M_strings:TOKENS] function to parse string into an array using specified delimiters (LICENSE:PD)</p>
<h2 id="synopsis-70">SYNOPSIS</h2>
<p>function sep(input_line,delimiters,nulls)</p>
<pre><code>    character(len=*),intent(in)              :: input_line
    character(len=*),optional,intent(in)     :: delimiters
    character(len=*),optional,intent(in)     :: nulls
    character(len=:),allocatable             :: sep(:)
</code></pre>
<h2 id="description-70">DESCRIPTION</h2>
<p>sep(3f) parses a string using specified delimiter characters and store tokens into an allocatable array</p>
<h2 id="options-55">OPTIONS</h2>
<ul>
<li><p><strong>INPUT_LINE</strong><br />
Input string to tokenize</p></li>
<li><p><strong>DELIMITERS</strong><br />
List of delimiter characters. The default delimiters are the "whitespace" characters (space, tab,new line, vertical tab, formfeed, carriage return, and null). You may specify an alternate set of delimiter characters.</p>
<p>Multi-character delimiters are not supported (Each character in the DELIMITERS list is considered to be a delimiter).</p>
<p>Quoting of delimiter characters is not supported.</p></li>
<li><p><strong>NULLS=IGNORE|RETURN|IGNOREEND</strong><br />
Treatment of null fields. By default adjacent delimiters in the input string do not create an empty string in the output array. if NULLS='return' adjacent delimiters create an empty element in the output ARRAY. If NULLS='ignoreend' then only trailing delimiters at the right of the string are ignored.</p></li>
<li><p><strong>ORDER='ASCENDING'|'DESCENDING'</strong><br />
by default the tokens are returned from last to first; order='ASCENDING' returns them from first to last (left to right).</p></li>
</ul>
<h2 id="returns-47">RETURNS</h2>
<ul>
<li><strong>SEP</strong><br />
Output array of tokens</li>
</ul>
<h2 id="examples-70">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_sep
   use M_strings, only: sep
   character(len=*),parameter :: fo=&#39;(/,a,*(/,&quot;[&quot;,g0,&quot;]&quot;:,&quot;,&quot;))&#39;
   character(len=*),parameter :: line=&amp;
   &#39;  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    &#39;
      write(*,&#39;(a)&#39;) &#39;INPUT LINE:[&#39;//LINE//&#39;]&#39;
      write(*,fo) &#39;typical call:&#39;,sep(line)
      write(*,fo) &#39;delimiters &quot;:|&quot;:&#39;,sep(line,&#39;:|&#39;)
      write(*,fo) &#39;count null fields &quot;:|&quot;:&#39;,sep(line,&#39;:|&#39;,&#39;return&#39;)
   end program demo_sep
</code></pre>
<p>Output</p>
<pre><code>   INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]

   typical call:
   [cc        ],
   [B         ],
   [a         ],
   [333|333   ],
   [1:|:2     ],
   [qrstuvwxyz],
   [ghijklmnop],
   [aBcdef    ]

   delimiters &quot;:|&quot;:
   [333 a B cc                         ],
   [2     333                          ],
   [  aBcdef   ghijklmnop qrstuvwxyz  1]

   count null fields &quot;:|&quot;:
   [333 a B cc                         ],
   [2     333                          ],
   [                                   ],
   [                                   ],
   [  aBcdef   ghijklmnop qrstuvwxyz  1]
</code></pre>
<h2 id="author-68">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-67">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-71" class="slide section level1">
<h1>NAME</h1>
<p>slice(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters (LICENSE:PD)</p>
<h2 id="synopsis-71">SYNOPSIS</h2>
<p>subroutine slice(input_line,ibegin,iend,delimiters,nulls)</p>
<pre><code>    character(len=*),intent(in)              :: input_line
    integer,allocatable,intent(out)          :: ibegin(:),iend(:)
    character(len=*),optional,intent(in)     :: delimiters
    character(len=*),optional,intent(in)     :: nulls
</code></pre>
<h2 id="description-71">DESCRIPTION</h2>
<p>slice(3f) parses a string using specified delimiter characters and store token beginning and ending positions into allocatable arrays</p>
<h2 id="options-56">OPTIONS</h2>
<ul>
<li><p><strong>INPUT_LINE</strong><br />
Input string to tokenize</p></li>
<li><p><strong>IBEGIN,IEND</strong><br />
arrays containing start and end positions of tokens. IEND(I)&lt;IBEGIN(I) designates a null token.</p></li>
<li><p><strong>DELIMITERS</strong><br />
List of delimiter characters. The default delimiters are the "whitespace" characters (space, tab,new line, vertical tab, formfeed, carriage return, and null). You may specify an alternate set of delimiter characters.</p>
<p>Multi-character delimiters are not supported (Each character in the DELIMITERS list is considered to be a delimiter).</p>
<p>Quoting of delimiter characters is not supported.</p></li>
<li><p><strong>NULLS="IGNORE"|"RETURN"|"IGNOREEND"</strong><br />
Treatment of null fields. By default adjacent delimiters in the input string do not create an empty string in the output array. if NULLS='return' adjacent delimiters create an empty element in the output ARRAY. If NULLS='ignoreend' then only trailing delimiters at the right of the string are ignored.</p></li>
</ul>
<h2 id="examples-71">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_slice
    use M_strings, only: slice
    implicit none
    integer :: i
    character(len=*),parameter     :: &amp;
    &amp; line=&#39;  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    &#39;
    integer,allocatable :: ibegin(:), iend(:) ! output arrays of positions
    character(len=*),parameter :: title=&#39;(80(&quot;=&quot;),t1,a)&#39;
       write(*,*)&#39;INPUT LINE:[&#39;//line//&#39;]&#39;
       !
       write(*,title)&#39;typical call: &#39;
       call slice(line,ibegin,iend)
       call printme()
       !
       write(*,title)&#39;custom list of delimiters=&quot;:|&quot; : &#39;
       call slice(line,ibegin,iend,delimiters=&#39;:|&#39;,nulls=&#39;ignore&#39;)
       call printme()
       !
       write(*,title)&#39;delimiters=&quot;:|&quot;, and count null fields: &#39;
       call slice(line,ibegin,iend,delimiters=&#39;:|&#39;,nulls=&#39;return&#39;)
       call printme()
       !
       write(*,title)&#39;default delimiters and return null fields: &#39;
       call slice(line,ibegin,iend,delimiters=&#39;&#39;,nulls=&#39;return&#39;)
       call printme()
    contains
    subroutine printme()
       write(*,&#39;((*(:/,3x,&quot;[&quot;,g0,&quot;]&quot;)))&#39;)&amp;
               &amp; (line(ibegin(i):iend(i)),i=1,size(ibegin))
       write(*,&#39;(*(g0,1x))&#39;)&#39;SIZE:&#39;,size(ibegin)
    end subroutine printme
    end program demo_slice
</code></pre>
<p>Results:</p>
<pre><code> &gt; INPUT LINE:
 &gt; [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
 &gt; typical call: ========================================================
 &gt;
 &gt;    [aBcdef]
 &gt;    [ghijklmnop]
 &gt;    [qrstuvwxyz]
 &gt;    [1:|:2]
 &gt;    [333|333]
 &gt;    [a]
 &gt;    [B]
 &gt;    [cc]
 &gt; SIZE: 8
 &gt; custom list of delimiters=&quot;:|&quot; : =====================================
 &gt;
 &gt;    [  aBcdef   ghijklmnop qrstuvwxyz  1]
 &gt;    [2     333]
 &gt;    [333 a B cc    ]
 &gt; SIZE: 3
 &gt; delimiters=&quot;:|&quot;, and count null fields: ==============================
 &gt;
 &gt;    [  aBcdef   ghijklmnop qrstuvwxyz  1]
 &gt;    []
 &gt;    []
 &gt;    [2     333]
 &gt;    [333 a B cc    ]
 &gt; SIZE: 5
 &gt; default delimiters and return null fields: ===========================
 &gt;
 &gt;    []
 &gt;    []
 &gt;    [aBcdef]
 &gt;    []
 &gt;    []
 &gt;    [ghijklmnop]
 &gt;    [qrstuvwxyz]
 &gt;    []
 &gt;    [1:|:2]
 &gt;    []
 &gt;    []
 &gt;    []
 &gt;    []
 &gt;    [333|333]
 &gt;    [a]
 &gt;    [B]
 &gt;    [cc]
 &gt;    []
 &gt;    []
 &gt;    []
 &gt; SIZE: 20
</code></pre>
<p>======================================================================</p>
<h2 id="author-69">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-68">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-72" class="slide section level1">
<h1>NAME</h1>
<p>split2020(3f) - [M_strings:TOKENS] parse a string into tokens using proposed f2023 method (LICENSE:PD)</p>
<h2 id="synopsis-72">SYNOPSIS</h2>
<p>TOKEN form</p>
<pre><code>   subroutine split2020 (string, set, tokens, separator)
   character(len=*),intent(in) :: string
   character(len=*),intent(in) :: set
   character(len=:),allocatable,intent(out) :: tokens(:)
   character(len=1),allocatable,intent(out),optional :: separator(:)
</code></pre>
<p>BOUNDS ARRAY form</p>
<pre><code>   subroutine split2020 (string, set, first, last)
   character(len=*),intent(in) :: string
   character(len=*),intent(in) :: set
   integer,allocatable,intent(out) :: first(:)
   integer,allocatable,intent(out) :: last(:)
</code></pre>
<p>STEP THROUGH BY POSITION form</p>
<pre><code>   subroutine split2020 (string, set, pos [, back])
   character(len=*),intent(in) :: string
   character(len=*),intent(in) :: set
   integer,intent(inout)       :: pos
   logical,intent(in),optional :: back
</code></pre>
<h2 id="description-72">DESCRIPTION</h2>
<p>Parse a string into tokens. STRING, SET, TOKENS and SEPARATOR must all be of the same CHARACTER kind type parameter.</p>
<h2 id="options-57">OPTIONS</h2>
<ul>
<li><p><strong>STRING</strong><br />
string to break into tokens</p></li>
<li><p><strong>SET</strong><br />
Each character in SET is a token delimiter. A sequence of zero or more characters in STRING delimited by any token delimiter, or the beginning or end of STRING, comprise a token. Thus, two consecutive token delimiters in STRING, or a token delimiter in the first or last character of STRING, indicate a token with zero length.</p>
<p>??? how about if null defaults to all whitespace characters</p></li>
<li><p><strong>TOKENS</strong><br />
It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in STRING, and with character length equal to the length of the longest token. The tokens in STRING are assigned by intrinsic assignment, in the order found, to the elements of TOKENS, in array element order.</p>
<p>???If input is null it still must be of size 1?</p></li>
<li><p><strong>SEPARATOR</strong><br />
Each element in SEPARATOR(i) is assigned the value of the ith token delimiter in STRING. It is allocated with the lower bound equal to one and the upper bound equal to one less than the number of tokens in STRING, and with character length equal to one.</p>
<p>???one less than? '' ' '</p></li>
<li><p><strong>FIRST</strong><br />
It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in STRING. Each element is assigned, in array element order, the starting position of each token in STRING, in the order found. If a token has zero length, the starting position is equal to one if the token is at the beginning of STRING, and one greater than the position of the preceding delimiter otherwise.</p></li>
<li><p><strong>LAST</strong><br />
It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in STRING. Each element is assigned, in array element order, the ending position of each token in STRING, in the order found. If a token has zero length, the ending position is one less than the starting position.</p></li>
<li><p><strong>POS</strong><br />
If BACK is present with the value .TRUE., the value</p>
<ul>
<li><p><strong>of POS shall be in the range 0 &lt; POS</strong><br />
LEN (STRING)+1;</p></li>
<li><p><strong>otherwise it shall be in the range 0</strong><br />
POS LEN (STRING).</p></li>
</ul>
<p>If BACK is absent or is present with the value .FALSE., POS is assigned the position of the leftmost token delimiter in STRING whose position is greater than POS, or if there is no such character, it is assigned a value one greater than the length of STRING. This identifies a token with starting position one greater than the value of POS on invocation, and ending position one less than the value of POS on return.</p>
<p>If BACK is present with the value true, POS is assigned the position of the rightmost token delimiter in STRING whose position is less than POS, or if there is no such character, it is assigned the value zero. This identifies a token with ending position one less than the value of POS on invocation, and starting position one greater than the value of POS on return.</p>
<p>When SPLIT is invoked with a value for POS of 1 &lt;= POS &lt;= LEN(STRING) and STRING(POS:POS) is not a token delimiter present in SET, the token identified by SPLIT does not comprise a complete token as described in the description of the SET argument, but rather a partial token.</p></li>
<li><p><strong>BACK</strong><br />
shall be a logical scalar. It is an INTENT (IN) argument. If POS does not appear and BACK is present with the value true, STRING is scanned backwards for tokens starting from the end. If POS does not appear and BACK is absent or present with the value false, STRING is scanned forwards for tokens starting from the beginning.</p></li>
</ul>
<h2 id="examples-72">EXAMPLES</h2>
<p>Sample of uses</p>
<pre><code>   program demo_sort2020
   use M_strings, only : split2020
   implicit none
   character(len=*),parameter :: gen=&#39;(*(&quot;[&quot;,g0,&quot;]&quot;:,&quot;,&quot;))&#39;

    ! Execution of TOKEN form
    block
      character (len=:), allocatable :: string
      character (len=:), allocatable :: tokens(:)
      character (len=*),parameter :: set = &quot; ,&quot;
      string = &#39;first,second,third&#39;
      call split2020(string, set, tokens )
      write(*,gen)tokens

    ! assigns the value [&#39;first &#39;,&#39;second&#39;,&#39;third &#39; ]
    ! to TOKENS.
    endblock

    ! Execution of BOUNDS form

    block
      character (len=:), allocatable :: string
      character (len=*),parameter :: set = &quot; ,&quot;
      integer, allocatable        :: first(:), last(:)
      string =    &#39;first,second,,forth&#39;
      call split2020 (string, set, first, last)
      write(*,gen)first
      write(*,gen)last

    ! will assign the value [ 1, 7, 14, 15 ] to FIRST,
    ! and the value [ 5, 12, 13, 19 ] to LAST.
    endblock

    ! Execution of STEP form
    block
      character (len=:), allocatable :: string
      character (len=*),parameter :: set = &quot; ,&quot;
      integer :: p, ibegin, iend
      string = &quot; one,   last  example  &quot;
      do while (p &lt; len(string))
        ibegin = p + 1
        call split2020 (string, set, p)
        iend=p-1
        if(iend &gt; ibegin)then
           print &#39;(t3,a,1x,i0,1x,i0)&#39;, string (ibegin:iend),ibegin,iend
        endif
      enddo
    endblock
   end program demo_sort2020
</code></pre>
<p>Results:</p>
<pre><code>   [first ],[second],[third ]
   [1],[7],[14],[15]
   [5],[12],[13],[19]
     one 2 4
     last 9 12
     example 15 21

     &gt; ??? option to skip adjacent delimiters (not return null tokens)
     &gt;     common with whitespace
     &gt; ??? quoted strings, especially CSV both &quot; and &#39;, Fortran adjacent
     &gt;     is insert versus other rules
     &gt; ??? escape character like \\ .
     &gt; ??? multi-character delimiters like \\n, \\t,
     &gt; ??? regular expression separator
</code></pre>
<h2 id="author-70">AUTHOR</h2>
<p>Milan Curcic, "<a href="mailto:milancurcic@hey.com">milancurcic@hey.com</a>"</p>
<h2 id="license-69">LICENSE</h2>
<h3 id="mit-1">MIT</h3>
<h2 id="version-1">VERSION</h2>
<p>version 0.1.0, copyright 2020, Milan Curcic</p>
</div>
<div id="name-73" class="slide section level1">
<h1>NAME</h1>
<p>split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters (LICENSE:PD)</p>
<h2 id="synopsis-73">SYNOPSIS</h2>
<p>subroutine split(input_line,array,delimiters,order,nulls)</p>
<pre><code>    character(len=*),intent(in)              :: input_line
    character(len=:),allocatable,intent(out) :: array(:)
    character(len=*),optional,intent(in)     :: delimiters
    character(len=*),optional,intent(in)     :: order
    character(len=*),optional,intent(in)     :: nulls
</code></pre>
<h2 id="description-73">DESCRIPTION</h2>
<p>SPLIT(3f) parses a string using specified delimiter characters and store tokens into an allocatable array</p>
<h2 id="options-58">OPTIONS</h2>
<ul>
<li><p><strong>INPUT_LINE</strong><br />
Input string to tokenize</p></li>
<li><p><strong>ARRAY</strong><br />
Output array of tokens</p></li>
<li><p><strong>DELIMITERS</strong><br />
List of delimiter characters. The default delimiters are the "whitespace" characters (space, tab,new line, vertical tab, formfeed, carriage return, and null). You may specify an alternate set of delimiter characters.</p>
<p>Multi-character delimiters are not supported (Each character in the DELIMITERS list is considered to be a delimiter).</p>
<p>Quoting of delimiter characters is not supported.</p></li>
<li><p><strong>ORDER SEQUENTIAL|REVERSE|RIGHT</strong><br />
Order of output array. By default ARRAY contains the tokens having parsed the INPUT_LINE from left to right. If ORDER='RIGHT' or ORDER='REVERSE' the parsing goes from right to left. (This can be accomplished with array syntax in modern Fortran, but was more useful pre-fortran90).</p></li>
<li><p><strong>NULLS=IGNORE|RETURN|IGNOREEND</strong><br />
Treatment of null fields. By default adjacent delimiters in the input string do not create an empty string in the output array. if NULLS='return' adjacent delimiters create an empty element in the output ARRAY. If NULLS='ignoreend' then only trailing delimiters at the right of the string are ignored.</p></li>
</ul>
<h2 id="examples-73">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_split
   use M_strings, only: split
   implicit none
   integer :: i
   character(len=*),parameter :: title=&#39;(80(&quot;=&quot;),t1,a)&#39;
   character(len=*),parameter     :: line=&amp;
   &#39;  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    &#39;
   character(len=:),allocatable :: array(:) ! output array of tokens
      write(*,*)&#39;INPUT LINE:[&#39;//line//&#39;]&#39;
      !
      write(*,title)&#39;typical call: &#39;
      call split(line,array)
      call printme()
      !
      write(*,title)&#39;custom delimiters=&quot;:|&quot; : &#39;
      call split(line,array,delimiters=&#39;:|&#39;,&amp;
      &amp; order=&#39;sequential&#39;,nulls=&#39;ignore&#39;)
      call printme()
      !
      write(*,title)&amp;
      &#39;delimiters=&quot;:|&quot;,reverse array order and count null fields:&#39;
      call split(line,array,delimiters=&#39;:|&#39;,&amp;
      &amp; order=&#39;reverse&#39;,nulls=&#39;return&#39;)
      call printme()
      !
      write(*,title)&amp;
      &#39;default delimiters, reverse array order and return null fields:&#39;
      call split(line,array,delimiters=&#39;&#39;,&amp;
      &amp; order=&#39;reverse&#39;,nulls=&#39;return&#39;)
      call printme()
   contains
   subroutine printme()
      write(*,&#39;(i0,&quot; ==&gt; &quot;,a)&#39;)(i,trim(array(i)),i=1,size(array))
      write(*,*)&#39;SIZE:&#39;,size(array)
   end subroutine printme
   end program demo_split
</code></pre>
<p>Results:</p>
<pre><code> &gt; INPUT LINE:
 &gt; [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
 &gt; typical call: ========================================================
 &gt; 1 ==&gt; aBcdef
 &gt; 2 ==&gt; ghijklmnop
 &gt; 3 ==&gt; qrstuvwxyz
 &gt; 4 ==&gt; 1:|:2
 &gt; 5 ==&gt; 333|333
 &gt; 6 ==&gt; a
 &gt; 7 ==&gt; B
 &gt; 8 ==&gt; cc
 &gt;  SIZE:           8
 &gt; custom delimiters=&quot;:|&quot; : =============================================
 &gt; 1 ==&gt;   aBcdef   ghijklmnop qrstuvwxyz  1
 &gt; 2 ==&gt; 2     333
 &gt; 3 ==&gt; 333 a B cc
 &gt;  SIZE:           3
 &gt; delimiters=&quot;:|&quot;,reverse array order and count null fields:============
 &gt; 1 ==&gt; 333 a B cc
 &gt; 2 ==&gt; 2     333
 &gt; 3 ==&gt;
 &gt; 4 ==&gt;
 &gt; 5 ==&gt;   aBcdef   ghijklmnop qrstuvwxyz  1
 &gt;  SIZE:           5
 &gt; default delimiters, reverse array order and return null fields:=======
 &gt; 1 ==&gt;
 &gt; 2 ==&gt;
 &gt; 3 ==&gt;
 &gt; 4 ==&gt; cc
 &gt; 5 ==&gt; B
 &gt; 6 ==&gt; a
 &gt; 7 ==&gt; 333|333
 &gt; 8 ==&gt;
 &gt; 9 ==&gt;
 &gt; 10 ==&gt;
 &gt; 11 ==&gt;
 &gt; 12 ==&gt; 1:|:2
 &gt; 13 ==&gt;
 &gt; 14 ==&gt; qrstuvwxyz
 &gt; 15 ==&gt; ghijklmnop
 &gt; 16 ==&gt;
 &gt; 17 ==&gt;
 &gt; 18 ==&gt; aBcdef
 &gt; 19 ==&gt;
 &gt; 20 ==&gt;
 &gt;  SIZE:          20
</code></pre>
<h2 id="author-71">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-70">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-74" class="slide section level1">
<h1>NAME</h1>
<p>squeeze(3f) - [M_strings:EDITING] delete adjacent duplicate occurrences of a character from a string (LICENSE:PD)</p>
<h2 id="synopsis-74">SYNOPSIS</h2>
<p>function squeeze(STR,CHAR) result (OUTSTR)</p>
<pre><code>    character(len=*),intent(in)          :: STR
    character(len=*),intent(in),optional :: CHAR
    character(len=len(str))              :: OUTSTR
</code></pre>
<h2 id="description-74">DESCRIPTION</h2>
<p>squeeze(3f) reduces adjacent duplicates of the specified character to a single character</p>
<h2 id="options-59">OPTIONS</h2>
<ul>
<li><p><strong>STR</strong><br />
input string in which to reduce adjacent duplicate characters to a single character</p></li>
<li><p><strong>CHAR</strong><br />
The character to remove adjacent duplicates of</p></li>
</ul>
<h2 id="returns-48">RETURNS</h2>
<ul>
<li><strong>OUTSTR</strong><br />
string with all contiguous adjacent occurrences of CHAR removed</li>
</ul>
<h2 id="examples-74">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_squeeze
   use M_strings, only : squeeze
   implicit none
   character(len=:),allocatable :: strings(:)

   strings=[ character(len=72) :: &amp;
   &amp;&#39;&#39;, &amp;
   &amp;&#39;&quot;If I were two-faced,&amp;
   &amp;would I be wearing this one?&quot; --- Abraham Lincoln&#39;,  &amp;
   &amp;&#39;..1111111111111111111&amp;
   &amp;111111111111111111111111111111111111111111117777888&#39;, &amp;
   &amp;&#39;I never give &#39;&#39;em hell,&amp;
   &amp;I just tell the truth, and they think it&#39;&#39;s hell.&#39;,&amp;
   &amp;&#39;                                                  &amp;
   &amp; --- Harry S Truman&#39;    &amp;
   &amp;]
      call printme( trim(strings(1)), &#39; &#39; )
      call printme( strings(2:4),     [&#39;-&#39;,&#39;7&#39;,&#39;.&#39;] )
      call printme( strings(5),       [&#39; &#39;,&#39;-&#39;,&#39;r&#39;] )
   contains
   impure elemental subroutine printme(str,chr)
   character(len=*),intent(in) :: str
   character(len=1),intent(in) :: chr
   character(len=:),allocatable :: answer
      write(*,&#39;(a)&#39;)repeat(&#39;=&#39;,11)
      write(*,&#39;(&quot;IN:   &lt;&lt;&lt;&quot;,g0,&quot;&gt;&gt;&gt;&quot;)&#39;)str
      answer=squeeze(str,chr)
      write(*,&#39;(&quot;OUT:  &lt;&lt;&lt;&quot;,g0,&quot;&gt;&gt;&gt;&quot;)&#39;)answer
      write(*,&#39;(&quot;LENS: &quot;,*(g0,1x))&#39;)&quot;from&quot;,len(str),&quot;to&quot;,len(answer), &amp;
              &amp; &quot;for a change of&quot;,len(str)-len(answer)
      write(*,&#39;(&quot;CHAR: &quot;,g0)&#39;)chr
   end subroutine printme
   end program demo_squeeze
</code></pre>
<h2 id="author-72">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-71">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-75" class="slide section level1">
<h1>NAME</h1>
<p>stretch(3f) - [M_strings:LENGTH] return string padded to at least specified length (LICENSE:PD)</p>
<h2 id="synopsis-75">SYNOPSIS</h2>
<p>function stretch(str,length,pattern,suffix) result(strout)</p>
<pre><code>    character(len=*),intent(in)         :: str
    integer,intent(in)                  :: length
    character(len=*)intent(in),optional :: pattern
    character(len=*)intent(in),optional :: suffix
    character(len=:),allocatable        :: strout
</code></pre>
<h2 id="description-75">DESCRIPTION</h2>
<p>stretch(3f) pads a string with spaces to at least the specified length. If the trimmed input string is longer than the requested length the original string is returned trimmed of trailing spaces.</p>
<h2 id="options-60">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
the input string to return trimmed, but then padded to the specified length if shorter than length</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return</p></li>
<li><p><strong>pattern</strong><br />
optional string to use as padding. Defaults to a space.</p></li>
<li><p><strong>suffix</strong><br />
optional string to append to output string</p></li>
</ul>
<h2 id="returns-49">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
The input string padded to the requested length or the trimmed input string if the input string is longer than the requested length.</li>
</ul>
<h2 id="examples-75">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>  program demo_stretch
   use M_strings, only : stretch
   implicit none
   character(len=10)            :: string=&#39;abcdefghij&#39;
   character(len=:),allocatable :: answer
   integer                      :: i
      answer=stretch(string,5)
      write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
      answer=stretch(string,20)
      write(*,&#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;) answer
      i=30
      write(*,*)
      write(*,&#39;(1x,a,i0)&#39;) &amp;
       &amp; stretch(&#39;CHAPTER 1 : The beginning &#39;,i,&#39;.&#39;), 1    ,&amp;
       &amp; stretch(&#39;CHAPTER 2 : The end &#39;,i,&#39;.&#39;),       1234 ,&amp;
       &amp; stretch(&#39;APPENDIX &#39;,i,&#39;.&#39;),                  1235
      write(*,*)
      write(*,&#39;(1x,a,i7)&#39;) &amp;
       &amp; stretch(&#39;CHAPTER 1 : The beginning &#39;,i,&#39;.&#39;), 1    ,&amp;
       &amp; stretch(&#39;CHAPTER 2 : The end &#39;,i,&#39;.&#39;),       1234 ,&amp;
       &amp; stretch(&#39;APPENDIX &#39;,i,&#39;.&#39;),                  1235
      write(*,*)
      write(*,*) &amp;
       &amp; stretch(&#39;CHAPTER 1 : The beginning &#39;,i,suffix=&#39;: &#39;), 1
      write(*,*) &amp;
       &amp; stretch(&#39;CHAPTER 2 : The end &#39;,i,suffix=&#39;: &#39;),1234
      write(*,*) &amp;
       &amp; stretch(&#39;APPENDIX &#39;,i,suffix=&#39;: &#39;),           1235
  end program demo_stretch

  Results:

   [abcdefghij]
   [abcdefghij          ]

    CHAPTER 1 : The beginning ```.1
    CHAPTER 2 : The end ```.......1234
    APPENDIX ```..................1235

    CHAPTER 1 : The beginning ```.      1
    CHAPTER 2 : The end ```.......   1234
    APPENDIX ```..................   1235

    CHAPTER 1 : The beginning     :            1
    CHAPTER 2 : The end           :         1234
    APPENDIX                      :         1235
</code></pre>
<h2 id="author-73">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-72">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-76" class="slide section level1">
<h1>NAME</h1>
<p>string_to_value(3f) - [M_strings:TYPE] subroutine returns numeric value from string (LICENSE:PD)</p>
<h2 id="synopsis-76">SYNOPSIS</h2>
<p>subroutine string_to_value(chars,valu,ierr)</p>
<pre><code>    character(len=*),intent(in)              :: chars   ! input string
    integer|real|doubleprecision,intent(out) :: valu
    integer,intent(out)                      :: ierr
</code></pre>
<h2 id="description-76">DESCRIPTION</h2>
<p>Returns a numeric value from a numeric character string.</p>
<p>Works with any g-format input, including integer, real, and exponential. If the input string begins with "B", "Z", or "O" and otherwise represents a positive whole number it is assumed to be a binary, hexadecimal, or octal value. If the string contains commas they are removed. If the string is of the form NN:MMM``` or NN#MMM then NN is assumed to be the base of the whole number.</p>
<p>If an error occurs in the READ, IOSTAT is returned in IERR and value is set to zero. if no error occurs, IERR=0.</p>
<h2 id="options-61">OPTIONS</h2>
<ul>
<li><strong>CHARS</strong><br />
input string to read numeric value from</li>
</ul>
<h2 id="returns-50">RETURNS</h2>
<ul>
<li><p><strong>VALU</strong><br />
numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.</p></li>
<li><p><strong>IERR</strong><br />
error flag (0 == no error)</p></li>
</ul>
<h2 id="examples-76">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_string_to_value
    use M_strings, only: string_to_value
    implicit none
    real :: value
    integer :: ierr
    character(len=80) :: string
       string=&#39; -40.5e-2 &#39;
       call string_to_value(string,value,ierr)
       write(*,*) &#39;value of string [&#39;//trim(string)//&#39;] is &#39;,value
   end program demo_string_to_value
</code></pre>
<h2 id="author-74">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-73">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-77" class="slide section level1">
<h1>NAME</h1>
<p>string_to_values(3f) - [M_strings:TYPE] read a string representing numbers into a numeric array (LICENSE:PD)</p>
<h2 id="synopsis-77">SYNOPSIS</h2>
<p>subroutine string_to_values(line,iread,values,inums,delims,ierr)</p>
<pre><code>       character(len=*) :: line
       integer          :: iread
       real             :: values(*)
       integer          :: inums
       character(len=*) :: delims
       integer          :: ierr
</code></pre>
<h2 id="description-77">DESCRIPTION</h2>
<p>This routine can take a string representing a series of numbers and convert it to a numeric array and return how many numbers were found.</p>
<h2 id="options-62">OPTIONS</h2>
<ul>
<li><p><strong>LINE</strong><br />
Input string containing numbers</p></li>
<li><p><strong>IREAD</strong><br />
maximum number of values to try to read from input string</p></li>
</ul>
<h2 id="returns-51">RETURNS</h2>
<ul>
<li><p><strong>VALUES</strong><br />
real array to be filled with numbers</p></li>
<li><p><strong>INUMS</strong><br />
number of values successfully read (before error occurs if one does)</p></li>
<li><p><strong>DELIMS</strong><br />
delimiter character(s), usually a space. must not be a null string. If more than one character, a space must not be the last character or it will be ignored.</p></li>
<li><p><strong>IERR</strong><br />
error flag (0=no error, else column number string starts at that error occurred on).</p></li>
</ul>
<h2 id="examples-77">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_string_to_values
      use M_strings, only : string_to_values
      implicit none
      character(len=80)  :: s=&#39; 10 20e3;3.45 -400.3e-2;1234; 5678 &#39;
      integer,parameter  :: isz=10
      real               :: array(isz)
      integer            :: inums, ierr, ii

      call string_to_values(s,10,array,inums,&#39; ;&#39;,ierr)
      call reportit()

      call string_to_values(&#39;10;2.3;3.1416&#39;,isz,array,inums,&#39; ;&#39;,ierr)
      call reportit()

      contains
         subroutine reportit()
            write(*,*)&#39;string_to_values:&#39;
            write(*,*)&#39;input string```..........&#39;,trim(s)
            write(*,*)&#39;number of values found```&#39;,inums
            write(*,*)&#39;values```................&#39;,(array(ii),ii=1,inums)
         end subroutine reportit
     end program demo_string_to_values
</code></pre>
<p>Expected output</p>
<pre><code>    string_to_values:
    input string```.......... 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found```           6
    values```................   10.0000000  20000.0000  3.45000005
    -4.00299978  1234.00000  5678.00000
    string_to_values:
    input string```.......... 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found```           3
    values```................   10.0000000  2.29999995  3.14159989
</code></pre>
<h2 id="author-75">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-74">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-78" class="slide section level1">
<h1>NAME</h1>
<p>strtok(3f) - [M_strings:TOKENS] Tokenize a string (LICENSE:PD)</p>
<h2 id="synopsis-78">SYNOPSIS</h2>
<p>function strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)</p>
<pre><code>  ! returned value
  logical                      :: strtok_status
  ! string to tokenize
  character(len=*),intent(in)  :: source_string
  ! token count since started
  integer,intent(inout)        :: itoken
  ! beginning of token
  integer,intent(out)          :: token_start
  ! end of token
  integer,intent(inout)        :: token_end
  ! list of separator characters
  character(len=*),intent(in)  :: delimiters
</code></pre>
<h2 id="description-78">DESCRIPTION</h2>
<p>The STRTOK(3f) function is used to isolate sequential tokens in a string, SOURCE_STRING. These tokens are delimited in the string by at least one of the characters in DELIMITERS. The first time that STRTOK(3f) is called, ITOKEN should be specified as zero. Subsequent calls, wishing to obtain further tokens from the same string,</p>
<ul>
<li><strong>should pass back in TOKEN_END</strong><br />
and ITOKEN until the function result returns .false.</li>
</ul>
<p>This routine assumes no other calls are made to it using any other input string while it is processing an input line.</p>
<h2 id="options-63">OPTIONS</h2>
<ul>
<li><p><strong>source_string</strong><br />
input string to parse</p></li>
<li><p><strong>itoken</strong><br />
token count should be set to zero for a new string</p></li>
<li><p><strong>delimiters</strong><br />
characters used to determine the end of tokens</p></li>
</ul>
<h2 id="returns-52">RETURNS</h2>
<ul>
<li><p><strong>token_start</strong><br />
beginning position in SOURCE_STRING where token was found</p></li>
<li><p><strong>token_end</strong><br />
ending position in SOURCE_STRING where token was found strtok_status</p></li>
</ul>
<h2 id="examples-78">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_strtok
    use M_strings, only : strtok
    implicit none
    character(len=264)          :: inline
    character(len=*),parameter  :: delimiters=&#39; ;,&#39;
    integer                     :: ios, itoken, ibegin, iend
       do ! read lines from stdin until end-of-file or error
          read (unit=*,fmt=&quot;(a)&quot;,iostat=ios) inline
          if(ios /= 0)stop
          ! must set ITOKEN=0 before looping on strtok(3f)
          ! on a new string.
          itoken=0
          do while &amp;
          &amp;( strtok(inline,itoken,ibegin,iend,delimiters) )
             print *, itoken,&amp;
             &amp; &#39;TOKEN=[&#39;//(inline(ibegin:iend))//&#39;]&#39;,ibegin,iend
          enddo
       enddo
    end program demo_strtok

    sample input file

     this is a test of strtok; A:B :;,C;;

    sample output file

    1  TOKEN=[this]    2   5
    2  TOKEN=[is]      7   8
    3  TOKEN=[a]       10  10
    4  TOKEN=[test]    12  15
    5  TOKEN=[of]      17  18
    6  TOKEN=[strtok]  20  25
    7  TOKEN=[A:B]     28  30
    8  TOKEN=[:]       32  32
    9  TOKEN=[C]       35  35
</code></pre>
<h2 id="author-76">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-75">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-79" class="slide section level1">
<h1>NAME</h1>
<p>substitute(3f) - [M_strings:EDITING] subroutine globally substitutes one substring for another in string (LICENSE:PD)</p>
<h2 id="synopsis-79">SYNOPSIS</h2>
<p>subroutine substitute(targetline,old,new,ierr,start,end)</p>
<pre><code>    character(len=*)              :: targetline
    character(len=*),intent(in)   :: old
    character(len=*),intent(in)   :: new
    integer,intent(out),optional  :: ierr
    integer,intent(in),optional   :: start
    integer,intent(in),optional   :: end
</code></pre>
<h2 id="description-79">DESCRIPTION</h2>
<p>Globally substitute one substring for another in string.</p>
<h2 id="options-64">OPTIONS</h2>
<ul>
<li><p><strong>TARGETLINE</strong><br />
input line to be changed. Must be long enough to hold altered output.</p></li>
<li><p><strong>OLD</strong><br />
substring to find and replace</p></li>
<li><p><strong>NEW</strong><br />
replacement for OLD substring</p></li>
<li><p><strong>IERR</strong><br />
error code. If IER = <strong>-1</strong> bad directive, &gt;= 0 then count of changes made.</p></li>
<li><p><strong>START</strong><br />
sets the left margin to be scanned for OLD in TARGETLINE.</p></li>
<li><p><strong>END</strong><br />
sets the right margin to be scanned for OLD in TARGETLINE.</p></li>
</ul>
<h2 id="examples-79">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_substitute
   use M_strings, only : substitute
   implicit none
   ! must be long enough to hold changed line
   character(len=80) :: targetline

   targetline=&#39;this is the input string&#39;
   write(*,*)&#39;ORIGINAL    : &#39;//trim(targetline)

   ! changes the input to &#39;THis is THe input string&#39;
   call substitute(targetline,&#39;th&#39;,&#39;TH&#39;)
   write(*,*)&#39;th =&gt; TH    : &#39;//trim(targetline)

   ! a null old substring means &quot;at beginning of line&quot;
   ! changes the input to &#39;BEFORE:this is the input string&#39;
   call substitute(targetline,&#39;&#39;,&#39;BEFORE:&#39;)
   write(*,*)&#39;&quot;&quot; =&gt; BEFORE: &#39;//trim(targetline)

   ! a null new string deletes occurrences of the old substring
   ! changes the input to &#39;ths s the nput strng&#39;
   call substitute(targetline,&#39;i&#39;,&#39;&#39;)
   write(*,*)&#39;i =&gt; &quot;&quot;     : &#39;//trim(targetline)

   end program demo_substitute
</code></pre>
<p>Expected output</p>
<pre><code>    ORIGINAL    : this is the input string
    th =&gt; TH    : THis is THe input string
    &quot;&quot; =&gt; BEFORE: BEFORE:THis is THe input string
    i =&gt; &quot;&quot;     : BEFORE:THs s THe nput strng
</code></pre>
<h2 id="author-77">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-76">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-80" class="slide section level1">
<h1>NAME</h1>
<p>switch(3f) - [M_strings:ARRAY] converts between CHARACTER scalar and array of single characters (LICENSE:PD)</p>
<h2 id="synopsis-80">SYNOPSIS</h2>
<p>pure function switch(array) result (string)</p>
<pre><code>    character(len=1),intent(in) :: array(:)
    character(len=SIZE(array))  :: string

     or
</code></pre>
<p>pure function switch(string) result (array)</p>
<pre><code>    character(len=*),intent(in) :: string
    character(len=1)            :: array(len(string))
</code></pre>
<h2 id="description-80">DESCRIPTION</h2>
<p>SWITCH(3f): generic function that switches CHARACTER string to an array of single characters or an array of single characters to a CHARACTER string. Useful in passing strings to C. New Fortran features may supersede these routines.</p>
<h2 id="examples-80">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_switch
   use M_strings, only : switch, isalpha, islower, nospace
   character(len=*),parameter :: &amp;
   &amp; dashes=&#39;-----------------------------------&#39;
   character(len=*),parameter :: string=&#39;This is a string&#39;
   character(len=1024)        :: line

   ! First, examples of standard Fortran features
   ! returns array [F,T,T,T,T,T]
   write(*,*)[&#39;A&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;] == &#39;=&#39;
   ! this would return T
   write(*,*)all([&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;] == &#39;=&#39;)
   ! this would return F
   write(*,*)all([&#39;A&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;,&#39;=&#39;] == &#39;=&#39;)

   ! so to test if the string DASHES is all dashes
   ! using SWITCH(3f) is
   if(all(switch(dashes) == &#39;-&#39;))then
      write(*,*)&#39;DASHES is all dashes&#39;
   endif

   ! so to test is a string is all letters
   ! isalpha(3f) returns .true. only if character is a letter
   ! false because dashes are not a letter
   write(*,*) all(isalpha(switch(dashes)))
   ! false because of spaces
   write(*,*) all(isalpha(switch(string)))
   ! true because removed whitespace
   write(*,*) all(isalpha(switch(nospace(string))))

   ! to see if a string is all uppercase
   ! show the string
   write(*,*) string
   ! converted to character array
   write(*,&#39;(1x,*(&quot;[&quot;,a,&quot;]&quot;:))&#39;) switch(string)
   write(*,&#39;(*(l3))&#39;) islower(switch(string))

   ! we need a string that is all letters
   line=nospace(string)
   write(*,*)&#39;LINE=&#39;,trim(line)
   ! all true except first character
   write(*,*) islower(switch(nospace(string)))
   ! should be false
   write(*,*) all(islower(switch(nospace(string))))
   ! should be true
   write(*,*) all(islower(switch(nospace(string(2:)))))

   end program demo_switch
</code></pre>
<p>Expected output</p>
<pre><code>    &gt; F T T T T T
    &gt; T
    &gt; F
    &gt; DASHES is all dashes
    &gt; F
    &gt; F
    &gt; T
    &gt; This is a string
    &gt; [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g]
    &gt;  F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T
    &gt; LINE=Thisisastring
    &gt; F T T T T T T T T T T T T
    &gt; F
    &gt; T
</code></pre>
<h2 id="author-78">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-77">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-81" class="slide section level1">
<h1>NAME</h1>
<p>transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set (LICENSE:PD)</p>
<h2 id="synopsis-81">SYNOPSIS</h2>
<p>pure function transliterate(instr,old_set,new_set) result(outstr)</p>
<pre><code>    character(len=*),intent(in)  :: instr
    character(len=*),intent(in)  :: old_set
    character(len=*),intent(in)  :: new_set
    character(len=len(instr))    :: outstr
</code></pre>
<h2 id="description-81">DESCRIPTION</h2>
<p>Translate, squeeze, and/or delete characters from the input string.</p>
<h2 id="options-65">OPTIONS</h2>
<ul>
<li><p><strong>instr</strong><br />
input string to change</p></li>
<li><p><strong>old_set</strong><br />
list of letters to change in INSTR if found</p></li>
</ul>
<!-- end list -->

<pre><code>            Each character in the input string that matches a character
            in the old set is replaced.
</code></pre>
<ul>
<li><strong>new_set</strong><br />
list of letters to replace letters in OLD_SET with.</li>
</ul>
<!-- end list -->

<pre><code>            If the new_set is the empty set the matched characters
            are deleted.

            If the new_set is shorter than the old set the last character
            in the new set is used to replace the remaining characters
            in the new set.
</code></pre>
<h2 id="returns-53">RETURNS</h2>
<ul>
<li><strong>outstr</strong><br />
instr with substitutions applied</li>
</ul>
<h2 id="examples-81">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_transliterate

    use M_strings, only : transliterate
    implicit none
    character(len=80)   :: STRING

    STRING=&#39;aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ&#39;
    write(*,&#39;(a)&#39;) STRING

    ! convert a string to uppercase:
    write(*,*) TRANSLITERATE(STRING, &amp;
    &amp; &#39;abcdefghijklmnopqrstuvwxyz&#39;,&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;)

    ! change all miniscule letters to a colon (&quot;:&quot;):
    write(*,*) TRANSLITERATE(STRING, &amp;
    &amp; &#39;abcdefghijklmnopqrstuvwxyz&#39;,&#39;:&#39;)

    ! delete all miniscule letters
    write(*,*) TRANSLITERATE(STRING, &amp;
    &amp; &#39;abcdefghijklmnopqrstuvwxyz&#39;,&#39;&#39;)

   end program demo_transliterate

   Expected output

    &gt; aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
    &gt; AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
    &gt; :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
    &gt; ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre>
<h2 id="author-79">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-78">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-82" class="slide section level1">
<h1>NAME</h1>
<p>unquote(3f) - [M_strings:QUOTES] remove quotes from string as if read with list-directed input (LICENSE:PD)</p>
<h2 id="synopsis-82">SYNOPSIS</h2>
<p>function unquote(quoted_str,esc) result (unquoted_str)</p>
<pre><code>   character(len=*),intent(in)          :: quoted_str
   character(len=1),optional,intent(in) :: esc
   character(len=:),allocatable         :: unquoted_str
</code></pre>
<h2 id="description-82">DESCRIPTION</h2>
<p>Remove quotes from a CHARACTER variable as if it was read using list-directed input. This is particularly useful for processing tokens read from input such as CSV files.</p>
<p>Fortran can now read using list-directed input from an internal file, which should handle quoted strings, but list-directed input does not support escape characters, which UNQUOTE(3f) does.</p>
<h2 id="options-66">OPTIONS</h2>
<ul>
<li><p><strong>quoted_str</strong><br />
input string to remove quotes from, using the rules of list-directed input (two adjacent quotes inside a quoted region are replaced by a single quote, a single quote or double quote is selected as the delimiter based on which is encountered first going from left to right, ```)</p></li>
<li><p><strong>esc</strong><br />
optional character used to protect the next quote character from being processed as a quote, but simply as a plain character.</p></li>
</ul>
<h2 id="returns-54">RETURNS</h2>
<ul>
<li><strong>unquoted_str</strong><br />
The output string, which is based on removing quotes from quoted_str.</li>
</ul>
<h2 id="examples-82">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>   program demo_unquote
      use M_strings, only : unquote
      implicit none
      character(len=128)           :: quoted_str
      character(len=:),allocatable :: unquoted_str
      character(len=1),parameter   :: esc=&#39;\&#39;
      character(len=1024)          :: msg
      integer                      :: ios
      character(len=1024)          :: dummy
      do
         write(*,&#39;(a)&#39;,advance=&#39;no&#39;)&#39;Enter test string:&#39;
         read(*,&#39;(a)&#39;,iostat=ios,iomsg=msg)quoted_str
         if(ios /= 0)then
            write(*,*)trim(msg)
            exit
         endif

         ! the original string
         write(*,&#39;(a)&#39;)&#39;QUOTED       [&#39;//trim(quoted_str)//&#39;]&#39;

         ! the string processed by unquote(3f)
         unquoted_str=unquote(trim(quoted_str),esc)
         write(*,&#39;(a)&#39;)&#39;UNQUOTED     [&#39;//unquoted_str//&#39;]&#39;

         ! read the string list-directed to compare the results
         read(quoted_str,*,iostat=ios,iomsg=msg)dummy
         if(ios /= 0)then
            write(*,*)trim(msg)
         else
            write(*,&#39;(a)&#39;)&#39;LIST DIRECTED[&#39;//trim(dummy)//&#39;]&#39;
         endif
      enddo
   end program demo_unquote
</code></pre>
<h2 id="author-80">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-79">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-83" class="slide section level1">
<h1>NAME</h1>
<p>upper(3f) - [M_strings:CASE] changes a string to uppercase (LICENSE:PD)</p>
<h2 id="synopsis-83">SYNOPSIS</h2>
<p>elemental pure function upper(str,begin,end) result (string)</p>
<pre><code>    character(*), intent(in)    :: str
    integer,optional,intent(in) :: begin,end
    character(len(str))         :: string  ! output string
</code></pre>
<h2 id="description-83">DESCRIPTION</h2>
<p>upper(string) returns a copy of the input string with all characters converted in the optionally specified range to uppercase, assuming ASCII character sets are being used. If no range is specified the entire string is converted to uppercase.</p>
<h2 id="options-67">OPTIONS</h2>
<ul>
<li><p><strong>str</strong><br />
string to convert to uppercase</p></li>
<li><p><strong>begin</strong><br />
optional starting position in "str" to begin converting to uppercase</p></li>
<li><p><strong>end</strong><br />
optional ending position in "str" to stop converting to uppercase</p></li>
</ul>
<h2 id="returns-55">RETURNS</h2>
<ul>
<li><strong>upper</strong><br />
copy of the input string with all characters converted to uppercase over optionally specified range.</li>
</ul>
<h2 id="trivia-1">TRIVIA</h2>
<p>The terms "uppercase" and "lowercase" date back to the early days of the mechanical printing press. Individual metal alloy casts of each needed letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were stored and organized in wooden cases. The more often needed miniscule letters were placed closer to hand, in the lower cases of the work bench. The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.</p>
<h2 id="examples-83">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_upper
    use M_strings, only: upper
    implicit none
    character(len=:),allocatable  :: s
       s=&#39; ABCDEFG abcdefg &#39;
       write(*,*) &#39;mixed-case input string is ```.&#39;,s
       write(*,*) &#39;upper-case output string is ```&#39;,upper(s)
       write(*,*) &#39;make first character uppercase  ``` &#39;,&amp;
       &amp; upper(&#39;this is a sentence.&#39;,1,1)
       write(*,&#39;(1x,a,*(a:,&quot;+&quot;))&#39;) &#39;UPPER(3f) is elemental ==&gt;&#39;,&amp;
       &amp; upper([&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;])
    end program demo_upper
</code></pre>
<p>Expected output</p>
<pre><code>    mixed-case input string is ```. ABCDEFG abcdefg
    upper-case output string is ``` ABCDEFG ABCDEFG
    make first character uppercase  ``` This is a sentence.
    UPPER(3f) is elemental ==&gt;ABC+DEF+GHI
</code></pre>
<h2 id="author-81">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-80">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-84" class="slide section level1">
<h1>NAME</h1>
<p>upper_quoted(3f) - [M_strings:CASE] elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules (LICENSE:PD)</p>
<h2 id="synopsis-84">SYNOPSIS</h2>
<p>elemental pure function upper_quoted(str) result (string)</p>
<pre><code>    character(*), intent(in)    :: str
    character(len(str))         :: string  ! output string
</code></pre>
<h2 id="description-84">DESCRIPTION</h2>
<p>upper_quoted(string) returns a copy of the input string with all not-quoted characters converted to uppercase, assuming ASCII character sets are being used. The quoting rules are the same as for Fortran source. Either a single or double quote starts a quoted string, and a quote character of the same type is doubled when it appears internally in the quoted string. If a double quote quotes the string single quotes may appear in the quoted string as single characters, and vice-versa for single quotes.</p>
<h2 id="options-68">OPTIONS</h2>
<ul>
<li><strong>str</strong><br />
string to convert to uppercase</li>
</ul>
<h2 id="returns-56">RETURNS</h2>
<ul>
<li><strong>upper</strong><br />
copy of the input string with all unquoted characters converted to uppercase</li>
</ul>
<h2 id="examples-84">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>    program demo_upper_quoted
    use M_strings, only: upper_quoted
    implicit none
    character(len=:),allocatable  :: s
    s=&#39; ABCDEFG abcdefg &quot;Double-Quoted&quot; &#39;&#39;Single-Quoted&#39;&#39; &quot;with &quot;&quot;&amp;
       &amp; Quote&quot; everything else&#39;
       write(*,*) &#39;mixed-case input string is ```.&#39;,s
       write(*,*) &#39;upper-case output string is ```&#39;,upper_quoted(s)
       write(*,&#39;(1x,a,*(a:,&quot;+&quot;))&#39;) &#39;upper_quoted(3f) is elemental ==&gt;&#39;, &amp;
       &amp; upper_quoted([&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;])
    end program demo_upper_quoted
</code></pre>
<p>Expected output:</p>
<pre><code>    mixed-case input string is ```. ABCDEFG abcdefg &quot;Double-Quoted&quot;
    &#39;Single-Quoted&#39; &quot;with &quot;&quot; Quote&quot; everything else
    upper-case output string is ``` ABCDEFG ABCDEFG &quot;Double-Quoted&quot;
    &#39;Single-Quoted&#39; &quot;with &quot;&quot; Quote&quot; EVERYTHING ELSE
    upper_quoted(3f) is elemental ==&gt;ABC+DEF+GHI
</code></pre>
<h2 id="author-82">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-81">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-85" class="slide section level1">
<h1>NAME</h1>
<p>v2s(3f) - [M_strings:TYPE] return numeric string from a numeric value (LICENSE:PD)</p>
<h2 id="synopsis-85">SYNOPSIS</h2>
<p>function v2s(value) result(outstr)</p>
<pre><code>       integer|real|doubleprecision|logical,intent(in ) :: value
       character(len=:),allocatable :: outstr
       character(len=*),optional,intent(in) :: fmt
</code></pre>
<h2 id="description-85">DESCRIPTION</h2>
<p>v2s(3f) returns a representation of a numeric value as a string when given a numeric value of type REAL, DOUBLEPRECISION, INTEGER or LOGICAL. It creates the strings using internal WRITE() statements. Trailing zeros are removed from non-zero values, and the string is left-justified.</p>
<h2 id="options-69">OPTIONS</h2>
<ul>
<li><p><strong>VALUE</strong><br />
input value to be converted to a string</p></li>
<li><p><strong>FMT</strong><br />
format can be explicitly given, but is limited to generating a string of eighty or less characters.</p></li>
</ul>
<h2 id="returns-57">RETURNS</h2>
<ul>
<li><strong>OUTSTR</strong><br />
returned string representing input value,</li>
</ul>
<h2 id="examples-85">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>   program demo_v2s
   use M_strings, only: v2s
   write(*,*) &#39;The value of 3.0/4.0 is [&#39;//v2s(3.0/4.0)//&#39;]&#39;
   write(*,*) &#39;The value of 1234    is [&#39;//v2s(1234)//&#39;]&#39;
   write(*,*) &#39;The value of 0d0     is [&#39;//v2s(0d0)//&#39;]&#39;
   write(*,*) &#39;The value of .false. is [&#39;//v2s(.false.)//&#39;]&#39;
   write(*,*) &#39;The value of .true. is  [&#39;//v2s(.true.)//&#39;]&#39;
   end program demo_v2s
</code></pre>
<p>Expected output</p>
<pre><code>    The value of 3.0/4.0 is [0.75]
    The value of 1234    is [1234]
    The value of 0d0     is [0]
    The value of .false. is [F]
    The value of .true. is  [T]
</code></pre>
<h2 id="author-83">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-82">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-86" class="slide section level1">
<h1>NAME</h1>
<p>value_to_string(3f) - [M_strings:TYPE] return numeric string from a numeric value (LICENSE:PD)</p>
<h2 id="synopsis-86">SYNOPSIS</h2>
<p>subroutine value_to_string(value,chars[,lgth,ierr,fmt,trimz])</p>
<pre><code>    character(len=*) :: chars  ! minimum of 23 characters required
    !--------
    ! VALUE may be any &lt;em&gt;one&lt;/em&gt; of the following types:
    doubleprecision,intent(in)               :: value
    real,intent(in)                          :: value
    integer,intent(in)                       :: value
    logical,intent(in)                       :: value
    !--------
    character(len=*),intent(out)             :: chars
    integer,intent(out),optional             :: lgth
    integer,optional                         :: ierr
    character(len=*),intent(in),optional     :: fmt
    logical,intent(in)                       :: trimz
</code></pre>
<h2 id="description-86">DESCRIPTION</h2>
<p>value_to_string(3f) returns a numeric representation of a numeric value in a string given a numeric value of type REAL, DOUBLEPRECISION, INTEGER or LOGICAL. It creates the string using internal writes. It then removes trailing zeros from non-zero values, and left-justifies the string.</p>
<h2 id="options-70">OPTIONS</h2>
<ul>
<li><p><strong>VALUE</strong><br />
input value to be converted to a string</p></li>
<li><p><strong>FMT</strong><br />
You may specify a specific format that produces a string up to the length of CHARS; optional.</p></li>
<li><p><strong>TRIMZ</strong><br />
If a format is supplied the default is not to try to trim trailing zeros. Set TRIMZ to .true. to trim zeros from a string assumed to represent a simple numeric value.</p></li>
</ul>
<h2 id="returns-58">RETURNS</h2>
<ul>
<li><p><strong>CHARS</strong><br />
returned string representing input value, must be at least 23 characters long; or what is required by optional FMT if longer.</p></li>
<li><p><strong>LGTH</strong><br />
position of last non-blank character in returned string; optional.</p></li>
<li><p><strong>IERR</strong><br />
If not zero, error occurred; optional.</p></li>
</ul>
<h2 id="examples-86">EXAMPLES</h2>
<p>Sample program:</p>
<pre><code>     program demo_value_to_string
     use M_strings, only: value_to_string
     implicit none
     character(len=80) :: string
     integer           :: lgth
        call value_to_string(3.0/4.0,string,lgth)
        write(*,*) &#39;The value is [&#39;,string(:lgth),&#39;]&#39;

        call value_to_string(3.0/4.0,string,lgth,fmt=&#39;&#39;)
        write(*,*) &#39;The value is [&#39;,string(:lgth),&#39;]&#39;

        call value_to_string&amp;
        &amp;(3.0/4.0,string,lgth,fmt=&#39;(&quot;THE VALUE IS &quot;,g0)&#39;)
        write(*,*) &#39;The value is [&#39;,string(:lgth),&#39;]&#39;

        call value_to_string(1234,string,lgth)
        write(*,*) &#39;The value is [&#39;,string(:lgth),&#39;]&#39;

        call value_to_string(1.0d0/3.0d0,string,lgth)
        write(*,*) &#39;The value is [&#39;,string(:lgth),&#39;]&#39;

     end program demo_value_to_string
</code></pre>
<p>Expected output</p>
<pre><code>    The value is [0.75]
    The value is [      0.7500000000]
    The value is [THE VALUE IS .750000000]
    The value is [1234]
    The value is [0.33333333333333331]
</code></pre>
<h2 id="author-84">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-83">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-87" class="slide section level1">
<h1>NAME</h1>
<p>visible(3f) - [M_strings:NONALPHA] expand a string to control and meta-control representations (LICENSE:PD)</p>
<h2 id="synopsis-87">SYNOPSIS</h2>
<p>function visible(input) result(output)</p>
<pre><code>    character(len=*),intent(in)           :: input
    character(len=:),allocatable          :: output
</code></pre>
<h2 id="description-87">DESCRIPTION</h2>
<p>visible(3f) expands characters to commonly used sequences used to represent the characters as control sequences or meta-control sequences.</p>
<h2 id="examples-87">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>    program demo_visible
    use M_strings, only : visible
    integer :: i
       do i=0,255
          write(*,&#39;(i0,1x,a)&#39;)i,visible(char(i))
       enddo
    end program demo_visible
</code></pre>
<h2 id="bugs">BUGS</h2>
<p>The expansion is not reversible, as input sequences such as "M-" or "^a" will look like expanded sequences.</p>
<h2 id="author-85">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-84">LICENSE</h2>
<p>Public Domain</p>
</div>
<div id="name-88" class="slide section level1">
<h1>NAME</h1>
<p>zpad(3f) - [M_strings:LENGTH] pad a string on the left with zeros to specified length (LICENSE:PD)</p>
<h2 id="synopsis-88">SYNOPSIS</h2>
<p>function zpad(valuein,length) result(strout)</p>
<pre><code>    class*,intent(in)           :: valuein(..)
    integer,intent(in),optional :: length
</code></pre>
<h2 id="description-88">DESCRIPTION</h2>
<p>zpad(3f) crops the input string (or integer, which will be converted to a string) and then pads it on the left with zeros to the specified length.</p>
<p>Note that if the trimmed input string is already as long or longer than the requested length the trimmed original string is returned.</p>
<p>For strings representing unsigned numbers this is basically an alias for</p>
<pre><code>       strout=pad(str,length,&#39;0&#39;,clip=.true.,right=.false.)
</code></pre>
<p>For integers the same is often done with internal WRITE(3f) statements such as</p>
<pre><code>       write(strout,&#39;(i5.5)&#39;)ivalue
</code></pre>
<p>but unlike internal I/O the function call can be used in expressions or passed as a procedure argument.</p>
<h2 id="options-71">OPTIONS</h2>
<ul>
<li><p><strong>valuein</strong><br />
The input value to left-pad. May be a scalar or vector string or integer. If the leftmost non-blank character is a sign character it is moved to the left-most position of the output.</p></li>
<li><p><strong>length</strong><br />
The minimum string length to return. If not present, the length of the input parameter VALUEIN is used. If the input value VALUEIN is an integer no zero padding occurs if LENGTH is not supplied.</p></li>
</ul>
<h2 id="returns-59">RETURNS</h2>
<ul>
<li><strong>strout</strong><br />
A trimmed string padded on the left with zeros to the requested length</li>
</ul>
<h2 id="examples-88">EXAMPLES</h2>
<p>Sample Program:</p>
<pre><code>     program demo_zpad
      use M_strings, only : zpad
      implicit none
      character(len=*),parameter :: boxed=&#39;(&quot;[&quot;,a,&quot;]&quot;,*(g0,1x))&#39;
      integer :: lun, i
         print boxed, zpad( &#39;111&#39;, 5),&#39;basic use&#39;
         print boxed, zpad( valuein=42 , length=7),&#39;by argument name&#39;
         print boxed, zpad( &#39;  34567  &#39;, 7),&#39;cropped before padding&#39;
         print boxed, zpad( &#39;123456789&#39;, 5),&#39;input longer than length&#39;
         print boxed, zpad( &#39;  +34567  &#39;, 7),&#39;starts with plus sign&#39;
         print boxed, zpad( &#39;  -34567  &#39;, 7),&#39;starts with minus sign&#39;
         print boxed, zpad(1234),&#39;some integers instead of strings&#39;
         print boxed, zpad(-1234)
         print boxed, zpad(1234,8)
         print boxed, zpad(-1234,8)
         print boxed, zpad(&#39;&#39;),&#39;a null gets you nothing&#39;
         print boxed, zpad(&#39;0&#39;),&#39;but blanks are used for default length&#39;
         print boxed, zpad(&#39;0    &#39;)
         print boxed, zpad(&#39;     &#39;)
         print *, &#39;input value may be an array:&#39;
         print &#39;(&quot;[&quot;,a,&quot;]&quot;)&#39;, zpad([1,10,100,1000,10000,100000],8)

         ! example usage:
         ! open output_00085.dat
         i=85
         open(newunit=lun,file=&#39;output_&#39;//zpad(i,5)//&#39;.dat&#39;)
         close(unit=lun,status=&#39;delete&#39;)

     end program demo_zpad
</code></pre>
<p>Results:</p>
<pre><code>    &gt; [00111]basic use
    &gt; [0000042]by argument name
    &gt; [0034567]cropped before padding
    &gt; [123456789]input longer than length
    &gt; [+0034567]starts with plus sign
    &gt; [-0034567]starts with minus sign
    &gt; [1234]some integers instead of strings
    &gt; [-1234]
    &gt; [00001234]
    &gt; [-00001234]
    &gt; []a null gets you nothing
    &gt; [0]but blanks are used for default length
    &gt; [00000]
    &gt; [00000]
    &gt;  input value may be an array:
    &gt; [00000001]
    &gt; [00000010]
    &gt; [00000100]
    &gt; [00001000]
    &gt; [00010000]
    &gt; [00100000]
</code></pre>
<h2 id="author-86">AUTHOR</h2>
<p>John S. Urban</p>
<h2 id="license-85">LICENSE</h2>
<p>Public Domain</p>
</div>
</body>
</html>
