var tipuesearch = {"pages":[{"title":" M_strings ","text":"M_strings M_strings.f90 and associated files NAME M_strings and M_strings_oops - Fortran modules for processing strings DESCRIPTION The M_strings (3fm) module is a collection of Fortran procedures that\nsupplement the built-in intrinsic string routines.  Routines for parsing\ntokenizing, changing case, substituting new strings for substrings\nlocating strings with simple wildcard expressions, removing tabs and\nline terminators as well as other string manipulations are included. M_strings_oop (3fm) is a companion module that provides an OOP interface\nto the M_strings module. SYNOPSIS public entities: use M_strings, only : split , sep , delim , chomp , strtok use M_strings, only : split2020 , find_field use M_strings, only : substitute , change , modif , transliterate , reverse , squeeze use M_strings, only : replace , join use M_strings, only : upper , lower , upper_quoted use M_strings, only : rotate13 use M_strings, only : adjustc , compact , nospace , indent use M_strings, only : crop , clip , unquote , quote , matching_delimiter use M_strings, only : len_white , pad , lpad , cpad , rpad , zpad , stretch , lenset , merge_str use M_strings, only : switch , s2c , c2s use M_strings, only : noesc , notabs , dilate , expand , visible use M_strings, only : longest_common_substring use M_strings, only : string_to_value , string_to_values , s2v , s2vs use M_strings, only : value_to_string , v2s , msg use M_strings, only : listout , getvals use M_strings, only : glob , ends_with use M_strings, only : paragraph use M_strings, only : base , decodebase , codebase , base2 use M_strings, only : isalnum , isalpha , iscntrl , isdigit use M_strings, only : isgraph , islower , isprint , ispunct use M_strings, only : isspace , isupper , isascii , isblank , isxdigit use M_strings, only : isnumber use M_strings, only : fortran_name use M_strings, only : describe use M_strings, only : edit_distance use M_strings, only : cc use M_strings, only : int , real , dble , nint INTRINSICS The M_strings(3fm) module supplements and works in combination with\nthe Fortran built-in intrinsics. Standard Fortran lets you access the\ncharacters in a string using ranges much like they are character arrays\nassignment, comparisons with standard operators, supports dynamically\nallocatable strings and supports concatenation using the // operator: adjustl Left adjust a string adjustr Right adjust a string index Position of a substring within a string repeat Repeated string concatenation scan Scan a string for the presence of a set of characters trim Remove trailing blank characters of a string verify Scan a string for the absence of a set of characters len It returns the length of a character string achar converts an integer into a character iachar converts a character into an integer len_trim finds length of string with trailing spaces ignored new_line Newline character selected_char_kind Choose character kind lge Lexical greater than or equal lgt Lexical greater than lle Lexical less than or equal llt Lexical less than DOWNLOAD and BUILD with make(1) Just download the github repository, enter the src/ directory and run make: git clone https : // github . com / urbanjost / M_strings . git cd M_strings / src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # for nvfortran make clean make F90 = nvfortran nvfortran # optionally make test # run the unit tests make run # run all the demo programs from the man - pages make help # see other developer options This will compile the M_strings(3f) module and optionally build all the\nexample programs from the document pages in the example/ sub-directory\nand run the unit tests. DOWNLOAD AND BUILD WITH FPM(1) Alternatively, download the github repository and build it with\nfpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/M_strings.git cd M_strings\n     fpm build\n     fpm test # run unit tests or just list it as a dependency in your fpm.toml project file. [dependencies] M_strings = { git = \"https://github.com/urbanjost/M_strings.git\" , tag = \"v1.0.1\" } Note that M_strings.f90 is registered at the fpm(1) registry DOCUMENTATION USER In addition to a markdown document with links to\n   some of the most commonly used procedures, there are HTML documents for each\n   subprogram in the style of man-pages: An index to the HTML versions\n   of the man-pages. A single page (that uses javascript) combining all the HTML descriptions of the man-pages\n   for easy searching and printing: BOOK_M_strings . man-page archives for use on GNU/Linux, Unix and CygWin platforms: manpages.zip manpages.tgz CHANGELOG provides a history of significant changes DEVELOPER ( experimental ) The code was run through ford(1) to produce a developers’ document . github action status DEMO PROGRAMS Each man-page includes a working example program. These and additional\nexamples are included in the example/ directory. Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"string – M_strings ","text":"type, public :: string Contents Variables str Constructor string Type-Bound Procedures adjustc adjustl adjustr chars compact cpad crop dble expand index init int len len_trim lenset lower lpad match noesc notabs operator(*) operator(+) operator(-) operator(//) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) pad real reverse rpad substitute transliterate trim upper zpad Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Constructor public        interface string private  function construct_from_fill(chars, len) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: chars integer, intent(in), optional :: len Return Value type( string ) Type-Bound Procedures procedure, public :: adjustc => oop_adjustc private  function oop_adjustc(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in), optional :: length Return Value type( string ) procedure, public :: adjustl => oop_adjustl private  function oop_adjustl(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: adjustr => oop_adjustr private  function oop_adjustr(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: chars => oop_switch private  function oop_switch(self) result(array) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(len=1), (len(self%str)) procedure, public :: compact => oop_compact private  function oop_compact(self, char) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), optional :: char Return Value type( string ) procedure, public :: cpad => oop_cpad private  function oop_cpad(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string ) procedure, public :: crop => oop_crop private  function oop_crop(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: dble => oop_dble private  function oop_dble(self) result(value) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value doubleprecision procedure, public :: expand => oop_expand private  function oop_expand(self, escape_char) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character, intent(in), optional :: escape_char Return Value type( string ) procedure, public :: index => oop_index private  function oop_index(self, substring, back) result(location) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer procedure, public :: init => init_string private  subroutine init_string(self) Arguments Type Intent Optional Attributes Name class( string ) :: self procedure, public :: int => oop_int private  function oop_int(self) result(value) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer procedure, public :: len => oop_len private  function oop_len(self) result(length) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer procedure, public :: len_trim => oop_len_trim private  function oop_len_trim(self) result(length) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value integer procedure, public :: lenset => oop_lenset private  function oop_lenset(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string ) procedure, public :: lower => oop_lower private  function oop_lower(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: lpad => oop_lpad private  function oop_lpad(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string ) procedure, public :: match => oop_matchw private  function oop_matchw(self, pattern) result(answer) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: pattern Return Value logical procedure, public :: noesc => oop_noesc private  function oop_noesc(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: notabs => oop_notabs private  function oop_notabs(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) generic, public :: operator(*) => string_multiply_value private  function string_multiply_value(self, value) result(other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self class(*), intent(in) :: value Return Value type( string ) generic, public :: operator(+) => string_plus_value private  function string_plus_value(self, value) result(other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self class(*), intent(in) :: value Return Value type( string ) generic, public :: operator(-) => string_minus_value private  function string_minus_value(self, value) result(other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self class(*), intent(in) :: value Return Value type( string ) generic, public :: operator(//) => string_append_value private  function string_append_value(self, value) result(other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self class(*), intent(in) :: value Return Value type( string ) generic, public :: operator(/=) => ne private  function ne(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical generic, public :: operator(<) => lt private  function lt(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical generic, public :: operator(<=) => le private  function le(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical generic, public :: operator(==) => eq private  function eq(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical generic, public :: operator(>) => gt private  function gt(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical generic, public :: operator(>=) => ge private  function ge(self, other) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self type( string ), intent(in) :: other Return Value logical procedure, public :: pad => oop_pad private  function oop_pad(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string ) procedure, public :: real => oop_real private  function oop_real(self) result(value) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value real procedure, public :: reverse => oop_reverse private  function oop_reverse(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: rpad => oop_rpad private  function oop_rpad(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string ) procedure, public :: substitute => oop_substitute private  function oop_substitute(self, old, new) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: old character(len=*), intent(in) :: new Return Value type( string ) procedure, public :: transliterate => oop_transliterate private  function oop_transliterate(self, old, new) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self character(len=*), intent(in) :: old character(len=*), intent(in) :: new Return Value type( string ) procedure, public :: trim => oop_trim private  function oop_trim(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: upper => oop_upper private  function oop_upper(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value type( string ) procedure, public :: zpad => oop_zpad private  function oop_zpad(self, length) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self integer, intent(in) :: length Return Value type( string )","tags":"","loc":"type/string.html"},{"title":"adjustc – M_strings","text":"public pure function adjustc(string, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: length Return Value character(len=:), allocatable Contents Source Code adjustc Source Code pure function adjustc ( string , length ) character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen <= 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft > 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc","tags":"","loc":"proc/adjustc.html"},{"title":"base – M_strings","text":"public  function base(x, b, y, a) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x integer, intent(in) :: b character(len=*), intent(out) :: y integer, intent(in) :: a Return Value logical Contents Source Code base Source Code logical function base ( x , b , y , a ) implicit none character ( len =* ), intent ( in ) :: x character ( len =* ), intent ( out ) :: y integer , intent ( in ) :: b , a integer :: temp base = . true . if ( decodebase ( x , b , temp )) then if ( codebase ( temp , a , y )) then else print * , 'Error in coding number.' base = . false . endif else print * , 'Error in decoding number.' base = . false . endif end function base","tags":"","loc":"proc/base.html"},{"title":"base2 – M_strings","text":"public  function base2(x) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=max) Contents Source Code base2 Source Code function base2 ( x ) result ( str ) integer , intent ( in ) :: x integer :: i character ( len = max ( 1 , bit_size ( x ) - leadz ( x ))) :: str associate ( n => len ( str )) str = repeat ( '0' , n ) do i = 0 , n - 1 if ( btest ( x , i )) str ( n - i : n - i ) = '1' end do end associate end function base2","tags":"","loc":"proc/base2.html"},{"title":"bundle – M_strings","text":"public  function bundle(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, len) result(vec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x1 character(len=*), intent(in), optional :: x2 character(len=*), intent(in), optional :: x3 character(len=*), intent(in), optional :: x4 character(len=*), intent(in), optional :: x5 character(len=*), intent(in), optional :: x6 character(len=*), intent(in), optional :: x7 character(len=*), intent(in), optional :: x8 character(len=*), intent(in), optional :: x9 character(len=*), intent(in), optional :: x10 character(len=*), intent(in), optional :: x11 character(len=*), intent(in), optional :: x12 character(len=*), intent(in), optional :: x13 character(len=*), intent(in), optional :: x14 character(len=*), intent(in), optional :: x15 character(len=*), intent(in), optional :: x16 character(len=*), intent(in), optional :: x17 character(len=*), intent(in), optional :: x18 character(len=*), intent(in), optional :: x19 character(len=*), intent(in), optional :: x20 integer, intent(in), optional :: len Return Value character(len=:), allocatable, (:) Contents Source Code bundle Source Code function bundle ( x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 , x11 , x12 , x13 , x14 , x15 , x16 , x17 , x18 , x19 , x20 , len ) result ( vec ) character ( len =* ), intent ( in ), optional :: x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 character ( len =* ), intent ( in ), optional :: x11 , x12 , x13 , x14 , x15 , x16 , x17 , x18 , x19 , x20 integer , intent ( in ), optional :: len character ( len = :), allocatable :: vec (:) integer :: ilen , icount , iset ilen = 0 icount = 0 iset = 0 call increment ( x1 ) call increment ( x2 ) call increment ( x3 ) call increment ( x4 ) call increment ( x5 ) call increment ( x6 ) call increment ( x7 ) call increment ( x8 ) call increment ( x9 ) call increment ( x10 ) call increment ( x11 ) call increment ( x12 ) call increment ( x13 ) call increment ( x14 ) call increment ( x15 ) call increment ( x16 ) call increment ( x17 ) call increment ( x18 ) call increment ( x19 ) call increment ( x20 ) if ( present ( len )) ilen = len allocate ( character ( len = ilen ) :: vec ( icount )) call set ( x1 ) call set ( x2 ) call set ( x3 ) call set ( x4 ) call set ( x5 ) call set ( x6 ) call set ( x7 ) call set ( x8 ) call set ( x9 ) call set ( x10 ) call set ( x11 ) call set ( x12 ) call set ( x13 ) call set ( x14 ) call set ( x15 ) call set ( x16 ) call set ( x17 ) call set ( x18 ) call set ( x19 ) call set ( x20 ) contains subroutine increment ( str ) character ( len =* ), intent ( in ), optional :: str if ( present ( str )) then ilen = max ( ilen , len_trim ( str )) icount = icount + 1 endif end subroutine increment subroutine set ( str ) character ( len =* ), intent ( in ), optional :: str if ( present ( str )) then iset = iset + 1 vec ( iset ) = str endif end subroutine set end function bundle","tags":"","loc":"proc/bundle.html"},{"title":"c2s – M_strings","text":"public  function c2s(c_string_pointer) result(f_string) Uses iso_c_binding Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: c_string_pointer Return Value character(len=:), allocatable Contents Source Code c2s Source Code function c2s ( c_string_pointer ) result ( f_string ) use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer , c_char , c_null_char integer , parameter :: max_length = 4096 type ( c_ptr ), intent ( in ) :: c_string_pointer character ( len = :), allocatable :: f_string character ( kind = c_char ), dimension (:), pointer :: char_array_pointer => null () character ( len = max_length ) :: aux_string integer :: i , length = 0 call c_f_pointer ( c_string_pointer , char_array_pointer ,[ max_length ]) if (. not . associated ( char_array_pointer )) then allocate ( character ( len = 4 ) :: f_string ) f_string = \"NULL\" return endif aux_string = \" \" do i = 1 , max_length if ( char_array_pointer ( i ) == c_null_char ) then length = i - 1 exit endif aux_string ( i : i ) = char_array_pointer ( i ) enddo allocate ( character ( len = length ) :: f_string ) f_string = aux_string ( 1 : length ) end function c2s","tags":"","loc":"proc/c2s.html"},{"title":"chomp – M_strings","text":"public  function chomp(source_string, token, delimiters) Arguments Type Intent Optional Attributes Name character(len=*) :: source_string character(len=:), intent(out), allocatable :: token character(len=*), intent(in), optional :: delimiters Return Value integer Contents Source Code chomp Source Code FUNCTION chomp ( source_string , token , delimiters ) character ( len =* ) :: source_string ! string to tokenize character ( len = :), allocatable , intent ( out ) :: token ! returned token character ( len =* ), intent ( in ), optional :: delimiters ! list of separator characters integer :: chomp ! returns copy of shifted source_string character ( len = :), allocatable :: delimiters_local integer :: token_start ! beginning of token found if function result is .true. integer :: token_end ! end of token found if function result is .true. integer :: isource_len if ( present ( delimiters )) then delimiters_local = delimiters else ! increment start to previous end + 1 delimiters_local = char ( 32 ) // char ( 09 ) // char ( 10 ) // char ( 13 ) ! space,horizontal tab, newline, carriage return endif isource_len = len ( source_string ) ! length of input string ! find beginning of token token_start = 1 do while ( token_start <= isource_len ) ! step thru each character to find next delimiter, if any if ( index ( delimiters_local , source_string ( token_start : token_start )) /= 0 ) then token_start = token_start + 1 else exit endif enddo token_end = token_start do while ( token_end <= isource_len - 1 ) ! step thru each character to find next delimiter, if any if ( index ( delimiters_local , source_string ( token_end + 1 : token_end + 1 )) /= 0 ) then ! found a delimiter in next character exit endif token_end = token_end + 1 enddo !write(*,*)'TOKEN_START ',token_start !write(*,*)'TOKEN_END   ',token_end chomp = isource_len - token_end if ( chomp >= 0 ) then token = source_string ( token_start : token_end ) source_string = source_string ( token_end + 1 :) else token = '' source_string = '' endif end function chomp","tags":"","loc":"proc/chomp.html"},{"title":"clip – M_strings","text":"public  function clip(string) result(lopped) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Contents Source Code clip Source Code function clip ( string ) result ( lopped ) logical , parameter :: T = . true ., F = . false . character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: lopped integer :: ends ( 2 ) ends = verify ( string , \" \" , [ F , T ] ) if ( ends ( 1 ) == 0 ) then lopped = \"\" else lopped = string ( ends ( 1 ): ends ( 2 )) endif end function clip","tags":"","loc":"proc/clip.html"},{"title":"codebase – M_strings","text":"public  function codebase(inval10, outbase, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inval10 integer, intent(in) :: outbase character(len=*), intent(out) :: answer Return Value logical Contents Source Code codebase Source Code logical function codebase ( inval10 , outbase , answer ) implicit none integer , intent ( in ) :: inval10 integer , intent ( in ) :: outbase character ( len =* ), intent ( out ) :: answer integer :: n real :: inval10_local integer :: outbase_local integer :: in_sign answer = '' in_sign = sign ( 1 , inval10 ) * sign ( 1 , outbase ) inval10_local = abs ( inval10 ) outbase_local = abs ( outbase ) if ( outbase_local < 2. or . outbase_local > 36 ) then print * , '*codebase* ERROR: base must be between 2 and 36. base was' , outbase_local codebase = . false . else do while ( inval10_local > 0.0 ) n = INT ( inval10_local - outbase_local * INT ( inval10_local / outbase_local )) if ( n < 10 ) then answer = ACHAR ( IACHAR ( '0' ) + n ) // answer else answer = ACHAR ( IACHAR ( 'A' ) + n - 10 ) // answer endif inval10_local = INT ( inval10_local / outbase_local ) enddo codebase = . true . endif if ( in_sign == - 1 ) then answer = '-' // trim ( answer ) endif if ( answer == '' ) then answer = '0' endif end function codebase","tags":"","loc":"proc/codebase.html"},{"title":"compact – M_strings","text":"public  function compact(str, char) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) Contents Source Code compact Source Code function compact ( str , char ) result ( outstr ) character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ) == 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( iachar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output == 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select enddo IFSPACE end function compact","tags":"","loc":"proc/compact.html"},{"title":"cpad – M_strings","text":"public  function cpad(valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable Contents Source Code cpad Source Code function cpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )); line = valuein class default stop '<ERROR>*cpad* unknown type' end select strout = adjustc ( crop ( line ), length ) end function cpad","tags":"","loc":"proc/cpad.html"},{"title":"crop – M_strings","text":"public  function crop(strin) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin Return Value character(len=:), allocatable Contents Source Code crop Source Code function crop ( strin ) result ( strout ) character ( len =* ), intent ( in ) :: strin character ( len = :), allocatable :: strout strout = trim ( adjustl ( noesc ( dilate ( strin )))) end function crop","tags":"","loc":"proc/crop.html"},{"title":"decodebase – M_strings","text":"public  function decodebase(string, basein, out_baseten) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: basein integer, intent(out) :: out_baseten Return Value logical Contents Source Code decodebase Source Code logical function decodebase ( string , basein , out_baseten ) implicit none character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: basein integer , intent ( out ) :: out_baseten character ( len = len ( string )) :: string_local integer :: long , i , j , k real :: y real :: mult character ( len = 1 ) :: ch real , parameter :: XMAXREAL = real ( huge ( 1 )) integer :: out_sign integer :: basein_local integer :: ipound integer :: ierr string_local = upper ( trim ( adjustl ( string ))) decodebase = . false . ipound = index ( string_local , '#' ) ! determine if in form [-]base#whole if ( basein == 0. and . ipound > 1 ) then ! split string into two values call string_to_value ( string_local (: ipound - 1 ), basein_local , ierr ) ! get the decimal value of the base string_local = string_local ( ipound + 1 :) ! now that base is known make string just the value if ( basein_local >= 0 ) then ! allow for a negative sign prefix out_sign = 1 else out_sign =- 1 endif basein_local = abs ( basein_local ) else ! assume string is a simple positive value basein_local = abs ( basein ) out_sign = 1 endif out_baseten = 0 y = 0.0 ALL : if ( basein_local < 2. or . basein_local > 36 ) then print * , '(*decodebase* ERROR: Base must be between 2 and 36. base=' , basein_local else ALL out_baseten = 0 ; y = 0.0 ; mult = 1.0 long = LEN_TRIM ( string_local ) do i = 1 , long k = long + 1 - i ch = string_local ( k : k ) if ( ch == '-' . and . k == 1 ) then out_sign =- 1 cycle endif if ( ch < '0' . or . ch > 'Z' . or .( ch > '9' . and . ch < 'A' )) then write ( * , * ) '*decodebase* ERROR: invalid character ' , ch exit ALL endif if ( ch <= '9' ) then j = IACHAR ( ch ) - IACHAR ( '0' ) else j = IACHAR ( ch ) - IACHAR ( 'A' ) + 10 endif if ( j >= basein_local ) then exit ALL endif y = y + mult * j if ( mult > XMAXREAL / basein_local ) then exit ALL endif mult = mult * basein_local enddo decodebase = . true . out_baseten = nint ( out_sign * y ) * sign ( 1 , basein ) endif ALL end function decodebase","tags":"","loc":"proc/decodebase.html"},{"title":"describe – M_strings","text":"public  function describe(ch) result(string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ch Return Value character(len=:), allocatable Contents Source Code describe Source Code function describe ( ch ) result ( string ) character ( len = 1 ), intent ( in ) :: ch character ( len = :), allocatable :: string select case ( iachar ( ch )) case ( 0 ); STRING = \"ctrl-@ or ctrl-? (NUL) null\" case ( 1 ); STRING = \"ctrl-A (SOH) start of heading\" case ( 2 ); STRING = \"ctrl-B (STX) start of text\" case ( 3 ); STRING = \"ctrl-C (ETX) end of text\" case ( 4 ); STRING = \"ctrl-D (EOT) end of transmission\" case ( 5 ); STRING = \"ctrl-E (ENQ) enquiry\" case ( 6 ); STRING = \"ctrl-F (ACK) acknowledge\" case ( 7 ); STRING = \"ctrl-G (BEL) bell\" case ( 8 ); STRING = \"ctrl-H (BS) backspace\" case ( 9 ); STRING = \"ctrl-I (HT) horizontal tabulation\" case ( 10 ); STRING = \"ctrl-J (LF) line feed\" case ( 11 ); STRING = \"ctrl-K (VT) vertical tabulation\" case ( 12 ); STRING = \"ctrl-L (FF) form feed\" case ( 13 ); STRING = \"ctrl-M (CR) carriage return\" case ( 14 ); STRING = \"ctrl-N (SO) shift out\" case ( 15 ); STRING = \"ctrl-O (SI) shift in\" case ( 16 ); STRING = \"ctrl-P (DLE) data link escape\" case ( 17 ); STRING = \"ctrl-Q (DC1) device control 1\" case ( 18 ); STRING = \"ctrl-R (DC2) device control 2\" case ( 19 ); STRING = \"ctrl-S (DC3) device control 3\" case ( 20 ); STRING = \"ctrl-T (DC4) device control 4\" case ( 21 ); STRING = \"ctrl-U (NAK) negative acknowledge\" case ( 22 ); STRING = \"ctrl-V (SYN) synchronous idle\" case ( 23 ); STRING = \"ctrl-W (ETB) end of transmission block\" case ( 24 ); STRING = \"ctrl-X (CAN) cancel\" case ( 25 ); STRING = \"ctrl-Y (EM) end of medium\" case ( 26 ); STRING = \"ctrl-Z (SUB) substitute\" case ( 27 ); STRING = \"ctrl-[ (ESC) escape\" case ( 28 ); STRING = \"ctrl-\\ or ctrl-@ (FS) file separator\" case ( 29 ); STRING = \"ctrl-] (GS) group separator\" case ( 30 ); STRING = \"ctrl-&#94; or ctrl-= (RS) record separator\" case ( 31 ); STRING = \"ctrl-_ (US) unit separator\" case ( 32 ); STRING = \"space\" case ( 33 ); STRING = \"! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)\" case ( 34 ); STRING = \"\"\" quotation marks\" case ( 35 ); STRING = \"# number sign (hash, pound sign, hashtag)\" case ( 36 ); STRING = \"$ currency symbol\" case ( 37 ); STRING = \"% percent\" case ( 38 ); STRING = \"& ampersand\" case ( 39 ); STRING = \"' apostrophe\" case ( 40 ); STRING = \"( left parenthesis\" case ( 41 ); STRING = \") right parenthesis\" case ( 42 ); STRING = \"* asterisk\" case ( 43 ); STRING = \"+ plus\" case ( 44 ); STRING = \", comma\" case ( 45 ); STRING = \"- minus\" case ( 46 ); STRING = \". period\" case ( 47 ); STRING = \"/ slash\" case ( 48 ); STRING = \"0 zero\" case ( 49 ); STRING = \"1 one\" case ( 50 ); STRING = \"2 two\" case ( 51 ); STRING = \"3 three\" case ( 52 ); STRING = \"4 four\" case ( 53 ); STRING = \"5 five\" case ( 54 ); STRING = \"6 six\" case ( 55 ); STRING = \"7 seven\" case ( 56 ); STRING = \"8 eight\" case ( 57 ); STRING = \"9 nine\" case ( 58 ); STRING = \": colon\" case ( 59 ); STRING = \"; semicolon\" case ( 60 ); STRING = \"< less than\" case ( 61 ); STRING = \"= equals\" case ( 62 ); STRING = \"> greater than\" case ( 63 ); STRING = \"? question mark\" case ( 64 ); STRING = \"@ at sign\" case ( 65 ); STRING = \"A majuscule A\" case ( 66 ); STRING = \"B majuscule B\" case ( 67 ); STRING = \"C majuscule C\" case ( 68 ); STRING = \"D majuscule D\" case ( 69 ); STRING = \"E majuscule E\" case ( 70 ); STRING = \"F majuscule F\" case ( 71 ); STRING = \"G majuscule G\" case ( 72 ); STRING = \"H majuscule H\" case ( 73 ); STRING = \"I majuscule I\" case ( 74 ); STRING = \"J majuscule J\" case ( 75 ); STRING = \"K majuscule K\" case ( 76 ); STRING = \"L majuscule L\" case ( 77 ); STRING = \"M majuscule M\" case ( 78 ); STRING = \"N majuscule N\" case ( 79 ); STRING = \"O majuscule O\" case ( 80 ); STRING = \"P majuscule P\" case ( 81 ); STRING = \"Q majuscule Q\" case ( 82 ); STRING = \"R majuscule R\" case ( 83 ); STRING = \"S majuscule S\" case ( 84 ); STRING = \"T majuscule T\" case ( 85 ); STRING = \"U majuscule U\" case ( 86 ); STRING = \"V majuscule V\" case ( 87 ); STRING = \"W majuscule W\" case ( 88 ); STRING = \"X majuscule X\" case ( 89 ); STRING = \"Y majuscule Y\" case ( 90 ); STRING = \"Z majuscule Z\" case ( 91 ); STRING = \"[ left bracket\" case ( 92 ); STRING = \"\\ backslash\" case ( 93 ); STRING = \"] right bracket\" case ( 94 ); STRING = \"&#94; caret\" case ( 95 ); STRING = \"_ underscore\" case ( 96 ); STRING = \"` grave accent\" case ( 97 ); STRING = \"a miniscule a\" case ( 98 ); STRING = \"b miniscule b\" case ( 99 ); STRING = \"c miniscule c\" case ( 100 ); STRING = \"d miniscule d\" case ( 101 ); STRING = \"e miniscule e\" case ( 102 ); STRING = \"f miniscule f\" case ( 103 ); STRING = \"g miniscule g\" case ( 104 ); STRING = \"h miniscule h\" case ( 105 ); STRING = \"i miniscule i\" case ( 106 ); STRING = \"j miniscule j\" case ( 107 ); STRING = \"k miniscule k\" case ( 108 ); STRING = \"l miniscule l\" case ( 109 ); STRING = \"m miniscule m\" case ( 110 ); STRING = \"n miniscule n\" case ( 111 ); STRING = \"o miniscule o\" case ( 112 ); STRING = \"p miniscule p\" case ( 113 ); STRING = \"q miniscule q\" case ( 114 ); STRING = \"r miniscule r\" case ( 115 ); STRING = \"s miniscule s\" case ( 116 ); STRING = \"t miniscule t\" case ( 117 ); STRING = \"u miniscule u\" case ( 118 ); STRING = \"v miniscule v\" case ( 119 ); STRING = \"w miniscule w\" case ( 120 ); STRING = \"x miniscule x\" case ( 121 ); STRING = \"y miniscule y\" case ( 122 ); STRING = \"z miniscule z\" case ( 123 ); STRING = \"{ left brace\" case ( 124 ); STRING = \"| vertical line\" case ( 125 ); STRING = \"} right brace\" case ( 126 ); STRING = \"~ tilde\" case ( 127 ); STRING = \"ctrl-? (DEL) delete\" case default STRING = 'UNKNOWN' // v2s ( IACHAR ( ch )) end select end function describe","tags":"","loc":"proc/describe.html"},{"title":"dilate – M_strings","text":"public  function dilate(instr) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr Return Value character(len=:), allocatable Contents Source Code dilate Source Code function dilate ( INSTR ) result ( OUTSTR ) CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input line to scan for tab characters CHARACTER ( LEN = :), allocatable :: outstr ! tab-expanded version of INSTR produced integer :: i integer :: icount integer :: lgth icount = 0 do i = 1 , len ( instr ) if ( instr ( i : i ) == char ( 9 )) icount = icount + 1 enddo allocate ( character ( len = ( len ( instr ) + 8 * icount )) :: outstr ) call notabs ( instr , outstr , lgth ) outstr = outstr (: lgth ) END function dilate","tags":"","loc":"proc/dilate.html"},{"title":"edit_distance – M_strings","text":"public pure elemental function edit_distance(a, b) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a character(len=*), intent(in) :: b Return Value integer Contents Source Code edit_distance Source Code pure elemental integer function edit_distance ( a , b ) character ( len =* ), intent ( in ) :: a , b integer :: len_a , len_b , i , j , cost integer , allocatable :: matrix (:,:) len_a = len_trim ( a ) len_b = len_trim ( b ) !-------------------------------------- ! required by older compilers instead of above declaration if ( allocated ( matrix )) deallocate ( matrix ) allocate ( matrix ( 0 : len_a , 0 : len_b )) !-------------------------------------- matrix (:, 0 ) = [( i , i = 0 , len_a )] matrix ( 0 ,:) = [( j , j = 0 , len_b )] do i = 1 , len_a do j = 1 , len_b cost = merge ( 0 , 1 , a ( i : i ) == b ( j : j )) matrix ( i , j ) = min ( matrix ( i - 1 , j ) + 1 , matrix ( i , j - 1 ) + 1 , matrix ( i - 1 , j - 1 ) + cost ) enddo enddo edit_distance = matrix ( len_a , len_b ) end function edit_distance","tags":"","loc":"proc/edit_distance.html"},{"title":"expand – M_strings","text":"public  function expand(line, escape) result(lineout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(in), optional :: escape Return Value character(len=:), allocatable Contents Source Code expand Source Code function expand ( line , escape ) result ( lineout ) implicit none character ( len =* ), parameter :: c_horizontal_tab = char ( 9 ) character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( in ), optional :: escape ! escape character. Default is backslash character ( len = 1 ) :: esc ! escape character. Default is % character ( len = :), allocatable :: lineout integer :: i integer :: lgth character ( len = 3 ) :: thr integer :: xxx integer :: ios i = 0 ! pointer into input lgth = len_trim ( line ) lineout = '' if ( lgth == 0 ) return if ( present ( escape )) then esc = escape else esc = char ( 92 ) endif EXP : do i = i + 1 if ( i > lgth ) exit if ( line ( i : i ) == esc ) then i = i + 1 if ( i > lgth ) exit if ( line ( i : i ) /= esc ) then BACKSLASH : select case ( line ( i : i )) case ( 'a' , 'A' , 'g' , 'G' ); lineout = lineout // char ( 7 ) ! %a     alert (BEL) case ( 'b' , 'B' ); lineout = lineout // char ( 8 ) ! %b     backspace case ( 'c' , 'C' ); exit EXP ! %c     suppress further output case ( 'd' , 'D' ) ! %d     Dnnn decimal value thr = line ( i + 1 :) read ( thr , '(i3)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 3 case ( 'e' , 'E' ); lineout = lineout // char ( 27 ) ! %e     escape case ( 'f' , 'F' ); lineout = lineout // char ( 12 ) ! %f     form feed case ( 'n' , 'N' ); lineout = lineout // char ( 10 ) ! %n     new line !case('n','N');lineout=lineout//new_line('A')     ! %n     new line case ( 'o' , 'O' ) thr = line ( i + 1 :) read ( thr , '(o3)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 3 case ( 'r' , 'R' ); lineout = lineout // char ( 13 ) ! %r     carriage return case ( 't' , 'T' ); lineout = lineout // c_horizontal_tab ! %t     horizontal tab case ( 'v' , 'V' ); lineout = lineout // char ( 11 ) ! %v     vertical tab case ( 'x' , 'X' , 'h' , 'H' ) ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits) thr = line ( i + 1 :) read ( thr , '(z2)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 2 end select BACKSLASH else lineout = lineout // esc ! escape character, defaults to backslash endif else lineout = lineout // line ( i : i ) endif if ( i >= lgth ) exit EXP enddo EXP end function expand","tags":"","loc":"proc/expand.html"},{"title":"fortran_name – M_strings","text":"public elemental function fortran_name(line) result(lout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Contents Source Code fortran_name Source Code elemental function fortran_name ( line ) result ( lout ) character ( len =* ), parameter :: int = '0123456789' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: allowed = upper // lower // int // '_' character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: name logical :: lout name = trim ( line ) if ( len ( name ) /= 0 ) then lout = verify ( name ( 1 : 1 ), lower // upper ) == 0 & & . and . verify ( name , allowed ) == 0 & & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name","tags":"","loc":"proc/fortran_name.html"},{"title":"glob – M_strings","text":"public  function glob(tame, wild) Arguments Type Intent Optional Attributes Name character(len=*) :: tame character(len=*) :: wild Return Value logical Contents Source Code glob Source Code function glob ( tame , wild ) logical :: glob character ( len =* ) :: tame ! A string without wildcards character ( len =* ) :: wild ! A (potentially) corresponding string with wildcards character ( len = len ( tame ) + 1 ) :: tametext character ( len = len ( wild ) + 1 ) :: wildtext character ( len = 1 ), parameter :: NULL = char ( 0 ) integer :: wlen integer :: ti , wi integer :: i character ( len = :), allocatable :: tbookmark , wbookmark tametext = tame // NULL wildtext = wild // NULL tbookmark = NULL wbookmark = NULL wlen = len ( wild ) wi = 1 ti = 1 do ! Walk the text strings one character at a time. if ( wildtext ( wi : wi ) == '*' ) then ! How do you match a unique text string? do i = wi , wlen ! Easy: unique up on it! if ( wildtext ( wi : wi ) == '*' ) then wi = wi + 1 else exit endif enddo if ( wildtext ( wi : wi ) == NULL ) then ! \"x\" matches \"*\" glob = . true . return endif if ( wildtext ( wi : wi ) /= '?' ) then ! Fast-forward to next possible match. do while ( tametext ( ti : ti ) /= wildtext ( wi : wi )) ti = ti + 1 if ( tametext ( ti : ti ) == NULL ) then glob = . false . return ! \"x\" doesn't match \"*y*\" endif enddo endif wbookmark = wildtext ( wi :) tbookmark = tametext ( ti :) elseif ( tametext ( ti : ti ) /= wildtext ( wi : wi ) . and . wildtext ( wi : wi ) /= '?' ) then ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry. if ( wbookmark /= NULL ) then if ( wildtext ( wi :) /= wbookmark ) then wildtext = wbookmark wlen = len_trim ( wbookmark ) wi = 1 ! Don't go this far back again. if ( tametext ( ti : ti ) /= wildtext ( wi : wi )) then tbookmark = tbookmark ( 2 :) tametext = tbookmark ti = 1 cycle ! \"xy\" matches \"*y\" else wi = wi + 1 endif endif if ( tametext ( ti : ti ) /= NULL ) then ti = ti + 1 cycle ! \"mississippi\" matches \"*sip*\" endif endif glob = . false . return ! \"xy\" doesn't match \"x\" endif ti = ti + 1 wi = wi + 1 if ( ti > len ( tametext )) then glob = . false . return elseif ( tametext ( ti : ti ) == NULL ) then ! How do you match a tame text string? if ( wildtext ( wi : wi ) /= NULL ) then do while ( wildtext ( wi : wi ) == '*' ) ! The tame way: unique up on it! wi = wi + 1 ! \"x\" matches \"x*\" if ( wildtext ( wi : wi ) == NULL ) exit enddo endif if ( wildtext ( wi : wi ) == NULL ) then glob = . true . return ! \"x\" matches \"x\" endif glob = . false . return ! \"x\" doesn't match \"xy\" endif enddo end function glob","tags":"","loc":"proc/glob.html"},{"title":"indent – M_strings","text":"public  function indent(line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Contents Source Code indent Source Code function indent ( line ) implicit none integer :: indent character ( len =* ), intent ( in ) :: line integer :: i indent = 0 NOTSPACE : block SCAN : do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' ) then indent = i - 1 exit NOTSPACE endif enddo SCAN indent = len ( line ) endblock NOTSPACE end function indent","tags":"","loc":"proc/indent.html"},{"title":"isNumber – M_strings","text":"public  function isNumber(string, msg, verbose) result(isnumber) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=:), intent(out), optional, allocatable :: msg logical, intent(in), optional :: verbose Return Value integer Contents Source Code isNumber Source Code function isNumber ( string , msg , verbose ) implicit none character ( len =* ), intent ( in ) :: string character ( len = :), intent ( out ), allocatable , optional :: msg logical , intent ( in ), optional :: verbose integer :: isnumber integer :: i , iend character ( len = 1 ), allocatable :: z (:) character ( len = :), allocatable :: message logical :: founddigit logical :: verbose_local i = 1 founddigit = . false . isnumber = 0 z = switch ( trim ( nospace ( string ))) iend = size ( z ) message = 'not a number' if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif DONE : block if ( iend == 0 ) then isnumber =- 1 ! string is null message = 'null string' exit DONE endif if ( index ( '+-' , z ( i )) /= 0 ) i = i + 1 ! skip optional leading sign if ( i > iend ) then isnumber =- 2 ! string was just a sign message = 'just a sign' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 1 ! [+-]NNNNNN message = 'integer' exit DONE endif if ( z ( i ) == '.' ) then ! a period would be OK at this point i = i + 1 endif if ( i > iend ) then ! [+-]NNNNNN. isnumber = 2 message = 'whole number' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 3 ! [+-]NNNNNN.MMMM message = 'real number' exit DONE endif if ( index ( 'eEdD' , z ( i )) /= 0 ) then i = i + 1 if ( i == 2 ) then isnumber =- 6 ! [+-]NNNNNN[.[MMMM]]e but a value must follow message = 'missing leading value before exponent' exit DONE endif endif if ( i > iend ) then isnumber =- 3 ! [+-]NNNNNN[.[MMMM]]e but a value must follow message = 'missing exponent' exit DONE endif if (. not . founddigit ) then isnumber =- 7 message = 'missing value before exponent' exit DONE endif if ( index ( '+-' , z ( i )) /= 0 ) i = i + 1 if ( i > iend ) then isnumber =- 4 ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow message = 'missing exponent after sign' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 4 ! [+-]NNNNNN.MMMMe[+-]LL message = 'value with exponent' exit DONE endif isnumber =- 5 message = 'bad number' endblock DONE if ( verbose_local ) then write ( * , * ) trim ( string ) // ' is ' // message endif if ( present ( msg )) then msg = message endif contains subroutine next () ! move to next non-digit or end of string+1 integer :: j do j = i , iend if (. not . isdigit ( z ( j ))) then exit endif founddigit = . true . if ( verbose_local ) write ( * , * ) 'I=' , i , ' J=' , j , ' Z(j)=' , z ( j ) enddo i = j if ( verbose_local ) then write ( * , * ) 'I and J=' , i if ( i <= iend ) then write ( * , * ) 'Z(I)=' , z ( i ) else write ( * , * ) '====>' endif endif end subroutine next end function isNumber","tags":"","loc":"proc/isnumber.html"},{"title":"isalnum – M_strings","text":"public elemental function isalnum(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isalnum Source Code elemental function isalnum ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'a' : 'z' , 'A' : 'Z' , '0' : '9' ) res = . true . case default res = . false . end select end function isalnum","tags":"","loc":"proc/isalnum.html"},{"title":"isalpha – M_strings","text":"public elemental function isalpha(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isalpha Source Code elemental function isalpha ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'Z' , 'a' : 'z' ) res = . true . case default res = . false . end select end function isalpha","tags":"","loc":"proc/isalpha.html"},{"title":"isascii – M_strings","text":"public elemental function isascii(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isascii Source Code elemental function isascii ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( iachar ( ch )) case ( 0 : 127 ) res = . true . case default res = . false . end select end function isascii","tags":"","loc":"proc/isascii.html"},{"title":"isblank – M_strings","text":"public elemental function isblank(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isblank Source Code elemental function isblank ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( ' ' , char ( 9 )) res = . true . case default res = . false . end select end function isblank","tags":"","loc":"proc/isblank.html"},{"title":"iscntrl – M_strings","text":"public elemental function iscntrl(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code iscntrl Source Code elemental function iscntrl ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( char ( 127 ), char ( 0 ): char ( 31 )) res = . true . case default res = . false . end select end function iscntrl","tags":"","loc":"proc/iscntrl.html"},{"title":"isdigit – M_strings","text":"public elemental function isdigit(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isdigit Source Code elemental function isdigit ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( '0' : '9' ) res = . true . case default res = . false . end select end function isdigit","tags":"","loc":"proc/isdigit.html"},{"title":"isgraph – M_strings","text":"public elemental function isgraph(onechar) Arguments Type Intent Optional Attributes Name character, intent(in) :: onechar Return Value logical Contents Source Code isgraph Source Code elemental function isgraph ( onechar ) character , intent ( in ) :: onechar logical :: isgraph select case ( iachar ( onechar )) case ( 33 : 126 ) isgraph = . TRUE . case default isgraph = . FALSE . end select end function isgraph","tags":"","loc":"proc/isgraph.html"},{"title":"islower – M_strings","text":"public elemental function islower(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code islower Source Code elemental function islower ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'a' : 'z' ) res = . true . case default res = . false . end select end function islower","tags":"","loc":"proc/islower.html"},{"title":"isprint – M_strings","text":"public elemental function isprint(onechar) Arguments Type Intent Optional Attributes Name character, intent(in) :: onechar Return Value logical Contents Source Code isprint Source Code elemental function isprint ( onechar ) character , intent ( in ) :: onechar logical :: isprint select case ( onechar ) case ( ' ' : '~' ) ; isprint = . TRUE . case default ; isprint = . FALSE . end select end function isprint","tags":"","loc":"proc/isprint.html"},{"title":"ispunct – M_strings","text":"public elemental function ispunct(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code ispunct Source Code elemental function ispunct ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( char ( 33 ): char ( 47 ), char ( 58 ): char ( 64 ), char ( 91 ): char ( 96 ), char ( 123 ): char ( 126 )) res = . true . case default res = . false . end select end function ispunct","tags":"","loc":"proc/ispunct.html"},{"title":"isspace – M_strings","text":"public elemental function isspace(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isspace Source Code elemental function isspace ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( ' ' ) ! space(32) res = . true . case ( char ( 0 )) ! null(0) res = . true . case ( char ( 9 ): char ( 13 )) ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13), res = . true . case default res = . false . end select end function isspace","tags":"","loc":"proc/isspace.html"},{"title":"isupper – M_strings","text":"public pure elemental function isupper(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isupper Source Code pure elemental function isupper ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'Z' ) res = . true . case default res = . false . end select end function isupper","tags":"","loc":"proc/isupper.html"},{"title":"isxdigit – M_strings","text":"public elemental function isxdigit(ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical Contents Source Code isxdigit Source Code elemental function isxdigit ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'F' , 'a' : 'f' , '0' : '9' ) res = . true . case default res = . false . end select end function isxdigit","tags":"","loc":"proc/isxdigit.html"},{"title":"join – M_strings","text":"public pure function join(str, sep, trm, left, right, start, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str (:) character(len=*), intent(in), optional :: sep logical, intent(in), optional :: trm character(len=*), intent(in), optional :: left character(len=*), intent(in), optional :: right character(len=*), intent(in), optional :: start character(len=*), intent(in), optional :: end Return Value character(len=:), allocatable Contents Source Code join Source Code pure function join ( str , sep , trm , left , right , start , end ) result ( string ) character ( len =* ), intent ( in ) :: str (:) character ( len =* ), intent ( in ), optional :: sep , right , left , start , end logical , intent ( in ), optional :: trm character ( len = :), allocatable :: sep_local , left_local , right_local character ( len = :), allocatable :: string logical :: trm_local integer :: i if ( present ( sep )) then ; sep_local = sep ; else ; sep_local = '' ; endif if ( present ( trm )) then ; trm_local = trm ; else ; trm_local = . true . ; endif if ( present ( left )) then ; left_local = left ; else ; left_local = '' ; endif if ( present ( right )) then ; right_local = right ; else ; right_local = '' ; endif string = '' if ( size ( str ) == 0 ) then string = string // left_local // right_local else do i = 1 , size ( str ) - 1 if ( trm_local ) then string = string // left_local // trim ( str ( i )) // right_local // sep_local else string = string // left_local // str ( i ) // right_local // sep_local endif enddo if ( trm_local ) then string = string // left_local // trim ( str ( i )) // right_local else string = string // left_local // str ( i ) // right_local endif endif if ( present ( start )) string = start // string if ( present ( end )) string = string // end end function join","tags":"","loc":"proc/join.html"},{"title":"len_white – M_strings","text":"public elemental function len_white(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer Contents Source Code len_white Source Code elemental integer function len_white ( string ) character ( len =* ), intent ( in ) :: string ! input string to determine length of integer :: i10 intrinsic len len_white = 0 do i10 = len ( string ), 1 , - 1 select case ( string ( i10 : i10 )) case ( ' ' ) ! space(32) case ( char ( 0 )) ! null(0) case ( char ( 9 ): char ( 13 )) ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13) case default len_white = i10 exit end select enddo end function len_white","tags":"","loc":"proc/len_white.html"},{"title":"lenset – M_strings","text":"public  function lenset(line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=length) Contents Source Code lenset Source Code function lenset ( line , length ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = length ) :: strout strout = line end function lenset","tags":"","loc":"proc/lenset.html"},{"title":"longest_common_substring – M_strings","text":"public  function longest_common_substring(a, b) result(match) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a character(len=*), intent(in) :: b Return Value character(len=:), allocatable Contents Source Code longest_common_substring Source Code function longest_common_substring ( a , b ) result ( match ) character ( len =* ), intent ( in ) :: a , b character ( len = :), allocatable :: match character ( len = :), allocatable :: a2 , b2 integer :: left , foundat , len_a , i if ( len ( a ) < len ( b )) then ! to reduce required comparisions look for shortest string in longest string a2 = a b2 = b else a2 = b b2 = a endif match = '' do i = 1 , len ( a2 ) - 1 len_a = len ( a2 ) do left = 1 , len_a foundat = index ( b2 , a2 ( left :)) if ( foundat /= 0. and . len ( match ) < len_a - left + 1 ) then if ( len ( a2 ( left :)) > len ( match )) then match = a2 ( left :) exit endif endif enddo if ( len ( a2 ) < len ( match )) exit a2 = a2 (: len ( a2 ) - 1 ) enddo end function longest_common_substring","tags":"","loc":"proc/longest_common_substring.html"},{"title":"lower – M_strings","text":"public pure elemental function lower(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character Contents Source Code lower Source Code elemental pure function lower ( str , begin , end ) result ( string ) character ( * ), intent ( in ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( 1 , begin ), iend ) endif if ( present ( end )) then iend = max ( 1 , min ( iend , end )) endif do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select enddo end function lower","tags":"","loc":"proc/lower.html"},{"title":"lpad – M_strings","text":"public  function lpad(valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable Contents Source Code lpad Source Code function lpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )) strout = pad ( valuein , length , ' ' , right = . false ., clip = . true .) return class default stop '<ERROR>*lpad* unknown type' end select strout = pad ( line , length , ' ' , clip = . true ., right = . false .) end function lpad","tags":"","loc":"proc/lpad.html"},{"title":"merge_str – M_strings","text":"public  function merge_str(str1, str2, expr) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: str1 character(len=*), intent(in), optional :: str2 logical, intent(in) :: expr Return Value character(len=:), allocatable Contents Source Code merge_str Source Code function merge_str ( str1 , str2 , expr ) result ( strout ) character ( len =* ), intent ( in ), optional :: str1 character ( len =* ), intent ( in ), optional :: str2 character ( len = :), allocatable :: str1_local character ( len = :), allocatable :: str2_local logical , intent ( in ) :: expr character ( len = :), allocatable :: strout integer :: big if ( present ( str2 )) then str2_local = str2 else str2_local = '' endif if ( present ( str1 )) then str1_local = str1 else str1_local = '' endif big = max ( len ( str1_local ), len ( str2_local )) ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning '' strout = trim ( merge ( lenset ( str1_local , big ), lenset ( str2_local , big ), expr )) end function merge_str","tags":"","loc":"proc/merge_str.html"},{"title":"noesc – M_strings","text":"public elemental function noesc(INSTR) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: INSTR Return Value character(len=len) Contents Source Code noesc Source Code elemental function noesc ( INSTR ) character ( len =* ), intent ( in ) :: INSTR ! string that might contain nonprintable characters character ( len = len ( instr )) :: noesc integer :: ic , i10 noesc = '' ! initialize output string do i10 = 1 , len_trim ( INSTR ( 1 : len ( INSTR ))) ic = iachar ( INSTR ( i10 : i10 )) if ( ic <= 3 1. or . ic == 127 ) then ! find characters with ADE of 0-31, 127 noesc ( I10 : I10 ) = ' ' ! replace non-printable characters with a space else noesc ( I10 : I10 ) = INSTR ( i10 : i10 ) ! copy other characters as-is from input string to output string endif enddo end function noesc","tags":"","loc":"proc/noesc.html"},{"title":"nospace – M_strings","text":"public  function nospace(line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Contents Source Code nospace Source Code function nospace ( line ) character ( len =* ), intent ( in ) :: line ! remove whitespace from this string and return it character ( len = :), allocatable :: nospace ! returned string integer :: ipos ! position to place next output character at integer :: i ! counter to increment from beginning to end of input string allocate ( nospace , mold = line ) ! initially make output line length of input line nospace (: len_trim ( nospace )) = ' ' ipos = 0 do i = 1 , len_trim ( line ) ! increment from first to last character of the input line if ( isspace ( line ( i : i ) ) ) cycle ! if a blank is encountered skip it ipos = ipos + 1 ! increment count of non-blank characters found nospace ( ipos : ipos ) = line ( i : i ) ! store non-blank character in output enddo nospace = trim ( nospace ) ! blank out unpacked part of line end function nospace","tags":"","loc":"proc/nospace.html"},{"title":"pad – M_strings","text":"public  function pad(line, length, pattern, right, clip) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value character(len=:), allocatable Contents Source Code pad Source Code function pad ( line , length , pattern , right , clip ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len =* ), intent ( in ), optional :: pattern logical , optional , intent ( in ) :: right logical , optional , intent ( in ) :: clip character ( len = :), allocatable :: strout logical :: local_right logical :: local_clip character ( len = :), allocatable :: local_pattern character ( len = :), allocatable :: local_line if ( present ( right ) ) then ; local_right = right ; else ; local_right = . true .; endif if ( present ( clip ) ) then ; local_clip = clip ; else ; local_clip = . false .; endif if ( present ( pattern ) ) then ; local_pattern = pattern ; else ; local_pattern = ' ' ; endif if ( len ( local_pattern ). eq . 0 ) then strout = line else if ( local_clip ) then local_line = trim ( adjustl ( line )) allocate ( character ( len = max ( length , len ( local_line ))) :: strout ) else local_line = line allocate ( character ( len = max ( length , len ( line ))) :: strout ) endif if ( local_right ) then strout (:) = local_line // repeat ( local_pattern , len ( strout ) / len ( local_pattern ) + 1 ) else strout (:) = repeat ( local_pattern , ceiling ( real ( len ( strout )) / len ( local_pattern ))) strout ( len ( strout ) - len ( local_line ) + 1 :) = local_line endif endif end function pad","tags":"","loc":"proc/pad.html"},{"title":"paragraph – M_strings","text":"public  function paragraph(source_string, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source_string integer, intent(in) :: length Return Value character(len=:), allocatable, (:) Contents Source Code paragraph Source Code function paragraph ( source_string , length ) character ( len =* ), intent ( in ) :: source_string integer , intent ( in ) :: length integer :: itoken integer :: istart integer :: iend character ( len =* ), parameter :: delimiters = ' ' character ( len = :), allocatable :: paragraph (:) integer :: ilines integer :: ilength integer :: iword , iword_max integer :: i do i = 1 , 2 iword_max = 0 ! length of longest token ilines = 1 ! number of output line output will go on ilength = 0 ! length of output line so far itoken = 0 ! must set ITOKEN=0 before looping on strtok(3f) on a new string. do while ( strtok ( source_string , itoken , istart , iend , delimiters ) ) iword = iend - istart + 1 iword_max = max ( iword_max , iword ) if ( iword > length ) then ! this token is longer than the desired line length so put it on a line by itself if ( ilength /= 0 ) then ilines = ilines + 1 endif if ( i == 2 ) then ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph paragraph ( ilines ) = source_string ( istart : iend ) // ' ' endif ilength = iword + 1 elseif ( ilength + iword <= length ) then ! this word will fit on current line if ( i == 2 ) then paragraph ( ilines ) = paragraph ( ilines )(: ilength ) // source_string ( istart : iend ) endif ilength = ilength + iword + 1 else ! adding this word would make line too long so start new line ilines = ilines + 1 ilength = 0 if ( i == 2 ) then paragraph ( ilines ) = paragraph ( ilines )(: ilength ) // source_string ( istart : iend ) endif ilength = iword + 1 endif enddo if ( i == 1 ) then ! determined number of lines needed so allocate output array allocate ( character ( len = max ( length , iword_max )) :: paragraph ( ilines )) paragraph = ' ' endif enddo paragraph = paragraph (: ilines ) end function paragraph","tags":"","loc":"proc/paragraph.html"},{"title":"quote – M_strings","text":"public  function quote(str, mode, clip) result(quoted_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: mode logical, intent(in), optional :: clip Return Value character(len=:), allocatable Contents Source Code quote Source Code function quote ( str , mode , clip ) result ( quoted_str ) character ( len =* ), intent ( in ) :: str ! the string to be quoted character ( len =* ), optional , intent ( in ) :: mode logical , optional , intent ( in ) :: clip character ( len = :), allocatable :: quoted_str character ( len = 1 ), parameter :: double_quote = '\"' character ( len = 20 ) :: local_mode if ( present ( clip )) then if ( clip ) then quoted_str = adjustl ( str ) else quoted_str = str endif else quoted_str = str endif local_mode = merge_str ( mode , 'DOUBLE' , present ( mode )) select case ( lower ( local_mode )) case ( 'double' ) quoted_str = double_quote // trim ( replace ( quoted_str , '\"' , '\"\"' )) // double_quote case ( 'escape' ) quoted_str = double_quote // trim ( replace ( quoted_str , '\"' , '\\\"' )) // double_quote case default call journal ( 'sc' , '*quote* ERROR: unknown quote mode ' , local_mode ) quoted_str = str end select end function quote","tags":"","loc":"proc/quote.html"},{"title":"replace – M_strings","text":"public  function replace(targetline, old, new, cmd, occurrence, repeat, ignorecase, ierr) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: targetline character(len=*), intent(in), optional :: old character(len=*), intent(in), optional :: new character(len=*), intent(in), optional :: cmd integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: ierr Return Value character(len=:), allocatable Contents Source Code replace Source Code function replace ( targetline , old , new , cmd , occurrence , repeat , ignorecase , ierr ) result ( newline ) character ( len =* ), intent ( in ) :: targetline ! input line to be changed character ( len =* ), intent ( in ), optional :: old ! old substring to replace character ( len =* ), intent ( in ), optional :: new ! new substring character ( len =* ), intent ( in ), optional :: cmd ! contains the instructions changing the string integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made character ( len = :), allocatable :: newline ! output string buffer character ( len = :), allocatable :: new_local , old_local , old_local_for_comparison integer :: icount , ichange , ier2 integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: left_margin , right_margin integer :: ind integer :: ic integer :: ichr integer :: range_local ( 2 ) character ( len = :), allocatable :: targetline_for_comparison ! input line to be changed logical :: ignorecase_local logical :: flip character ( len = :), allocatable :: targetline_local ! input line to be changed flip = . false . ignorecase_local = . false . original_input_length = len_trim ( targetline ) ! get non-blank length of input line if ( present ( cmd )) then call crack_cmd ( cmd , old_local , new_local , ier2 ) if ( ier2 /= 0 ) then newline = targetline ! if no changes are made return original string on error if ( present ( ierr )) ierr = ier2 return endif elseif ( present ( old ). and . present ( new )) then old_local = old new_local = new else newline = targetline ! if no changes are made return original string on error call journal ( 'sc' , '*replace* must specify OLD and NEW or CMD' ) return endif if ( present ( ignorecase )) then ignorecase_local = ignorecase else ignorecase_local = . false . endif if ( present ( occurrence )) then range_local ( 1 ) = abs ( occurrence ) else range_local ( 1 ) = 1 endif if ( present ( repeat )) then range_local ( 2 ) = range_local ( 1 ) + repeat - 1 else range_local ( 2 ) = original_input_length endif if ( ignorecase_local ) then targetline_for_comparison = lower ( targetline ) old_local_for_comparison = lower ( old_local ) else targetline_for_comparison = targetline old_local_for_comparison = old_local endif if ( present ( occurrence )) then if ( occurrence < 0 ) then flip = . true . targetline_for_comparison = reverse ( targetline_for_comparison ) targetline_local = reverse ( targetline ) old_local_for_comparison = reverse ( old_local_for_comparison ) old_local = reverse ( old_local ) new_local = reverse ( new_local ) else targetline_local = targetline endif else targetline_local = targetline endif icount = 0 ! initialize error flag/change count ichange = 0 ! initialize error flag/change count len_old = len ( old_local ) ! length of old substring to be replaced len_new = len ( new_local ) ! length of new substring to replace old substring left_margin = 1 ! left_margin is left margin of window to change right_margin = len ( targetline ) ! right_margin is right margin of window to change newline = '' ! begin with a blank line as output string if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichr = len_new + original_input_length if ( len_new > 0 ) then newline = new_local (: len_new ) // targetline_local ( left_margin : original_input_length ) else newline = targetline_local ( left_margin : original_input_length ) endif ichange = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ichange if ( flip ) newline = reverse ( newline ) return endif ichr = left_margin ! place to put characters into output string ic = left_margin ! place looking at in input string loop : do ! try finding start of OLD in remaining part of input in change window ind = index ( targetline_for_comparison ( ic :), old_local_for_comparison (: len_old )) + ic - 1 if ( ind == ic - 1. or . ind > right_margin ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif icount = icount + 1 ! found an old string to change, so increment count of change candidates if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output newline = newline (: ichr - 1 ) // targetline_local ( ic : ind - 1 ) ichr = ichr + ladd endif if ( icount >= range_local ( 1 ). and . icount <= range_local ( 2 )) then ! check if this is an instance to change or keep ichange = ichange + 1 if ( len_new /= 0 ) then ! put in new string newline = newline (: ichr - 1 ) // new_local (: len_new ) ichr = ichr + len_new endif else if ( len_old /= 0 ) then ! put in copy of old string newline = newline (: ichr - 1 ) // old_local (: len_old ) ichr = ichr + len_old endif endif ic = ind + len_old enddo loop select case ( ichange ) case ( 0 ) ! there were no changes made to the window newline = targetline_local ! if no changes made output should be input case default if ( ic <= len ( targetline )) then ! if there is more after last change on original line add it newline = newline (: ichr - 1 ) // targetline_local ( ic : max ( ic , original_input_length )) endif end select if ( present ( ierr )) ierr = ichange if ( flip ) newline = reverse ( newline ) end function replace","tags":"","loc":"proc/replace.html"},{"title":"reverse – M_strings","text":"public elemental function reverse(string) result(rev) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Contents Source Code reverse Source Code elemental function reverse ( string ) result ( rev ) character ( len =* ), intent ( in ) :: string ! string to reverse character ( len = len ( string )) :: rev ! return value (reversed string) integer :: length integer :: i length = len ( string ) do i = 1 , length rev ( i : i ) = string ( length - i + 1 : length - i + 1 ) enddo end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"rotate13 – M_strings","text":"public  function rotate13(input) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(len=len) Contents Source Code rotate13 Source Code function rotate13 ( input ) implicit none character ( len =* ), intent ( in ) :: input character ( len = len ( input )) :: rotate13 integer :: itemp integer :: i rotate13 = ' ' do i = 1 , len_trim ( input ) itemp = iachar ( input ( i : i )) select case ( itemp ) case ( 65 : 77 , 97 : 109 ) itemp = itemp + 13 case ( 78 : 90 , 110 : 122 ) itemp = itemp - 13 end select rotate13 ( i : i ) = char ( itemp ) enddo end function rotate13","tags":"","loc":"proc/rotate13.html"},{"title":"rpad – M_strings","text":"public  function rpad(valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable Contents Source Code rpad Source Code function rpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )) strout = pad ( valuein , length , ' ' , clip = . true .) return class default stop '<ERROR>*rpad* unknown type' end select strout = pad ( line , length , ' ' , clip = . true .) end function rpad","tags":"","loc":"proc/rpad.html"},{"title":"s2c – M_strings","text":"public pure function s2c(string) result(array) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=C_CHAR, len=1), (len_trim(string)+1) Contents Source Code s2c Source Code pure function s2c ( string ) RESULT ( array ) use , intrinsic :: ISO_C_BINDING , only : C_CHAR character ( len =* ), intent ( in ) :: string character ( kind = C_CHAR , len = 1 ) :: array ( len_trim ( string ) + 1 ) integer :: i do i = 1 , size ( array ) - 1 array ( i ) = string ( i : i ) enddo array ( size ( array ):) = achar ( 0 ) end function s2c","tags":"","loc":"proc/s2c.html"},{"title":"s2v – M_strings","text":"public  function s2v(chars, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision Contents Source Code s2v Source Code doubleprecision function s2v ( chars , ierr , onerr ) character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local /= 0 ) then write ( * , * ) '*s2v* stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v","tags":"","loc":"proc/s2v.html"},{"title":"s2vs – M_strings","text":"public  function s2vs(string, delim) result(darray) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), optional :: delim Return Value doubleprecision, allocatable, (:) Contents Source Code s2vs Source Code function s2vs ( string , delim ) result ( darray ) character ( len =* ), intent ( in ) :: string ! keyword to retrieve value for from dictionary character ( len =* ), optional :: delim ! delimiter characters character ( len = :), allocatable :: delim_local doubleprecision , allocatable :: darray (:) ! function type character ( len = :), allocatable :: carray (:) ! convert value to an array using split(3f) integer :: i integer :: ier if ( present ( delim )) then delim_local = delim else delim_local = ' ;,' endif call split ( string , carray , delimiters = delim_local ) ! split string into an array allocate ( darray ( size ( carray ))) ! create the output array do i = 1 , size ( carray ) call string_to_value ( carray ( i ), darray ( i ), ier ) ! convert the string to a numeric value enddo end function s2vs","tags":"","loc":"proc/s2vs.html"},{"title":"sep – M_strings","text":"public  function sep(input_line, delimiters, nulls, order) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: nulls character(len=*), intent(in), optional :: order Return Value character(len=:), allocatable, (:) Contents Source Code sep Source Code function sep ( input_line , delimiters , nulls , order ) intrinsic index , min , present , len character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len =* ), optional , intent ( in ) :: order ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable :: sep (:) ! output array of tokens integer :: isize call split ( input_line , sep , delimiters , 'right' , nulls ) if ( present ( order )) then select case ( order ) case ( 'ascending' , 'ASCENDING' ) isize = size ( sep ) if ( isize > 1 ) then sep = sep ( isize : 1 : - 1 ) endif end select endif end function sep","tags":"","loc":"proc/sep.html"},{"title":"setbits16 – M_strings","text":"public  function setbits16(string) result(answer) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: string Return Value integer(kind=int16) Contents Source Code setbits16 Source Code function setbits16 ( string ) result ( answer ) implicit none integer ( kind = int16 ) :: answer character ( len = 16 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int16 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits16* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits16* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits16","tags":"","loc":"proc/setbits16.html"},{"title":"setbits32 – M_strings","text":"public  function setbits32(string) result(answer) Arguments Type Intent Optional Attributes Name character(len=32), intent(in) :: string Return Value integer(kind=int32) Contents Source Code setbits32 Source Code function setbits32 ( string ) result ( answer ) implicit none integer ( kind = int32 ) :: answer character ( len = 32 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int32 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits32* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits32* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits32","tags":"","loc":"proc/setbits32.html"},{"title":"setbits64 – M_strings","text":"public  function setbits64(string) result(answer) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: string Return Value integer(kind=int64) Contents Source Code setbits64 Source Code function setbits64 ( string ) result ( answer ) implicit none integer ( kind = int64 ) :: answer character ( len = 64 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int64 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits64* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits64* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits64","tags":"","loc":"proc/setbits64.html"},{"title":"setbits8 – M_strings","text":"public  function setbits8(string) result(answer) Arguments Type Intent Optional Attributes Name character(len=8), intent(in) :: string Return Value integer(kind=int8) Contents Source Code setbits8 Source Code function setbits8 ( string ) result ( answer ) implicit none integer ( kind = int8 ) :: answer character ( len = 8 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int8 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits8* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , lgth select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits8* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits8","tags":"","loc":"proc/setbits8.html"},{"title":"squeeze – M_strings","text":"public  function squeeze(str, charp) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: charp Return Value character(len=:), allocatable Contents Source Code squeeze Source Code function squeeze ( str , charp ) result ( outstr ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), intent ( in ) :: charp character ( len = :), allocatable :: outstr character ( len = 1 ) :: ch , last_one integer :: i , pio ! position in output outstr = repeat ( ' ' , len ( str )) ! start with a string big enough to hold any output if ( len ( outstr ) == 0 ) return ! handle edge condition last_one = str ( 1 : 1 ) ! since at least this long start output with first character outstr ( 1 : 1 ) = last_one pio = 1 do i = 2 , len ( str ) ch = str ( i : i ) pio = pio + merge ( 0 , 1 , ch == last_one . and . ch == charp ) ! decide whether to advance before saving outstr ( pio : pio ) = ch ! store new one or overlay the duplcation last_one = ch enddo outstr = outstr (: pio ) ! trim the output string to just what was set end function squeeze","tags":"","loc":"proc/squeeze.html"},{"title":"stretch – M_strings","text":"public  function stretch(line, length, pattern, suffix) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern character(len=*), intent(in), optional :: suffix Return Value character(len=:), allocatable Contents Source Code stretch Source Code function stretch ( line , length , pattern , suffix ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len =* ), intent ( in ), optional :: pattern character ( len =* ), intent ( in ), optional :: suffix character ( len = :), allocatable :: strout if ( present ( pattern )) then strout = pad ( line , length , pattern ) else strout = pad ( line , length ) endif if ( present ( suffix )) then strout = strout // suffix endif end function stretch","tags":"","loc":"proc/stretch.html"},{"title":"string_tokens – M_strings","text":"public pure function string_tokens(string, set) result(tokens) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set Return Value character, allocatable, (:) Contents Source Code string_tokens Source Code pure function string_tokens ( string , set ) result ( tokens ) ! Splits a string into tokens using characters in set as token delimiters. character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: set character (:), allocatable :: tokens (:) call split_tokens ( string , set , tokens ) end function string_tokens","tags":"","loc":"proc/string_tokens.html"},{"title":"strtok – M_strings","text":"public  function strtok(source_string, itoken, token_start, token_end, delimiters) result(strtok_status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source_string integer, intent(inout) :: itoken integer, intent(out) :: token_start integer, intent(inout) :: token_end character(len=*), intent(in) :: delimiters Return Value logical Contents Source Code strtok Source Code FUNCTION strtok ( source_string , itoken , token_start , token_end , delimiters ) result ( strtok_status ) character ( len =* ), intent ( in ) :: source_string ! Source string to tokenize. character ( len =* ), intent ( in ) :: delimiters ! list of separator characters. May change between calls integer , intent ( inout ) :: itoken ! token count since started logical :: strtok_status ! returned value integer , intent ( out ) :: token_start ! beginning of token found if function result is .true. integer , intent ( inout ) :: token_end ! end of token found if function result is .true. integer , save :: isource_len if ( itoken <= 0 ) then ! this is assumed to be the first call token_start = 1 else ! increment start to previous end + 1 token_start = token_end + 1 endif isource_len = len ( source_string ) ! length of input string if ( token_start > isource_len ) then ! user input error or at end of string token_end = isource_len ! assume end of token is end of string until proven otherwise so it is set strtok_status = . false . return endif ! find beginning of token do while ( token_start <= isource_len ) ! step thru each character to find next delimiter, if any if ( index ( delimiters , source_string ( token_start : token_start )) /= 0 ) then token_start = token_start + 1 else exit endif enddo token_end = token_start do while ( token_end <= isource_len - 1 ) ! step thru each character to find next delimiter, if any if ( index ( delimiters , source_string ( token_end + 1 : token_end + 1 )) /= 0 ) then ! found a delimiter in next character exit endif token_end = token_end + 1 enddo if ( token_start > isource_len ) then ! determine if finished strtok_status = . false . ! flag that input string has been completely processed else itoken = itoken + 1 ! increment count of tokens found strtok_status = . true . ! flag more tokens may remain endif end function strtok","tags":"","loc":"proc/strtok.html"},{"title":"transliterate – M_strings","text":"public pure function transliterate(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) Contents Source Code transliterate Source Code PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj jj = LEN ( new_set ) IF ( jj /= 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii /= 0 ) THEN if ( ii <= jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii == 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate","tags":"","loc":"proc/transliterate.html"},{"title":"unquote – M_strings","text":"public  function unquote(quoted_str, esc) result(unquoted_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: quoted_str character(len=1), intent(in), optional :: esc Return Value character(len=:), allocatable Contents Source Code unquote Source Code function unquote ( quoted_str , esc ) result ( unquoted_str ) character ( len =* ), intent ( in ) :: quoted_str ! the string to be unquoted character ( len = 1 ), optional , intent ( in ) :: esc ! escape character character ( len = :), allocatable :: unquoted_str integer :: inlen character ( len = 1 ), parameter :: single_quote = \"'\" character ( len = 1 ), parameter :: double_quote = '\"' integer :: quote ! whichever quote is to be used integer :: before integer :: current integer :: iesc integer :: iput integer :: i logical :: inside if ( present ( esc )) then ! select escape character as specified character or special value meaning not set iesc = iachar ( esc ) ! allow for an escape character else iesc =- 1 ! set to value that matches no character endif inlen = len ( quoted_str ) ! find length of input string allocate ( character ( len = inlen ) :: unquoted_str ) ! initially make output string length of input string if ( inlen >= 1 ) then ! double_quote is the default quote unless the first character is single_quote if ( quoted_str ( 1 : 1 ) == single_quote ) then quote = iachar ( single_quote ) else quote = iachar ( double_quote ) endif else quote = iachar ( double_quote ) endif before =- 2 ! initially set previous character to impossible value unquoted_str (:) = '' ! initialize output string to null string iput = 1 inside = . false . STEPTHROUGH : do i = 1 , inlen current = iachar ( quoted_str ( i : i )) if ( before == iesc ) then ! if previous character was escape use current character unconditionally iput = iput - 1 ! backup unquoted_str ( iput : iput ) = char ( current ) iput = iput + 1 before =- 2 ! this could be second esc or quote elseif ( current == quote ) then ! if current is a quote it depends on whether previous character was a quote if ( before == quote ) then unquoted_str ( iput : iput ) = char ( quote ) ! this is second quote so retain it iput = iput + 1 before =- 2 elseif (. not . inside . and . before /= iesc ) then inside = . true . else ! this is first quote so ignore it except remember it in case next is a quote before = current endif else unquoted_str ( iput : iput ) = char ( current ) iput = iput + 1 before = current endif enddo STEPTHROUGH unquoted_str = unquoted_str (: iput - 1 ) end function unquote","tags":"","loc":"proc/unquote.html"},{"title":"upper – M_strings","text":"public pure elemental function upper(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character Contents Source Code upper Source Code elemental pure function upper ( str , begin , end ) result ( string ) character ( * ), intent ( in ) :: str ! input string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ! initialize output string to input string ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( ibegin , begin ), iend ) endif if ( present ( end )) then iend = max ( 1 , min ( iend , end )) endif do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = achar ( iachar ( str ( i : i )) + diff ) ! change miniscule letter to majascule end select enddo end function upper","tags":"","loc":"proc/upper.html"},{"title":"upper_quoted – M_strings","text":"public pure elemental function upper_quoted(str) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Contents Source Code upper_quoted Source Code elemental pure function upper_quoted ( str ) result ( string ) character ( len =* ), intent ( in ) :: str ! The input string character ( len = len ( str )) :: string ! The output string logical :: toggle character ( len = 1 ) :: togglechar integer :: irnk integer :: i character ( len = 26 ), parameter :: large = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len = 26 ), parameter :: small = \"abcdefghijklmnopqrstuvwxyz\" string = str toggle = . TRUE . do i = 1 , len_trim ( string ) if ( toggle ) then if ( string ( i : i ) == '\"' . or . string ( i : i ) == \"'\" ) then toggle = . not . toggle togglechar = string ( i : i ) endif irnk = index ( small , string ( i : i )) if ( irnk > 0 ) then string ( i : i ) = large ( irnk : irnk ) endif else if ( string ( i : i ) == togglechar ) toggle = . not . toggle endif enddo end function upper_quoted","tags":"","loc":"proc/upper_quoted.html"},{"title":"v2s_bug – M_strings","text":"public  function v2s_bug(gval) result(outstr) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval Return Value character(len=:), allocatable Contents Source Code v2s_bug Source Code function v2s_bug ( gval ) result ( outstr ) class ( * ), intent ( in ) :: gval ! input value to convert to a string character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string call value_to_string ( gval , string ) outstr = trim ( string ) end function v2s_bug","tags":"","loc":"proc/v2s_bug.html"},{"title":"visible – M_strings","text":"public  function visible(input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(len=:), allocatable Contents Source Code visible Source Code function visible ( input ) result ( output ) character ( len =* ), intent ( in ) :: input character ( len = :), allocatable :: output integer :: i character ( len = 1 ) :: c character ( len =* ), parameter :: chars ( 0 : 255 ) = [ & '&#94;@  ' , '&#94;A  ' , '&#94;B  ' , '&#94;C  ' , '&#94;D  ' , '&#94;E  ' , '&#94;F  ' , '&#94;G  ' , '&#94;H  ' , '&#94;I  ' , & '&#94;J  ' , '&#94;K  ' , '&#94;L  ' , '&#94;M  ' , '&#94;N  ' , '&#94;O  ' , '&#94;P  ' , '&#94;Q  ' , '&#94;R  ' , '&#94;S  ' , & '&#94;T  ' , '&#94;U  ' , '&#94;V  ' , '&#94;W  ' , '&#94;X  ' , '&#94;Y  ' , '&#94;Z  ' , '&#94;[  ' , '&#94;\\  ' , '&#94;]  ' , & '&#94;&#94;  ' , '&#94;_  ' , '    ' , '!   ' , '\"   ' , '#   ' , '$   ' , '%   ' , '&   ' , '''   ' , & '(   ' , ')   ' , '*   ' , '+   ' , ',   ' , '-   ' , '.   ' , '/   ' , '0   ' , '1   ' , & '2   ' , '3   ' , '4   ' , '5   ' , '6   ' , '7   ' , '8   ' , '9   ' , ':   ' , ';   ' , & '<   ' , '=   ' , '>   ' , '?   ' , '@   ' , 'A   ' , 'B   ' , 'C   ' , 'D   ' , 'E   ' , & 'F   ' , 'G   ' , 'H   ' , 'I   ' , 'J   ' , 'K   ' , 'L   ' , 'M   ' , 'N   ' , 'O   ' , & 'P   ' , 'Q   ' , 'R   ' , 'S   ' , 'T   ' , 'U   ' , 'V   ' , 'W   ' , 'X   ' , 'Y   ' , & 'Z   ' , '[   ' , '\\   ' , ']   ' , '&#94;   ' , '_   ' , '`   ' , 'a   ' , 'b   ' , 'c   ' , & 'd   ' , 'e   ' , 'f   ' , 'g   ' , 'h   ' , 'i   ' , 'j   ' , 'k   ' , 'l   ' , 'm   ' , & 'n   ' , 'o   ' , 'p   ' , 'q   ' , 'r   ' , 's   ' , 't   ' , 'u   ' , 'v   ' , 'w   ' , & 'x   ' , 'y   ' , 'z   ' , '{   ' , '|   ' , '}   ' , '~   ' , '&#94;?  ' , 'M-&#94;@' , 'M-&#94;A' , & 'M-&#94;B' , 'M-&#94;C' , 'M-&#94;D' , 'M-&#94;E' , 'M-&#94;F' , 'M-&#94;G' , 'M-&#94;H' , 'M-&#94;I' , 'M-&#94;J' , 'M-&#94;K' , & 'M-&#94;L' , 'M-&#94;M' , 'M-&#94;N' , 'M-&#94;O' , 'M-&#94;P' , 'M-&#94;Q' , 'M-&#94;R' , 'M-&#94;S' , 'M-&#94;T' , 'M-&#94;U' , & 'M-&#94;V' , 'M-&#94;W' , 'M-&#94;X' , 'M-&#94;Y' , 'M-&#94;Z' , 'M-&#94;[' , 'M-&#94;\\', ' M - &#94; ] ', ' M - &#94;&#94; ', ' M - &#94;_ ', & ' M - ', ' M - ! ', 'M-\" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', & 'M-* ' , 'M-+ ' , 'M-, ' , 'M-- ' , 'M-. ' , 'M-/ ' , 'M-0 ' , 'M-1 ' , 'M-2 ' , 'M-3 ' , & 'M-4 ' , 'M-5 ' , 'M-6 ' , 'M-7 ' , 'M-8 ' , 'M-9 ' , 'M-: ' , 'M-; ' , 'M-< ' , 'M-= ' , & 'M-> ' , 'M-? ' , 'M-@ ' , 'M-A ' , 'M-B ' , 'M-C ' , 'M-D ' , 'M-E ' , 'M-F ' , 'M-G ' , & 'M-H ' , 'M-I ' , 'M-J ' , 'M-K ' , 'M-L ' , 'M-M ' , 'M-N ' , 'M-O ' , 'M-P ' , 'M-Q ' , & 'M-R ' , 'M-S ' , 'M-T ' , 'M-U ' , 'M-V ' , 'M-W ' , 'M-X ' , 'M-Y ' , 'M-Z ' , 'M-[ ' , & 'M-\\ ' , 'M-] ' , 'M-&#94; ' , 'M-_ ' , 'M-` ' , 'M-a ' , 'M-b ' , 'M-c ' , 'M-d ' , 'M-e ' , & 'M-f ' , 'M-g ' , 'M-h ' , 'M-i ' , 'M-j ' , 'M-k ' , 'M-l ' , 'M-m ' , 'M-n ' , 'M-o ' , & 'M-p ' , 'M-q ' , 'M-r ' , 'M-s ' , 'M-t ' , 'M-u ' , 'M-v ' , 'M-w ' , 'M-x ' , 'M-y ' , & 'M-z ' , 'M-{ ' , 'M-| ' , 'M-} ' , 'M-~ ' , 'M-&#94;?' ] output = '' do i = 1 , len ( input ) c = input ( i : i ) if ( c == ' ' ) then output = output // ' ' else output = output // trim ( chars ( iachar ( c ))) endif enddo end function visible","tags":"","loc":"proc/visible.html"},{"title":"zpad – M_strings","text":"public  function zpad(valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable Contents Source Code zpad Source Code function zpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( character ( len =* )); line = valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein end select strout = pad ( trim ( line ), length , '0' , clip = . true ., right = . false .) end function zpad","tags":"","loc":"proc/zpad.html"},{"title":"change – M_strings","text":"public  subroutine change(target_string, cmd, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: target_string character(len=*), intent(in) :: cmd integer :: ierr Contents Source Code change Source Code subroutine change ( target_string , cmd , ierr ) character ( len =* ), intent ( inout ) :: target_string ! line to be changed character ( len =* ), intent ( in ) :: cmd ! contains the instructions changing the string character ( len = 1 ) :: delimiters integer :: ierr ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made integer :: itoken integer , parameter :: id = 2 ! expected location of delimiter character ( len = :), allocatable :: old , new ! scratch string buffers logical :: ifok integer :: lmax ! length of target string integer :: start_token , end_token lmax = len_trim ( cmd ) ! significant length of change directive if ( lmax >= 4 ) then ! strtok ignores blank tokens so look for special case where first token is really null delimiters = cmd ( id : id ) ! find delimiter in expected location itoken = 0 ! initialize strtok(3f) procedure if ( strtok ( cmd ( id :), itoken , start_token , end_token , delimiters )) then ! find OLD string old = cmd ( start_token + id - 1 : end_token + id - 1 ) else old = '' endif if ( cmd ( id : id ) == cmd ( id + 1 : id + 1 )) then new = old old = '' else ! normal case ifok = strtok ( cmd ( id :), itoken , start_token , end_token , delimiters ) ! find NEW string if ( end_token == ( len ( cmd ) - id + 1 ) ) end_token = len_trim ( cmd ( id :)) ! if missing ending delimiter new = cmd ( start_token + id - 1 : min ( end_token + id - 1 , lmax )) endif call substitute ( target_string , old , new , ierr , 1 , len_trim ( target_string )) ! change old substrings to new substrings else ! command was two or less characters ierr =- 1 call journal ( 'sc' , '*change* incorrect change directive -too short' ) endif end subroutine change","tags":"","loc":"proc/change.html"},{"title":"delim – M_strings","text":"public  subroutine delim(line, array, n, icount, ibegin, iterm, lgth, dlim) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=*) :: array (n) integer, intent(in) :: n integer, intent(out) :: icount integer, intent(out) :: ibegin (n) integer, intent(out) :: iterm (n) integer, intent(out) :: lgth character(len=*), intent(in) :: dlim Contents Source Code delim Source Code subroutine delim ( line , array , n , icount , ibegin , iterm , lgth , dlim ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: n character ( len =* ) :: array ( n ) integer , intent ( out ) :: icount integer , intent ( out ) :: ibegin ( n ) integer , intent ( out ) :: iterm ( n ) integer , intent ( out ) :: lgth character ( len =* ), intent ( in ) :: dlim character ( len = len ( line )) :: line_local logical :: lstore integer :: i10 integer :: iarray integer :: icol integer :: idlim integer :: iend integer :: ifound integer :: istart icount = 0 lgth = len_trim ( line ) line_local = line idlim = len ( dlim ) if ( idlim > 5 ) then idlim = len_trim ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( idlim == 0 ) then idlim = 1 ! blank string endif endif if ( lgth == 0 ) then ! command was totally blank return endif icol = 1 if ( array ( 1 ) == '#N#' ) then ! special flag to not store into character array lstore = . false . else lstore = . true . endif do iarray = 1 , n , 1 ! store into each array element until done or too many words NOINCREMENT : do if ( index ( dlim ( 1 : idlim ), line_local ( icol : icol )) == 0 ) then ! if current character is not a delimiter istart = icol ! start new token on the non-delimiter character ibegin ( iarray ) = icol iend = lgth - istart + 1 + 1 ! assume no delimiters so put past end of line do i10 = 1 , idlim ifound = index ( line_local ( istart : lgth ), dlim ( i10 : i10 )) if ( ifound > 0 ) then iend = min ( iend , ifound ) endif enddo if ( iend <= 0 ) then ! no remaining delimiters iterm ( iarray ) = lgth if ( lstore ) then array ( iarray ) = line_local ( istart : lgth ) endif icount = iarray return else iend = iend + istart - 2 iterm ( iarray ) = iend if ( lstore ) then array ( iarray ) = line_local ( istart : iend ) endif endif icol = iend + 2 exit NOINCREMENT endif icol = icol + 1 enddo NOINCREMENT if ( icol > lgth ) then icount = iarray if ( ( iterm ( icount ) - ibegin ( icount )) < 0 ) then ! last token was all delimiters icount = icount - 1 endif return endif enddo icount = n ! more than n elements end subroutine delim","tags":"","loc":"proc/delim.html"},{"title":"find_field – M_strings","text":"public  subroutine find_field(string, field, position, delims, delim, found) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(out) :: field integer, intent(inout), optional :: position character(len=*), intent(in), optional :: delims character(len=*), intent(out), optional :: delim logical, intent(out), optional :: found Contents Source Code find_field Source Code subroutine find_field ( string , field , position , delims , delim , found ) character * ( * ), intent ( in ) :: string character * ( * ), intent ( out ) :: field integer , optional , intent ( inout ) :: position character * ( * ), optional , intent ( in ) :: delims character * ( * ), optional , intent ( out ) :: delim logical , optional , intent ( out ) :: found character :: delimiter * 1 integer :: pos , field_start , field_end , i logical :: trim_blanks field = '' delimiter = char ( 0 ) pos = 1 if ( present ( found )) found = . false . if ( present ( position )) pos = position if ( pos > len ( string )) goto 9000 !if (pos < 1) error stop 'Illegal position in find_field' if ( pos < 1 ) stop 'Illegal position in find_field' !-- Skip leading blanks if blank is a delimiter. field_start = pos trim_blanks = . true . if ( present ( delims )) trim_blanks = index ( delims , ' ' ) /= 0 if ( trim_blanks ) then i = verify ( string ( pos :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 goto 9000 end if field_start = pos + i - 1 end if if ( present ( found )) found = . true . !-- Find the end of the field. if ( present ( delims )) then i = scan ( string ( field_start :), delims ) else i = scan ( string ( field_start :), ' ' ) end if if ( i == 0 ) then field_end = len ( string ) delimiter = char ( 0 ) pos = field_end + 1 else field_end = field_start + i - 2 delimiter = string ( field_end + 1 : field_end + 1 ) pos = field_end + 2 end if !-- Return the field. field = string ( field_start : field_end ) !-- Skip trailing blanks if blank is a delimiter. if ( trim_blanks ) then i = verify ( string ( field_end + 1 :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 goto 9000 end if pos = field_end + i !-- If the first non-blank character is a delimiter, !-- skip blanks after it. i = 0 if ( present ( delims )) i = index ( delims , string ( pos : pos )) if ( i /= 0 ) then delimiter = string ( pos : pos ) pos = pos + 1 i = verify ( string ( pos :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 else pos = pos + i - 1 end if end if end if !---------- Normal exit. 9000 continue if ( present ( delim )) delim = delimiter if ( present ( position )) position = pos end subroutine find_field","tags":"","loc":"proc/find_field.html"},{"title":"getvals – M_strings","text":"public  subroutine getvals(line, values, icount, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line class(*), intent(out) :: values (:) integer, intent(out) :: icount integer, intent(out), optional :: ierr Contents Source Code getvals Source Code subroutine getvals ( line , values , icount , ierr ) implicit none character ( len =* ), intent ( in ) :: line class ( * ), intent ( out ) :: values (:) integer , intent ( out ) :: icount integer , intent ( out ), optional :: ierr character ( len = :), allocatable :: buffer character ( len = len ( line )) :: words ( size ( values )) integer :: ios , i , ierr_local , isize isize = 0 select type ( values ) type is ( integer ); isize = size ( values ) type is ( real ); isize = size ( values ) type is ( doubleprecision ); isize = size ( values ) type is ( character ( len =* )); isize = size ( values ) end select ierr_local = 0 words = ' ' ! make sure words() is initialized to null+blanks buffer = trim ( unquote ( line )) // \"/\" ! add a slash to the end so how the read behaves with missing values is clearly defined read ( buffer , * , iostat = ios ) words ! undelimited strings are read into an array icount = 0 do i = 1 , isize ! loop thru array and convert non-blank words to numbers if ( words ( i ) == ' ' ) cycle select type ( values ) type is ( integer ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( real ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( doubleprecision ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( character ( len =* )); values ( icount + 1 ) = words ( i ) end select if ( ios == 0 ) then icount = icount + 1 else ierr_local = ios write ( ERROR_UNIT , * ) '*getvals* WARNING:[' // trim ( words ( i )) // '] is not a number of specified type' endif enddo if ( present ( ierr )) then ierr = ierr_local elseif ( ierr_local /= 0 ) then ! error occurred and not returning error to main program to print message and stop program write ( ERROR_UNIT , * ) '*getval* error reading line [' // trim ( line ) // ']' stop 2 endif end subroutine getvals","tags":"","loc":"proc/getvals.html"},{"title":"listout – M_strings","text":"public  subroutine listout(icurve_lists, icurve_expanded, inums_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: icurve_lists (:) integer, intent(out) :: icurve_expanded (:) integer, intent(out) :: inums_out integer, intent(out) :: ierr Contents Source Code listout Source Code subroutine listout ( icurve_lists , icurve_expanded , inums_out , ierr ) implicit none integer , intent ( in ) :: icurve_lists (:) ! input array integer , intent ( out ) :: icurve_expanded (:) ! output array integer , intent ( out ) :: inums_out ! number of icurve_expanded numbers on output integer , intent ( out ) :: ierr ! status variable character ( len = 80 ) :: temp1 integer :: i80 , i90 integer :: imin , imax integer :: idirection , icount integer :: iin integer :: inums_max ierr = 0 icurve_expanded = 0 ! initialize output array inums_out = 0 ! initialize number of significant values in output array inums_max = size ( icurve_expanded ) if ( inums_max == 0 ) then ierr =- 2 return endif iin = size ( icurve_lists ) if ( iin > 0 ) then icurve_expanded ( 1 ) = icurve_lists ( 1 ) endif icount = 2 do i90 = 2 , iin if ( icurve_lists ( i90 ) < 0 ) then imax = abs ( icurve_lists ( i90 )) imin = abs ( icurve_lists ( i90 - 1 )) if ( imin > imax ) then idirection =- 1 imin = imin - 1 elseif ( imax > imin ) then idirection = 1 imin = imin + 1 else idirection = 1 endif do i80 = imin , imax , idirection if ( icount > inums_max ) then write ( temp1 , '(a,i5,a)' ) '*listout* only ' , inums_max , ' values allowed' ierr =- 1 call journal ( temp1 ) inums_out = icount - 1 exit endif icurve_expanded ( icount ) = i80 icount = icount + 1 enddo else icurve_expanded ( icount ) = icurve_lists ( i90 ) icount = icount + 1 endif enddo inums_out = icount - 1 end subroutine listout","tags":"","loc":"proc/listout.html"},{"title":"matching_delimiter – M_strings","text":"public impure elemental subroutine matching_delimiter(str, ipos, imatch) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch Contents Source Code matching_delimiter Source Code impure elemental subroutine matching_delimiter ( str , ipos , imatch ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: ipos integer , intent ( out ) :: imatch character :: delim1 , delim2 , ch integer :: lenstr integer :: idelim2 integer :: istart , iend integer :: inc integer :: isum integer :: i imatch = 0 lenstr = len_trim ( str ) delim1 = str ( ipos : ipos ) select case ( delim1 ) case ( '(' ) idelim2 = iachar ( delim1 ) + 1 istart = ipos + 1 iend = lenstr inc = 1 case ( ')' ) idelim2 = iachar ( delim1 ) - 1 istart = ipos - 1 iend = 1 inc =- 1 case ( '[' , '{' , '<' ) idelim2 = iachar ( delim1 ) + 2 istart = ipos + 1 iend = lenstr inc = 1 case ( ']' , '}' , '>' ) idelim2 = iachar ( delim1 ) - 2 istart = ipos - 1 iend = 1 inc =- 1 case default write ( * , * ) delim1 , ' is not a valid delimiter' return end select if ( istart < 1 . or . istart > lenstr ) then write ( * , * ) delim1 , ' has no matching delimiter' return endif delim2 = achar ( idelim2 ) ! matching delimiter isum = 1 do i = istart , iend , inc ch = str ( i : i ) if ( ch /= delim1 . and . ch /= delim2 ) cycle if ( ch == delim1 ) isum = isum + 1 if ( ch == delim2 ) isum = isum - 1 if ( isum == 0 ) exit enddo if ( isum /= 0 ) then write ( * , * ) delim1 , ' has no matching delimiter' return endif imatch = i end subroutine matching_delimiter","tags":"","loc":"proc/matching_delimiter.html"},{"title":"modif – M_strings","text":"public  subroutine modif(cline, mod) Arguments Type Intent Optional Attributes Name character(len=*) :: cline character(len=*), intent(in) :: mod Contents Source Code modif Source Code subroutine modif ( cline , mod ) character ( len =* ) :: cline !STRING TO BE MODIFIED character ( len =* ), intent ( in ) :: mod !STRING TO DIRECT MODIFICATION character ( len = len ( cline )) :: cmod character ( len = 3 ), parameter :: c = '#&&#94;' !ASSIGN DEFAULT EDIT CHARACTERS integer :: maxscra !LENGTH OF SCRATCH BUFFER character ( len = len ( cline )) :: dum2 !SCRATCH CHARACTER BUFFER logical :: linsrt !FLAG FOR INSERTING DATA ON LINE integer :: i , j , ic , ichr , iend , lmax , lmx1 maxscra = len ( cline ) cmod = trim ( mod ) lmax = min0 ( len ( cline ), maxscra ) !DETERMINE MAXIMUM LINE LENGTH lmx1 = lmax - 1 !MAX LINE LENGTH -1 dum2 = ' ' !INITIALIZE NEW LINE linsrt = . false . !INITIALIZE INSERT MODE iend = len_trim ( cmod ) !DETERMINE END OF MODS i = 0 !CHAR COUNTER FOR MOD LINE CMOD ic = 0 !CHAR COUNTER FOR CURRENT LINE CLINE ichr = 0 !CHAR COUNTER NEW LINE DUM2 11 continue i = i + 1 !NEXT CHAR IN MOD LINE if ( ichr > lmx1 ) goto 999 !IF TOO MANY CHARS IN NEW LINE if ( linsrt ) then !IF INSERTING NEW CHARS if ( i > iend ) cmod ( i : i ) = c ( 1 : 1 ) !FORCE END OF INSERT MODE if ( cmod ( i : i ) == c ( 1 : 1 )) then !IF END OF INSERT MODE linsrt = . false . !RESET INSERT MODE FLAG if ( ic + 1 == i ) then !NULL INSERT STRING ichr = ichr + 1 !INCREMENT COUNTER FOR NEW LINE dum2 ( ichr : ichr ) = c ( 1 : 1 ) !INSERT INSERT MODE TERMINATOR endif do j = ic , i !LOOP OF NUMBER OF CHARS INSERTED ichr = ichr + 1 !INCREMENT COUNTER FOR NEW LINE if ( ichr > lmax ) goto 999 !IF AT BUFFER LIMIT, QUIT dum2 ( ichr : ichr ) = cline ( j : j ) !APPEND CHARS FROM ORIG LINE enddo !...WHICH ALIGN WITH INSERTED CHARS ic = i !RESET CHAR COUNT TO END OF INSERT goto 1 !CHECK NEW LINE LENGTH AND CYCLE endif !END OF TERMINATED INSERT LOGIC ichr = ichr + 1 !INCREMENT NEW LINE COUNT dum2 ( ichr : ichr ) = cmod ( i : i ) !SET NEWLINE CHAR TO INSERTED CHAR else !IF NOT INSERTING CHARACTERS ic = ic + 1 !INCREMENT ORIGINAL LINE COUNTER if ( cmod ( i : i ) == c ( 1 : 1 )) goto 1 !IF DELETE CHAR. NO COPY AND CYCLE if ( cmod ( i : i ) == c ( 3 : 3 )) then !IF BEGIN INSERT MODE linsrt = . true . !SET INSERT FLAG TRUE goto 1 !CHECK LINE LENGTH AND CONTINUE endif !IF NOT BEGINNING INSERT MODE ichr = ichr + 1 !INCREMENT NEW LINE COUNTER if ( cmod ( i : i ) == c ( 2 : 2 )) then !IF REPLACE WITH BLANK dum2 ( ichr : ichr ) = ' ' !SET NEWLINE CHAR TO BLANK goto 1 !CHECK LINE LENGTH AND CYCLE endif !IF NOT REPLACE WITH BLANK if ( cmod ( i : i ) == ' ' ) then !IF BLANK, KEEP ORIGINAL CHARACTER dum2 ( ichr : ichr ) = cline ( ic : ic ) !SET NEW CHAR TO ORIGINAL CHAR else !IF NOT KEEPING OLD CHAR dum2 ( ichr : ichr ) = cmod ( i : i ) !REPLACE ORIGINAL CHAR WITH NEW endif !END CHAR KEEP OR REPLACE endif !END INSERT OR NO-INSERT 1 continue if ( i < lmax ) goto 11 !CHECK FOR END OF LINE REACHED !AND CYCLE IF OK 999 continue cline = dum2 !SET ORIGINAL CHARS TO NEW CHARS end subroutine modif !RETURN","tags":"","loc":"proc/modif.html"},{"title":"notabs – M_strings","text":"public impure elemental subroutine notabs(instr, outstr, lgth) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(out) :: outstr integer, intent(out) :: lgth Contents Source Code notabs Source Code elemental impure subroutine notabs ( instr , outstr , lgth ) character ( len =* ), intent ( in ) :: instr ! input line to scan for tab characters character ( len =* ), intent ( out ) :: outstr ! tab-expanded version of INSTR produced integer , intent ( out ) :: lgth ! column position of last character put into output string ! that is, lgth holds the position of the last non-blank character in OUTSTR integer , parameter :: tabsize = 8 ! assume a tab stop is set every 8th column integer :: ipos ! position in OUTSTR to put next character of INSTR integer :: lenin ! length of input string trimmed of trailing spaces integer :: lenout ! number of characters output string can hold integer :: istep ! counter that advances thru input string INSTR one character at a time character ( len = 1 ) :: c ! character in input line being processed integer :: iade ! ADE (ASCII Decimal Equivalent) of character being tested ipos = 1 ! where to put next character in output string OUTSTR lenin = len_trim ( instr ( 1 : len ( instr ) )) ! length of INSTR trimmed of trailing spaces lenout = len ( outstr ) ! number of characters output string OUTSTR can hold outstr = \" \" ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters SCAN_LINE : do istep = 1 , lenin ! look through input string one character at a time c = instr ( istep : istep ) ! get next character iade = iachar ( c ) ! get ADE of the character EXPAND_TABS : select case ( iade ) ! take different actions depending on which character was found case ( 9 ) ! test if character is a tab and move pointer out to appropriate column ipos = ipos + ( tabsize - ( mod ( ipos - 1 , tabsize ))) case ( 10 , 13 ) ! convert carriage-return and new-line to space ,typically to handle DOS-format files ipos = ipos + 1 case default ! c is anything else other than a tab,newline,or return  insert it in output string if ( ipos > lenout ) then call journal ( \"*notabs* output string overflow\" ) exit else outstr ( ipos : ipos ) = c ipos = ipos + 1 endif end select EXPAND_TABS enddo SCAN_LINE ipos = min ( ipos , lenout ) ! tabs or newline or return characters or last character might have gone too far lgth = len_trim ( outstr (: ipos )) ! trim trailing spaces end subroutine notabs","tags":"","loc":"proc/notabs.html"},{"title":"split – M_strings","text":"public  subroutine split(input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Contents Source Code split Source Code subroutine split ( input_line , array , delimiters , order , nulls ) intrinsic index , min , present , len character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: lgth ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter if ( allocated ( ibegin )) deallocate ( ibegin ) !x! intel compiler says allocated already ? if ( allocated ( iterm )) deallocate ( iterm ) !x! intel compiler says allocated already ? allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 lgth = len ( input_line ) ! lgth is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found if ( lgth > 0 ) then ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , lgth , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = lgth ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): lgth ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > lgth ) then ! no text left exit INFINITE endif enddo INFINITE endif select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to return select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split","tags":"","loc":"proc/split.html"},{"title":"string_to_values – M_strings","text":"public  subroutine string_to_values(line, iread, values, inums, delims, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr Contents Source Code string_to_values Source Code subroutine string_to_values ( line , iread , values , inums , delims , ierr ) implicit none character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , lgth , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local == '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 lgth = 0 ! lgth will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )) == 0 ) then ! found a non-delimiter lgth = i20 exit endif enddo if ( lgth == 0 ) then ! command was totally composed of delimiters call journal ( '*string_to_values* blank line passed as a list of numbers' ) return endif icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol > lgth ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )) == 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , lgth ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )) /= 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend == 0 ) iend = lgth + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier == 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP end subroutine string_to_values","tags":"","loc":"proc/string_to_values.html"},{"title":"substitute – M_strings","text":"public  subroutine substitute(targetline, old, new, ierr, start, end) Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end Contents Source Code substitute Source Code subroutine substitute ( targetline , old , new , ierr , start , end ) character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichr if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option ! change to optional parameter(s) len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id <= 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichr = len_new + original_input_length if ( ichr > maxlengthout ) then call journal ( 'sc' , '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new > 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif ichr = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind == ic - 1. or . ind > ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichr - 1 + ladd > maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichr :) = targetline ( ic : ind - 1 ) ichr = ichr + ladd endif if ( ichr - 1 + len_new > maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new /= 0 ) then dum1 ( ichr :) = new (: len_new ) ichr = ichr + len_new endif ic = ind + len_old enddo loop select case ( ier1 ) case (: - 1 ) call journal ( 'sc' , '*substitute* new line will be too long' ) case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichr + ladd > maxlengthout ) then call journal ( 'sc' , '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic < len ( targetline )) then dum1 ( ichr :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 end subroutine substitute","tags":"","loc":"proc/substitute.html"},{"title":"value_to_string – M_strings","text":"public  subroutine value_to_string(gval, chars, length, err, fmt, trimz) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval character(len=*), intent(out) :: chars integer, intent(out), optional :: length integer, optional :: err character(len=*), intent(in), optional :: fmt logical, intent(in), optional :: trimz Contents Source Code value_to_string Source Code subroutine value_to_string ( gval , chars , length , err , fmt , trimz ) class ( * ), intent ( in ) :: gval character ( len =* ), intent ( out ) :: chars integer , intent ( out ), optional :: length integer , optional :: err integer :: err_local character ( len =* ), optional , intent ( in ) :: fmt ! format to write value with logical , intent ( in ), optional :: trimz character ( len = :), allocatable :: fmt_local character ( len = 1024 ) :: msg if ( present ( fmt )) then select type ( gval ) type is ( integer ) fmt_local = '(i0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( real ) fmt_local = '(bz,g23.10e3)' fmt_local = '(bz,g0.8)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) fmt_local = '(bz,g0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( logical ) fmt_local = '(l1)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval class default call journal ( '*value_to_string* UNKNOWN TYPE' ) chars = ' ' end select if ( fmt == '' ) then chars = adjustl ( chars ) call trimzeros_ ( chars ) endif else ! no explicit format option present err_local =- 1 select type ( gval ) type is ( integer ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( real ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( logical ) write ( chars , * , iostat = err_local , iomsg = msg ) gval class default chars = '' end select chars = adjustl ( chars ) if ( index ( chars , '.' ) /= 0 ) call trimzeros_ ( chars ) endif if ( present ( trimz )) then if ( trimz ) then chars = adjustl ( chars ) call trimzeros_ ( chars ) endif endif if ( present ( length )) then length = len_trim ( chars ) endif if ( present ( err )) then err = err_local elseif ( err_local /= 0 ) then ! cannot currently do I/O from a function being called from I/O !write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']' chars = chars // ' *value_to_string* WARNING:[' // trim ( msg ) // ']' endif end subroutine value_to_string","tags":"","loc":"proc/value_to_string.html"},{"title":"atleast – M_strings","text":"public interface atleast Contents Module Procedures pad Module Procedures public  function pad (line, length, pattern, right, clip) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value character(len=:), allocatable","tags":"","loc":"interface/atleast.html"},{"title":"cc – M_strings","text":"public interface cc Contents Module Procedures bundle Module Procedures public  function bundle (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, len) result(vec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x1 character(len=*), intent(in), optional :: x2 character(len=*), intent(in), optional :: x3 character(len=*), intent(in), optional :: x4 character(len=*), intent(in), optional :: x5 character(len=*), intent(in), optional :: x6 character(len=*), intent(in), optional :: x7 character(len=*), intent(in), optional :: x8 character(len=*), intent(in), optional :: x9 character(len=*), intent(in), optional :: x10 character(len=*), intent(in), optional :: x11 character(len=*), intent(in), optional :: x12 character(len=*), intent(in), optional :: x13 character(len=*), intent(in), optional :: x14 character(len=*), intent(in), optional :: x15 character(len=*), intent(in), optional :: x16 character(len=*), intent(in), optional :: x17 character(len=*), intent(in), optional :: x18 character(len=*), intent(in), optional :: x19 character(len=*), intent(in), optional :: x20 integer, intent(in), optional :: len Return Value character(len=:), allocatable, (:)","tags":"","loc":"interface/cc.html"},{"title":"dble – M_strings","text":"public interface dble Contents Module Procedures dble_s2v Module Procedures private impure elemental function dble_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value doubleprecision","tags":"","loc":"interface/dble.html"},{"title":"ends_with – M_strings","text":"public interface ends_with Contents Module Procedures ends_with_str ends_with_any Module Procedures private pure function ends_with_str(string, ending) result(matched) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: ending Return Value logical private pure function ends_with_any(string, endings) result(matched) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: endings (:) Return Value logical","tags":"","loc":"interface/ends_with.html"},{"title":"int – M_strings","text":"public interface int Contents Module Procedures int_s2v Module Procedures private impure elemental function int_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value integer","tags":"","loc":"interface/int.html"},{"title":"matchw – M_strings","text":"public interface matchw Contents Module Procedures glob Module Procedures public  function glob (tame, wild) Arguments Type Intent Optional Attributes Name character(len=*) :: tame character(len=*) :: wild Return Value logical","tags":"","loc":"interface/matchw.html"},{"title":"msg – M_strings","text":"public interface msg Contents Module Procedures msg_scalar msg_one Module Procedures private  function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable private  function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable","tags":"","loc":"interface/msg.html"},{"title":"nint – M_strings","text":"public interface nint Contents Module Procedures nint_s2v Module Procedures private impure elemental function nint_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value integer","tags":"","loc":"interface/nint.html"},{"title":"real – M_strings","text":"public interface real Contents Module Procedures real_s2v Module Procedures private impure elemental function real_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value real","tags":"","loc":"interface/real.html"},{"title":"split2020 – M_strings","text":"public interface split2020 Contents Module Procedures split_tokens split_first_last split_pos Module Procedures private pure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set character, intent(out), allocatable :: tokens (:) character, intent(out), optional, allocatable :: separator (:) private pure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private pure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back","tags":"","loc":"interface/split2020.html"},{"title":"string_to_value – M_strings","text":"public interface string_to_value Contents Module Procedures a2d a2r a2i Module Procedures private  subroutine a2d(chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr private  subroutine a2r(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars real, intent(out) :: valu integer, intent(out) :: ierr private  subroutine a2i(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(out) :: valu integer, intent(out) :: ierr","tags":"","loc":"interface/string_to_value.html"},{"title":"switch – M_strings","text":"public interface switch Contents Module Procedures a2s s2a Module Procedures private pure function a2s(array) result(string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: array (:) Return Value character(len=SIZE) private pure function s2a(string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1), (len(string))","tags":"","loc":"interface/switch.html"},{"title":"v2s – M_strings","text":"public interface v2s Contents Module Procedures d2s r2s i2s l2s Module Procedures private  function d2s(dvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function r2s(rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function i2s(ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function l2s(lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable","tags":"","loc":"interface/v2s.html"},{"title":"p – M_strings","text":"public  function p(self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(len=len) Contents Source Code p Source Code function p ( self ) result ( string_out ) ! ident_30=\"@(#) M_strings oop_p(3f) return CHARACTER string from TYPE(STRING)\" class ( string ), intent ( in ) :: self character ( len = len ( self % str )) :: string_out string_out = self % str end function p","tags":"","loc":"proc/p.html"},{"title":"string – M_strings","text":"public interface string Contents Module Procedures construct_from_fill Module Procedures private  function construct_from_fill(chars, len) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: chars integer, intent(in), optional :: len Return Value type( string )","tags":"","loc":"interface/string.html"},{"title":"M_strings – M_strings","text":"Uses iso_fortran_env Contents Variables ascii_bel ascii_bs ascii_cr ascii_esc ascii_ff ascii_ht ascii_lf ascii_nul Interfaces atleast cc dble ends_with int matchw msg nint real split2020 string_to_value switch v2s Functions adjustc base base2 bundle c2s chomp clip codebase compact cpad crop decodebase describe dilate edit_distance expand fortran_name glob indent isNumber isalnum isalpha isascii isblank iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit join len_white lenset longest_common_substring lower lpad merge_str noesc nospace pad paragraph quote replace reverse rotate13 rpad s2c s2v s2vs sep setbits16 setbits32 setbits64 setbits8 squeeze stretch string_tokens strtok transliterate unquote upper upper_quoted v2s_bug visible zpad Subroutines change delim find_field getvals listout matching_delimiter modif notabs split string_to_values substitute value_to_string Variables Type Visibility Attributes Name Initial character, public, parameter :: ascii_bel = char(7) character, public, parameter :: ascii_bs = char(8) character, public, parameter :: ascii_cr = char(13) character, public, parameter :: ascii_esc = char(27) character, public, parameter :: ascii_ff = char(12) character, public, parameter :: ascii_ht = char(9) character, public, parameter :: ascii_lf = char(10) character, public, parameter :: ascii_nul = char(0) Interfaces public        interface atleast public  function pad (line, length, pattern, right, clip) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value character(len=:), allocatable public        interface cc public  function bundle (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, len) result(vec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x1 character(len=*), intent(in), optional :: x2 character(len=*), intent(in), optional :: x3 character(len=*), intent(in), optional :: x4 character(len=*), intent(in), optional :: x5 character(len=*), intent(in), optional :: x6 character(len=*), intent(in), optional :: x7 character(len=*), intent(in), optional :: x8 character(len=*), intent(in), optional :: x9 character(len=*), intent(in), optional :: x10 character(len=*), intent(in), optional :: x11 character(len=*), intent(in), optional :: x12 character(len=*), intent(in), optional :: x13 character(len=*), intent(in), optional :: x14 character(len=*), intent(in), optional :: x15 character(len=*), intent(in), optional :: x16 character(len=*), intent(in), optional :: x17 character(len=*), intent(in), optional :: x18 character(len=*), intent(in), optional :: x19 character(len=*), intent(in), optional :: x20 integer, intent(in), optional :: len Return Value character(len=:), allocatable, (:) public        interface dble private impure elemental function dble_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value doubleprecision public        interface ends_with private pure function ends_with_str(string, ending) result(matched) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: ending Return Value logical private pure function ends_with_any(string, endings) result(matched) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: endings (:) Return Value logical public        interface int private impure elemental function int_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value integer public        interface matchw public  function glob (tame, wild) Arguments Type Intent Optional Attributes Name character(len=*) :: tame character(len=*) :: wild Return Value logical public        interface msg private  function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable private  function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable public        interface nint private impure elemental function nint_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value integer public        interface real private impure elemental function real_s2v(chars) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars Return Value real public        interface split2020 private pure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set character, intent(out), allocatable :: tokens (:) character, intent(out), optional, allocatable :: separator (:) private pure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private pure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back public        interface string_to_value private  subroutine a2d(chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr private  subroutine a2r(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars real, intent(out) :: valu integer, intent(out) :: ierr private  subroutine a2i(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(out) :: valu integer, intent(out) :: ierr public        interface switch private pure function a2s(array) result(string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: array (:) Return Value character(len=SIZE) private pure function s2a(string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1), (len(string)) public        interface v2s private  function d2s(dvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function r2s(rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function i2s(ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function l2s(lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable Functions public pure function adjustc (string, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: length Return Value character(len=:), allocatable public  function base (x, b, y, a) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x integer, intent(in) :: b character(len=*), intent(out) :: y integer, intent(in) :: a Return Value logical public  function base2 (x) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=max) public  function bundle (x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, len) result(vec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x1 character(len=*), intent(in), optional :: x2 character(len=*), intent(in), optional :: x3 character(len=*), intent(in), optional :: x4 character(len=*), intent(in), optional :: x5 character(len=*), intent(in), optional :: x6 character(len=*), intent(in), optional :: x7 character(len=*), intent(in), optional :: x8 character(len=*), intent(in), optional :: x9 character(len=*), intent(in), optional :: x10 character(len=*), intent(in), optional :: x11 character(len=*), intent(in), optional :: x12 character(len=*), intent(in), optional :: x13 character(len=*), intent(in), optional :: x14 character(len=*), intent(in), optional :: x15 character(len=*), intent(in), optional :: x16 character(len=*), intent(in), optional :: x17 character(len=*), intent(in), optional :: x18 character(len=*), intent(in), optional :: x19 character(len=*), intent(in), optional :: x20 integer, intent(in), optional :: len Return Value character(len=:), allocatable, (:) public  function c2s (c_string_pointer) result(f_string) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: c_string_pointer Return Value character(len=:), allocatable public  function chomp (source_string, token, delimiters) Arguments Type Intent Optional Attributes Name character(len=*) :: source_string character(len=:), intent(out), allocatable :: token character(len=*), intent(in), optional :: delimiters Return Value integer public  function clip (string) result(lopped) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable public  function codebase (inval10, outbase, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inval10 integer, intent(in) :: outbase character(len=*), intent(out) :: answer Return Value logical public  function compact (str, char) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) public  function cpad (valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable public  function crop (strin) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin Return Value character(len=:), allocatable public  function decodebase (string, basein, out_baseten) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: basein integer, intent(out) :: out_baseten Return Value logical public  function describe (ch) result(string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ch Return Value character(len=:), allocatable public  function dilate (instr) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr Return Value character(len=:), allocatable public pure elemental function edit_distance (a, b) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a character(len=*), intent(in) :: b Return Value integer public  function expand (line, escape) result(lineout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(in), optional :: escape Return Value character(len=:), allocatable public elemental function fortran_name (line) result(lout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical public  function glob (tame, wild) Arguments Type Intent Optional Attributes Name character(len=*) :: tame character(len=*) :: wild Return Value logical public  function indent (line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer public  function isNumber (string, msg, verbose) result(isnumber) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=:), intent(out), optional, allocatable :: msg logical, intent(in), optional :: verbose Return Value integer public elemental function isalnum (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isalpha (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isascii (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isblank (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function iscntrl (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isdigit (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isgraph (onechar) Arguments Type Intent Optional Attributes Name character, intent(in) :: onechar Return Value logical public elemental function islower (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isprint (onechar) Arguments Type Intent Optional Attributes Name character, intent(in) :: onechar Return Value logical public elemental function ispunct (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isspace (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public pure elemental function isupper (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public elemental function isxdigit (ch) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: ch Return Value logical public pure function join (str, sep, trm, left, right, start, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str (:) character(len=*), intent(in), optional :: sep logical, intent(in), optional :: trm character(len=*), intent(in), optional :: left character(len=*), intent(in), optional :: right character(len=*), intent(in), optional :: start character(len=*), intent(in), optional :: end Return Value character(len=:), allocatable public elemental function len_white (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer public  function lenset (line, length) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length Return Value character(len=length) public  function longest_common_substring (a, b) result(match) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a character(len=*), intent(in) :: b Return Value character(len=:), allocatable public pure elemental function lower (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character public  function lpad (valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable public  function merge_str (str1, str2, expr) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: str1 character(len=*), intent(in), optional :: str2 logical, intent(in) :: expr Return Value character(len=:), allocatable public elemental function noesc (INSTR) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: INSTR Return Value character(len=len) public  function nospace (line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable public  function pad (line, length, pattern, right, clip) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value character(len=:), allocatable public  function paragraph (source_string, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source_string integer, intent(in) :: length Return Value character(len=:), allocatable, (:) public  function quote (str, mode, clip) result(quoted_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: mode logical, intent(in), optional :: clip Return Value character(len=:), allocatable public  function replace (targetline, old, new, cmd, occurrence, repeat, ignorecase, ierr) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: targetline character(len=*), intent(in), optional :: old character(len=*), intent(in), optional :: new character(len=*), intent(in), optional :: cmd integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: ierr Return Value character(len=:), allocatable public elemental function reverse (string) result(rev) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) public  function rotate13 (input) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(len=len) public  function rpad (valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable public pure function s2c (string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=C_CHAR, len=1), (len_trim(string)+1) public  function s2v (chars, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision public  function s2vs (string, delim) result(darray) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), optional :: delim Return Value doubleprecision, allocatable, (:) public  function sep (input_line, delimiters, nulls, order) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: nulls character(len=*), intent(in), optional :: order Return Value character(len=:), allocatable, (:) public  function setbits16 (string) result(answer) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: string Return Value integer(kind=int16) public  function setbits32 (string) result(answer) Arguments Type Intent Optional Attributes Name character(len=32), intent(in) :: string Return Value integer(kind=int32) public  function setbits64 (string) result(answer) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: string Return Value integer(kind=int64) public  function setbits8 (string) result(answer) Arguments Type Intent Optional Attributes Name character(len=8), intent(in) :: string Return Value integer(kind=int8) public  function squeeze (str, charp) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: charp Return Value character(len=:), allocatable public  function stretch (line, length, pattern, suffix) result(strout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: length character(len=*), intent(in), optional :: pattern character(len=*), intent(in), optional :: suffix Return Value character(len=:), allocatable public pure function string_tokens (string, set) result(tokens) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: set Return Value character, allocatable, (:) public  function strtok (source_string, itoken, token_start, token_end, delimiters) result(strtok_status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source_string integer, intent(inout) :: itoken integer, intent(out) :: token_start integer, intent(inout) :: token_end character(len=*), intent(in) :: delimiters Return Value logical public pure function transliterate (instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) public  function unquote (quoted_str, esc) result(unquoted_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: quoted_str character(len=1), intent(in), optional :: esc Return Value character(len=:), allocatable public pure elemental function upper (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character public pure elemental function upper_quoted (str) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) public  function v2s_bug (gval) result(outstr) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval Return Value character(len=:), allocatable public  function visible (input) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value character(len=:), allocatable public  function zpad (valuein, length) result(strout) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein integer, intent(in) :: length Return Value character(len=:), allocatable Subroutines public  subroutine change (target_string, cmd, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: target_string character(len=*), intent(in) :: cmd integer :: ierr public  subroutine delim (line, array, n, icount, ibegin, iterm, lgth, dlim) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=*) :: array (n) integer, intent(in) :: n integer, intent(out) :: icount integer, intent(out) :: ibegin (n) integer, intent(out) :: iterm (n) integer, intent(out) :: lgth character(len=*), intent(in) :: dlim public  subroutine find_field (string, field, position, delims, delim, found) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(out) :: field integer, intent(inout), optional :: position character(len=*), intent(in), optional :: delims character(len=*), intent(out), optional :: delim logical, intent(out), optional :: found public  subroutine getvals (line, values, icount, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line class(*), intent(out) :: values (:) integer, intent(out) :: icount integer, intent(out), optional :: ierr public  subroutine listout (icurve_lists, icurve_expanded, inums_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: icurve_lists (:) integer, intent(out) :: icurve_expanded (:) integer, intent(out) :: inums_out integer, intent(out) :: ierr public impure elemental subroutine matching_delimiter (str, ipos, imatch) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch public  subroutine modif (cline, mod) Arguments Type Intent Optional Attributes Name character(len=*) :: cline character(len=*), intent(in) :: mod public impure elemental subroutine notabs (instr, outstr, lgth) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(out) :: outstr integer, intent(out) :: lgth public  subroutine split (input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls public  subroutine string_to_values (line, iread, values, inums, delims, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr public  subroutine substitute (targetline, old, new, ierr, start, end) Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end public  subroutine value_to_string (gval, chars, length, err, fmt, trimz) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval character(len=*), intent(out) :: chars integer, intent(out), optional :: length integer, optional :: err character(len=*), intent(in), optional :: fmt logical, intent(in), optional :: trimz","tags":"","loc":"module/m_strings.html"},{"title":"M_strings_oop – M_strings","text":"NAME M_strings_oop(3f) - [M_strings::INTRO::OOPS] OOP Fortran string module SYNOPSIS use M_strings_oop DESCRIPTION The M_strings ( 3 fm ) module is a collection of Fortran procedures that supplement the built - in intrinsic string routines . Routines for parsing , tokenizing , changing case , substituting new strings for substrings , locating strings with simple wildcard expressions , removing tabs and line terminators and other string manipulations are included . M_strings_oop ( 3 fm ) is a companion module that provides an OOP interface to the M_strings module . SEE ALSO There are additional routines in other GPF modules for working with expressions ( M_calculator ), time strings ( M_time ), random strings ( M_random , M_uuid ), lists ( M_list ), and interfacing with the C regular expression library ( M_regex ). EXAMPLES Each of the procedural functions in M_strings ( 3 fm ) includes an example program in the corresponding man ( 1 ) page for the function . The object - oriented interface does not have individual man ( 1 ) pages , but is instead demonstrated using the following example program : program demo_M_strings_oop ! ! This is an example using the object - oriented class / type model ! defined in M_strings_oop ! This is essentially the same functionality as the procedures ! combined with several Fortran intrinsics and overloaded operators ! use M_strings_oop , only : string , p implicit none TYPE ( string ) :: str1 TYPE ( string ) :: str2 TYPE ( string ) :: str3 TYPE ( string ) :: str4 !==================================================================== write ( * , * ) 'exercise the M_STRING_OOP module interface' ! draw a break line in the output write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'Call methods of type(STRING)' ! define TYPE ( STRING ) with constructor str2 = string ( '   This  is  a  String!       ' ) str4 = string ( ' a  String ' ) write ( * , * ) repeat ( '=' , 68 ) ! print members of type write ( * , 101 ) 'str2 %s tr is ................ ' , str2 % str ! same as intrinsic LEN () write ( * , 202 ) 'len ........................ ' , str2 % len () ! same as intrinsic LEN_TRIM () write ( * , 202 ) 'len_trim ................... ' , str2 % len_trim () ! same as intrinsic INDEX () write ( * , 202 ) 'index(\"is\")................. ' , str2 % index ( \"is\" ) ! same as intrinsic INDEX () write ( * , 202 ) 'index(\"is\",back=.T.) ....... ' , str2 % index ( \"is\" , back =. TRUE . ) ! output TYPE ( STRING ) with % str all uppercase write ( * , 101 ) 'upper ...................... ' , p ( str2 % upper ()) ! output TYPE ( STRING ) with % str all miniscule write ( * , 101 ) 'lower ...................... ' , p ( str2 % lower ()) ! output TYPE ( STRING ) with % str reversed write ( * , 101 ) 'reverse .................... ' , p ( str2 % reverse ()) ! same as intrinsic ADJUSTL () write ( * , 101 ) 'adjustl .................... ' , p ( str2 % adjustl ()) ! same as intrinsic ADJUSTR () write ( * , 101 ) 'adjustr .................... ' , p ( str2 % adjustr ()) ! center string in current string length write ( * , 101 ) 'adjustc .................... ' , p ( str2 % adjustc ()) ! center string in string length of NN write ( * , 101 ) 'adjustc(40) ................ ' , p ( str2 % adjustc ( 40 )) ! force % str to be NN characters long write ( * , 101 ) 'lenset(40) ................. ' , p ( str2 % lenset ( 40 )) ! same as intrinsic TRIM () write ( * , 101 ) 'trim ....................... ' , p ( str2 % trim ()) ! trim leading and trailing spaces write ( * , 101 ) 'crop ....................... ' , p ( str2 % crop ()) ! calls M_strings procedure SUBSTITUTE () write ( * , 101 ) 'substitute(\"This\",\"Here\") .. ' , & & p ( str2 % substitute ( \"This\" , \"Here\" )) ! calls M_strings procedure COMPACT () write ( * , 101 ) 'compact .................... ' , p ( str2 % compact ()) write ( * , 101 ) 'compact(\"\") ................ ' , p ( str2 % compact ( \"\" )) write ( * , 101 ) 'compact(\":\") ............... ' , p ( str2 % compact ( \":\" )) ! calls M_strings procedure TRANSLITERATE () write ( * , 101 ) 'transliterate(\"aei\",\"VWX\") . ' , & & p ( str2 % transliterate ( \"aei\" , \"VWX\" )) write ( * , 101 ) 'transliterate(\"aeiou\",\" \") . ' , & & p ( str2 % transliterate ( \"aeiou\" , \" \" )) write ( * , 101 ) 'transliterate(\"aeiou\",\"\") .. ' , & & p ( str2 % transliterate ( \"aeiou\" , \"\" )) write ( * , 101 ) 'transliterate(\" aeiou\",\"\") . ' , & & p ( str2 % transliterate ( \" aeiou\" , \"\" )) ! calls M_strings procedure SWITCH () write ( * , 404 ) 'chars .................... . ' , str4 % chars () write ( * , * ) repeat ( '=' , 68 ) str2 % str = ' \\t\\t Some tabs \\t x \\b X ' write ( * , 101 ) 'str2 %s tr ................... ' , str2 % str write ( * , 101 ) 'expand ..................... ' , p ( str2 % expand ()) str2 = str2 % expand () ! calls M_strings procedure NOTABS () write ( * , 101 ) 'notabs ..................... ' , p ( str2 % notabs ()) ! calls M_strings procedure NOESC () write ( * , 101 ) 'noesc ...................... ' , p ( str2 % noesc ()) write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'Casting to numeric variables' str3 = string ( '   12.345678901234567e1        ' ) write ( * , 101 ) 'str3 %s tr ................... ' , str3 % str ! calls M_strings procedure STRING_TO_VALUE () write ( * , * ) 'int  ....................... ' , str3 % int () ! calls M_strings procedure STRING_TO_VALUE () write ( * , * ) 'real ....................... ' , str3 % real () ! calls M_strings procedure STRING_TO_VALUE () write ( * , * ) 'dble ....................... ' , str3 % dble () write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'Matching simple globbing patterns' str3 = string ( '   12.345678901234567e1        ' ) str3 = string ( 'Four score and seven years ago' ) write ( * , 101 ) 'str3 %s tr ................... ' , str3 % str ! calls M_strings procedure MATCHW write ( * , * ) 'match(\"Fo*\") ............... ' , str3 % match ( \"Fo*\" ) ! calls M_strings procedure MATCHW write ( * , * ) 'match(\"and\") ............... ' , str3 % match ( \"and\" ) ! calls M_strings procedure MATCHW write ( * , * ) 'match(\"*and*\") ............. ' , str3 % match ( \"*and*\" ) 101 format ( 1 x , a , \"[\" , a , \"]\" ) 202 format ( 1 x , a , i0 ) 303 format ( 1 x , * ( l3 )) 404 format ( 1 x , a , * ( \"[\" , a1 , \"]\" :)) write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))' str1 % str = '123.456' str2 % str = 'AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj' write ( * , 101 ) 'str1 %s tr ................... ' , str1 % str write ( * , 101 ) 'str2 %s tr ................... ' , str2 % str write ( * , * ) 'str1 + str2 ................ ' , p ( str1 + str2 ) ! a string that looks like a numeric value can have a value added write ( * , * ) 'str1 + 20000 ............... ' , p ( str1 + 20000 ) write ( * , * ) 'str1 - 20.0 ................ ' , p ( str1 - 20.0 ) write ( * , * ) 'str2 - \"Aa\" (removes ALL) .. ' , p ( str2 - 'Aa' ) write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'OVERLOADED OPERATORS (multiply,return TYPE(STRING))' str1 % str = 'AaBbCcDdEeFfGgHhIiJj' write ( * , 101 ) 'str1 %s tr ................... ' , str1 % str write ( * , * ) 'str1 * 2 ................... ' , p ( str1 * 2 ) write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'OVERLOADED OPERATORS (//,return TYPE(STRING))' str1 % str = 'String one:' str2 % str = 'String two:' write ( * , 101 ) 'str1 %s tr ................... ' , str1 % str write ( * , 101 ) 'str2 %s tr ................... ' , str2 % str write ( * , * ) 'str1 // str2 ................ ' , p ( str1 // str2 ) ! numeric values are converted to strings write ( * , * ) 'str1 // 20000 ............... ' , p ( str1 // 20000 ) write ( * , * ) 'str1 // 20.0 ................ ' , p ( str1 // 20.0 ) write ( * , * ) repeat ( '=' , 68 ) write ( * , * ) 'OVERLOADED OPERATORS (logical comparisons,return logical)' ! NOTE : comparisons are performed on the character variable members ! of the type ( string ) str1 % str = 'abcdefghij' str2 % str = 'klmnopqrst' write ( * , 101 ) 'str1 %s tr ................... ' , str1 % str write ( * , 101 ) 'str2 %s tr ................... ' , str2 % str write ( * , * ) ': EQ LT GT LE GE NE' write ( * , * ) 'compare str1 to str1' write ( * , 303 ) str1 == str1 , str1 < str1 , str1 > str1 , str1 <= str1 & & , str1 >= str1 , str1 /= str1 write ( * , * ) 'compare str1 to str2' write ( * , 303 ) str1 == str2 , str1 < str2 , str1 > str2 , str1 <= str2 & & , str1 >= str2 , str1 /= str2 write ( * , * ) 'compare str2 to str1' write ( * , 303 ) str2 == str1 , str2 < str1 , str2 > str1 , str2 <= str1 & & , str2 >= str1 , str2 /= str1 write ( * , * ) repeat ( '=' , 68 ) end program demo_M_strings_oop Expected output exercise the M_STRING_OOP module interface =================================================================== Call methods of type(STRING) =================================================================== str2%str is ................ [   This  is  a  String!             ] len ........................ 36 len_trim ................... 23 index(“is”)................. 6 index(“is”,back=.T.) ....... 10 upper ...................... [   THIS  IS  A  STRING!             ] lower ...................... [   this  is  a  string!             ] reverse .................... [             !gnirtS  a  si  sihT   ] adjustl .................... [This  is  a  String!                ] adjustr .................... [                This  is  a  String!] adjustc .................... [        This  is  a  String!        ] adjustc(40) ................ [              This  is  a  String!      ] lenset(40) ................. [   This  is  a  String!                 ] trim ....................... [   This  is  a  String!] crop ....................... [This  is  a  String!] substitute(“This”,”Here”) .. [   Here  is  a  String!             ] compact .................... [This is a String!] compact(“”) ................ [ThisisaString!] compact(“:”) ............... [This:is:a:String!] transliterate(“aei”,”VWX”) . [   ThXs  Xs  V  StrXng!             ] transliterate(“aeiou”,” “) . [   Th s   s     Str ng!             ] transliterate(“aeiou”,”“) .. [   Ths  s    Strng!                 ] transliterate(” aeiou”,”“) . [ThssStrng!                          ] chars .................... . [ ][a][ ][s][t][r][i][n][g][ ] =================================================================== str2%str ................... [\\t\\tSome tabs\\t   x\\bX ] expand ..................... [         Some tabs          x   X] notabs ..................... [                Some tabs          x    X] noesc ...................... [  Some tabs    x X] =================================================================== Casting to numeric variables str3%str ................... [   12.345678901234567e1        ] int  .......................          123 real .......................    123.456787 dble .......................    123.45678901234567 =================================================================== Matching simple globbing patterns str3%str ................... [Four score and seven years ago] match(“Fo*”) ...............  T match(“and”) ...............  F match(“ and ”) .............  T ==================================================================== OVERLOADED OPERATORS (add and subtract, return TYPE(STRING)) str1%str ................... [123.456] str2%str ................... [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj] str1 + str2 ................ 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj str1 + 20000 ............... 20123.455999999998 str1 - 20.0 ................ -103.456 str2 - “Aa” (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj =================================================================== OVERLOADED OPERATORS (multiply, return TYPE(STRING)) str1%str ................... [AaBbCcDdEeFfGgHhIiJj] str1 * 2 ................... AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj =================================================================== OVERLOADED OPERATORS (//, return TYPE(STRING)) str1%str ................... [String one:] str2%str ................... [String two:] str1 // str2 ................ String one:String two: str1 // 20000 ............... String one:20000 str1 // 20.0 ................ String one:20.0 =================================================================== OVERLOADED OPERATORS (logical comparisons, return logical) str1%str ................... [abcdefghij] str2%str ................... [klmnopqrst] EQ LT GT LE GE NE compare str1 to str1 T  F  F  T  T  F compare str1 to str2 F  T  F  T  F  T compare str2 to str1 F  F  T  F  T  T\n   =================================================================== AUTHOR John S. Urban LICENSE Public Domain Uses M_strings Contents Interfaces string Derived Types string Functions p Interfaces public        interface string private  function construct_from_fill(chars, len) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: chars integer, intent(in), optional :: len Return Value type( string ) Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Constructor private\n\n                    \n                    function construct_from_fill (chars, len) Type-Bound Procedures procedure\n                    ,                  public\n                  :: adjustc =>\n                    oop_adjustc Function procedure\n                    ,                  public\n                  :: adjustl =>\n                    oop_adjustl Function procedure\n                    ,                  public\n                  :: adjustr =>\n                    oop_adjustr Function procedure\n                    ,                  public\n                  :: chars =>\n                    oop_switch Function procedure\n                    ,                  public\n                  :: compact =>\n                    oop_compact Function procedure\n                    ,                  public\n                  :: cpad =>\n                    oop_cpad Function procedure\n                    ,                  public\n                  :: crop =>\n                    oop_crop Function procedure\n                    ,                  public\n                  :: dble =>\n                    oop_dble Function procedure\n                    ,                  public\n                  :: expand =>\n                    oop_expand Function procedure\n                    ,                  public\n                  :: index =>\n                    oop_index Function procedure\n                    ,                  public\n                  :: init =>\n                    init_string Subroutine procedure\n                    ,                  public\n                  :: int =>\n                    oop_int Function procedure\n                    ,                  public\n                  :: len =>\n                    oop_len Function procedure\n                    ,                  public\n                  :: len_trim =>\n                    oop_len_trim Function procedure\n                    ,                  public\n                  :: lenset =>\n                    oop_lenset Function procedure\n                    ,                  public\n                  :: lower =>\n                    oop_lower Function procedure\n                    ,                  public\n                  :: lpad =>\n                    oop_lpad Function procedure\n                    ,                  public\n                  :: match =>\n                    oop_matchw Function procedure\n                    ,                  public\n                  :: noesc =>\n                    oop_noesc Function procedure\n                    ,                  public\n                  :: notabs =>\n                    oop_notabs Function generic,\n                  public\n                  :: operator(*) =>\n                    string_multiply_value generic,\n                  public\n                  :: operator(+) =>\n                    string_plus_value generic,\n                  public\n                  :: operator(-) =>\n                    string_minus_value generic,\n                  public\n                  :: operator(//) =>\n                    string_append_value generic,\n                  public\n                  :: operator(/=) =>\n                    ne generic,\n                  public\n                  :: operator(<) =>\n                    lt generic,\n                  public\n                  :: operator(<=) =>\n                    le generic,\n                  public\n                  :: operator(==) =>\n                    eq generic,\n                  public\n                  :: operator(>) =>\n                    gt generic,\n                  public\n                  :: operator(>=) =>\n                    ge procedure\n                    ,                  public\n                  :: pad =>\n                    oop_pad Function procedure\n                    ,                  public\n                  :: real =>\n                    oop_real Function procedure\n                    ,                  public\n                  :: reverse =>\n                    oop_reverse Function procedure\n                    ,                  public\n                  :: rpad =>\n                    oop_rpad Function procedure\n                    ,                  public\n                  :: substitute =>\n                    oop_substitute Function procedure\n                    ,                  public\n                  :: transliterate =>\n                    oop_transliterate Function procedure\n                    ,                  public\n                  :: trim =>\n                    oop_trim Function procedure\n                    ,                  public\n                  :: upper =>\n                    oop_upper Function procedure\n                    ,                  public\n                  :: zpad =>\n                    oop_zpad Function Functions public  function p (self) result(string_out) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self Return Value character(len=len)","tags":"","loc":"module/m_strings_oop.html"},{"title":"M_strings.F90 – M_strings","text":"Contents Modules M_strings Source Code M_strings.F90 Source Code MODULE M_strings ! use , intrinsic :: iso_fortran_env , only : ERROR_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : output_unit , stderr => error_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none ! change default for every procedure contained in the module private public split !  subroutine parses a string using specified delimiter characters and store tokens into an allocatable array public sep !  function interface to split public chomp !  function consumes input line as it returns next token in a string using specified delimiters public delim !  subroutine parses a string using specified delimiter characters and store tokens into an array public strtok !  gets next token. Used by change(3f) public paragraph !  convert a long string into a paragraph public substitute !  subroutine non-recursively globally replaces old substring with new substring in string public replace !  function non-recursively globally replaces old substring with new substring in string public change !  replaces old substring with new substring in string with a directive like a line editor public modif !  change string using a directive using rules similar to XEDIT line editor MODIFY command public transliterate !  when characters in set one are found replace them with characters from set two public reverse !  elemental function reverses character order in a string public join !  append an array of character variables with specified separator into a single CHARACTER variable public squeeze !  delete adjacent duplicate characters from a string public rotate13 !  apply trivial encryption algorithm ROT13 to string public switch !  generic switch between a string and an array of single characters (a2s,s2a) private a2s !  function to copy char array to string private s2a !  function to copy string(1:Clen(string)) to char array public s2c !  convert character variable to array of character(len=1) with null terminator for C compatibility public c2s !  convert null-terminated array of character(len=1) to string for strings returned by C public upper !  elemental function converts string to uppercase public lower !  elemental function converts string to miniscule public upper_quoted !  elemental function converts string to miniscule skipping strings quoted per Fortran syntax rules public adjustc !  elemental function centers string within the length of the input string public compact !  left justify string and replace duplicate whitespace with single characters or nothing public nospace !  function replaces whitespace with nothing public indent !  count number of leading spaces public crop !  function trims leading and trailing spaces and control characters public clip !  function trims leading and trailing spaces public matching_delimiter !  find position of matching delimiter public unquote !  remove quotes from string as if read with list-directed input public quote !  add quotes to string as if written with list-directed input public lenset !  return a string as specified length public pad !  return a string of at least specified length public zpad !  return a string of at least specified length padded on left with zeros public lpad !  convert value to a string of at least specified length padded on left with zeros public cpad !  convert value to a centered string of at least specified length public rpad !  convert value to a string of at least specified length padded on right with zeros public stretch !  return a string of at least specified length with suffix public merge_str !  make strings of equal length and then call MERGE(3f) intrinsic public len_white !  find location of last non-whitespace character public noesc !  elemental function converts non-printable ASCII8 characters to a space public notabs !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters public dilate !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters public expand !  expand escape sequences in a string public visible !  expand escape sequences in a string to control and meta-control representations public string_to_value !  generic subroutine returns REAL|DOUBLEPRECISION|INTEGER value from string (a2d,a2r,a2i) private a2d !  subroutine returns double value from string private a2r !  subroutine returns real value from string private a2i !  subroutine returns integer value from string public string_to_values !  subroutine returns values from a string public getvals !  subroutine returns values from a string public s2v !  function returns doubleprecision value from string public s2vs !  function returns a doubleprecision array of numbers from a string !------------------------------------------------------------------------------------------------------------ public msg !  function returns a string representing up to nine scalar intrinsic values public value_to_string !  generic subroutine returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value public v2s !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value private d2s !  function returns string from doubleprecision value private r2s !  function returns string from real value private i2s !  function returns string from integer value private l2s !  function returns string from logical value public v2s_bug !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER value public isnumber !  determine if string represents a number private trimzeros_ !  Delete trailing zeros from numeric decimal string public listout !  expand a list of numbers where  negative numbers denote range ends (1 -10 means 1 thru 10) public int , real , dble , nint interface int ; module procedure int_s2v ; end interface interface real ; module procedure real_s2v ; end interface interface dble ; module procedure dble_s2v ; end interface interface nint ; module procedure nint_s2v ; end interface public setbits8 !  use a string representing a positive binary value to fill the bits of an INTEGER value public setbits16 !  use a string representing a positive binary value to fill the bits of an INTEGER value public setbits32 !  use a string representing a positive binary value to fill the bits of an INTEGER value public setbits64 !  use a string representing a positive binary value to fill the bits of an INTEGER value public base !  convert whole number string in base [2-36] to string in alternate base [2-36] public codebase !  convert whole number string in base [2-36] to base 10 number public decodebase !  convert whole number in base 10 to string in base [2-36] public base2 !  convert INTEGER to a string representing a binary value public glob !  compares given string for match to pattern which may contain wildcard characters public ends_with !  test whether strings ends with one of the specified suffix public isalnum !  elemental function returns .true. if CHR is a letter or digit public isalpha !  elemental function returns .true. if CHR is a letter and .false. otherwise public isascii !  elemental function returns .true. if the low order byte of c is in the range char(0) to char(127) public isblank !  elemental function returns .true. if CHR is a blank character (space or horizontal tab. public iscntrl !  elemental function returns .true. if CHR is a delete character or ordinary control character public isdigit !  elemental function returns .true. if CHR is a digit (0,1,...,9) and .false. otherwise public isgraph !  elemental function true if CHR is an ASCII printable character except considers a space non-printable public islower !  elemental function returns .true. if CHR is a miniscule letter (a-z) public isprint !  elemental function determines if CHR is an ASCII printable character public ispunct !  elemental function returns .true. if CHR is a printable punctuation character public isspace !  elemental function true if CHR is a null, space, tab, carriage return, new line, vertical tab, or formfeed public isupper !  elemental function returns .true. if CHR is an uppercase letter (A-Z) public isxdigit !  elemental function returns .true. if CHR is a hexadecimal digit (0-9, a-f, or A-F). public fortran_name !  elemental function returns .true. if LINE is a valid Fortran name public describe !  returns a string describing character public edit_distance !  returns a naive edit distance using the Levenshtein distance algorithm public bundle !  return up to twenty strings of arbitrary length as an array public longest_common_substring !  function that returns the longest common substring of two strings. interface switch module procedure a2s , s2a end interface switch interface string_to_value module procedure a2d , a2r , a2i end interface interface v2s module procedure d2s , r2s , i2s , l2s end interface interface msg module procedure msg_scalar , msg_one end interface msg character , public , parameter :: ascii_nul = char ( 0 ) ! null character , public , parameter :: ascii_bel = char ( 7 ) ! bell character , public , parameter :: ascii_bs = char ( 8 ) ! backspace character , public , parameter :: ascii_ht = char ( 9 ) ! horizontal tab character , public , parameter :: ascii_lf = char ( 10 ) ! line feed or newline character , public , parameter :: ascii_ff = char ( 12 ) ! form feed or newpage character , public , parameter :: ascii_cr = char ( 13 ) ! carriage return character , public , parameter :: ascii_esc = char ( 27 ) ! escape interface ends_with procedure :: ends_with_str procedure :: ends_with_any end interface ends_with public :: split2020 , string_tokens public :: find_field interface split2020 module procedure :: split_tokens , split_first_last , split_pos end interface split2020 interface journal module procedure flush_trail ! journal()                ! no options module procedure write_message_only ! journal(c)               ! must have one string module procedure where_write_message_all ! journal(where,[g1-g9])   ! must have two strings module procedure set_stdout_lun ! journal(i)               ! first is not a string end interface journal interface str module procedure str_scalar , str_one end interface str integer , save , private :: stdout = OUTPUT_UNIT logical , save :: debug = . false . integer , save :: last_int = 0 interface matchw ; module procedure glob ; end interface interface atleast ; module procedure pad ; end interface interface cc ; module procedure bundle ; end interface public matchw !  clone of glob -- for backward compatibiity public atleast !  clone of pad -- for backward compatibiity public cc !  clone of pad -- for backward compatibiity CONTAINS function glob ( tame , wild ) logical :: glob character ( len =* ) :: tame ! A string without wildcards character ( len =* ) :: wild ! A (potentially) corresponding string with wildcards character ( len = len ( tame ) + 1 ) :: tametext character ( len = len ( wild ) + 1 ) :: wildtext character ( len = 1 ), parameter :: NULL = char ( 0 ) integer :: wlen integer :: ti , wi integer :: i character ( len = :), allocatable :: tbookmark , wbookmark tametext = tame // NULL wildtext = wild // NULL tbookmark = NULL wbookmark = NULL wlen = len ( wild ) wi = 1 ti = 1 do ! Walk the text strings one character at a time. if ( wildtext ( wi : wi ) == '*' ) then ! How do you match a unique text string? do i = wi , wlen ! Easy: unique up on it! if ( wildtext ( wi : wi ) == '*' ) then wi = wi + 1 else exit endif enddo if ( wildtext ( wi : wi ) == NULL ) then ! \"x\" matches \"*\" glob = . true . return endif if ( wildtext ( wi : wi ) /= '?' ) then ! Fast-forward to next possible match. do while ( tametext ( ti : ti ) /= wildtext ( wi : wi )) ti = ti + 1 if ( tametext ( ti : ti ) == NULL ) then glob = . false . return ! \"x\" doesn't match \"*y*\" endif enddo endif wbookmark = wildtext ( wi :) tbookmark = tametext ( ti :) elseif ( tametext ( ti : ti ) /= wildtext ( wi : wi ) . and . wildtext ( wi : wi ) /= '?' ) then ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry. if ( wbookmark /= NULL ) then if ( wildtext ( wi :) /= wbookmark ) then wildtext = wbookmark wlen = len_trim ( wbookmark ) wi = 1 ! Don't go this far back again. if ( tametext ( ti : ti ) /= wildtext ( wi : wi )) then tbookmark = tbookmark ( 2 :) tametext = tbookmark ti = 1 cycle ! \"xy\" matches \"*y\" else wi = wi + 1 endif endif if ( tametext ( ti : ti ) /= NULL ) then ti = ti + 1 cycle ! \"mississippi\" matches \"*sip*\" endif endif glob = . false . return ! \"xy\" doesn't match \"x\" endif ti = ti + 1 wi = wi + 1 if ( ti > len ( tametext )) then glob = . false . return elseif ( tametext ( ti : ti ) == NULL ) then ! How do you match a tame text string? if ( wildtext ( wi : wi ) /= NULL ) then do while ( wildtext ( wi : wi ) == '*' ) ! The tame way: unique up on it! wi = wi + 1 ! \"x\" matches \"x*\" if ( wildtext ( wi : wi ) == NULL ) exit enddo endif if ( wildtext ( wi : wi ) == NULL ) then glob = . true . return ! \"x\" matches \"x\" endif glob = . false . return ! \"x\" doesn't match \"xy\" endif enddo end function glob pure function ends_with_str ( string , ending ) result ( matched ) character ( * ), intent ( in ) :: string , ending integer :: n1 , n2 logical :: matched n1 = len ( string ) - len ( ending ) + 1 n2 = len ( string ) if ( n1 < 1 ) then matched = . false . else matched = ( string ( n1 : n2 ) == ending ) endif end function ends_with_str pure function ends_with_any ( string , endings ) result ( matched ) character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: endings (:) logical :: matched integer :: i matched = . true . FINDIT : block do i = 1 , size ( endings ) if ( ends_with_str ( string , trim ( endings ( i )))) exit FINDIT enddo matched = . false . endblock FINDIT end function ends_with_any function sep ( input_line , delimiters , nulls , order ) intrinsic index , min , present , len character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len =* ), optional , intent ( in ) :: order ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable :: sep (:) ! output array of tokens integer :: isize call split ( input_line , sep , delimiters , 'right' , nulls ) if ( present ( order )) then select case ( order ) case ( 'ascending' , 'ASCENDING' ) isize = size ( sep ) if ( isize > 1 ) then sep = sep ( isize : 1 : - 1 ) endif end select endif end function sep subroutine split ( input_line , array , delimiters , order , nulls ) intrinsic index , min , present , len character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: lgth ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter if ( allocated ( ibegin )) deallocate ( ibegin ) !x! intel compiler says allocated already ? if ( allocated ( iterm )) deallocate ( iterm ) !x! intel compiler says allocated already ? allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 lgth = len ( input_line ) ! lgth is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found if ( lgth > 0 ) then ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , lgth , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = lgth ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): lgth ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > lgth ) then ! no text left exit INFINITE endif enddo INFINITE endif select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to return select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split FUNCTION chomp ( source_string , token , delimiters ) character ( len =* ) :: source_string ! string to tokenize character ( len = :), allocatable , intent ( out ) :: token ! returned token character ( len =* ), intent ( in ), optional :: delimiters ! list of separator characters integer :: chomp ! returns copy of shifted source_string character ( len = :), allocatable :: delimiters_local integer :: token_start ! beginning of token found if function result is .true. integer :: token_end ! end of token found if function result is .true. integer :: isource_len if ( present ( delimiters )) then delimiters_local = delimiters else ! increment start to previous end + 1 delimiters_local = char ( 32 ) // char ( 09 ) // char ( 10 ) // char ( 13 ) ! space,horizontal tab, newline, carriage return endif isource_len = len ( source_string ) ! length of input string ! find beginning of token token_start = 1 do while ( token_start <= isource_len ) ! step thru each character to find next delimiter, if any if ( index ( delimiters_local , source_string ( token_start : token_start )) /= 0 ) then token_start = token_start + 1 else exit endif enddo token_end = token_start do while ( token_end <= isource_len - 1 ) ! step thru each character to find next delimiter, if any if ( index ( delimiters_local , source_string ( token_end + 1 : token_end + 1 )) /= 0 ) then ! found a delimiter in next character exit endif token_end = token_end + 1 enddo !write(*,*)'TOKEN_START ',token_start !write(*,*)'TOKEN_END   ',token_end chomp = isource_len - token_end if ( chomp >= 0 ) then token = source_string ( token_start : token_end ) source_string = source_string ( token_end + 1 :) else token = '' source_string = '' endif end function chomp subroutine delim ( line , array , n , icount , ibegin , iterm , lgth , dlim ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: n character ( len =* ) :: array ( n ) integer , intent ( out ) :: icount integer , intent ( out ) :: ibegin ( n ) integer , intent ( out ) :: iterm ( n ) integer , intent ( out ) :: lgth character ( len =* ), intent ( in ) :: dlim character ( len = len ( line )) :: line_local logical :: lstore integer :: i10 integer :: iarray integer :: icol integer :: idlim integer :: iend integer :: ifound integer :: istart icount = 0 lgth = len_trim ( line ) line_local = line idlim = len ( dlim ) if ( idlim > 5 ) then idlim = len_trim ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( idlim == 0 ) then idlim = 1 ! blank string endif endif if ( lgth == 0 ) then ! command was totally blank return endif icol = 1 if ( array ( 1 ) == '#N#' ) then ! special flag to not store into character array lstore = . false . else lstore = . true . endif do iarray = 1 , n , 1 ! store into each array element until done or too many words NOINCREMENT : do if ( index ( dlim ( 1 : idlim ), line_local ( icol : icol )) == 0 ) then ! if current character is not a delimiter istart = icol ! start new token on the non-delimiter character ibegin ( iarray ) = icol iend = lgth - istart + 1 + 1 ! assume no delimiters so put past end of line do i10 = 1 , idlim ifound = index ( line_local ( istart : lgth ), dlim ( i10 : i10 )) if ( ifound > 0 ) then iend = min ( iend , ifound ) endif enddo if ( iend <= 0 ) then ! no remaining delimiters iterm ( iarray ) = lgth if ( lstore ) then array ( iarray ) = line_local ( istart : lgth ) endif icount = iarray return else iend = iend + istart - 2 iterm ( iarray ) = iend if ( lstore ) then array ( iarray ) = line_local ( istart : iend ) endif endif icol = iend + 2 exit NOINCREMENT endif icol = icol + 1 enddo NOINCREMENT if ( icol > lgth ) then icount = iarray if ( ( iterm ( icount ) - ibegin ( icount )) < 0 ) then ! last token was all delimiters icount = icount - 1 endif return endif enddo icount = n ! more than n elements end subroutine delim subroutine crack_cmd ( cmd , old , new , ierr ) character ( len =* ), intent ( in ) :: cmd character ( len = :), allocatable , intent ( out ) :: old , new ! scratch string buffers integer :: ierr character ( len = 1 ) :: delimiters integer :: itoken integer , parameter :: id = 2 ! expected location of delimiter logical :: ifok integer :: lmax ! length of target string integer :: start_token , end_token ierr = 0 old = '' new = '' lmax = len_trim ( cmd ) ! significant length of change directive if ( lmax >= 4 ) then ! strtok ignores blank tokens so look for special case where first token is really null delimiters = cmd ( id : id ) ! find delimiter in expected location itoken = 0 ! initialize strtok(3f) procedure if ( strtok ( cmd ( id :), itoken , start_token , end_token , delimiters )) then ! find OLD string old = cmd ( start_token + id - 1 : end_token + id - 1 ) else old = '' endif if ( cmd ( id : id ) == cmd ( id + 1 : id + 1 )) then new = old old = '' else ! normal case ifok = strtok ( cmd ( id :), itoken , start_token , end_token , delimiters ) ! find NEW string if ( end_token == ( len ( cmd ) - id + 1 ) ) end_token = len_trim ( cmd ( id :)) ! if missing ending delimiter new = cmd ( start_token + id - 1 : min ( end_token + id - 1 , lmax )) endif else ! command was two or less characters ierr =- 1 call journal ( 'sc' , '*crack_cmd* incorrect change directive -too short' ) endif end subroutine crack_cmd function replace ( targetline , old , new , cmd , occurrence , repeat , ignorecase , ierr ) result ( newline ) character ( len =* ), intent ( in ) :: targetline ! input line to be changed character ( len =* ), intent ( in ), optional :: old ! old substring to replace character ( len =* ), intent ( in ), optional :: new ! new substring character ( len =* ), intent ( in ), optional :: cmd ! contains the instructions changing the string integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made character ( len = :), allocatable :: newline ! output string buffer character ( len = :), allocatable :: new_local , old_local , old_local_for_comparison integer :: icount , ichange , ier2 integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: left_margin , right_margin integer :: ind integer :: ic integer :: ichr integer :: range_local ( 2 ) character ( len = :), allocatable :: targetline_for_comparison ! input line to be changed logical :: ignorecase_local logical :: flip character ( len = :), allocatable :: targetline_local ! input line to be changed flip = . false . ignorecase_local = . false . original_input_length = len_trim ( targetline ) ! get non-blank length of input line if ( present ( cmd )) then call crack_cmd ( cmd , old_local , new_local , ier2 ) if ( ier2 /= 0 ) then newline = targetline ! if no changes are made return original string on error if ( present ( ierr )) ierr = ier2 return endif elseif ( present ( old ). and . present ( new )) then old_local = old new_local = new else newline = targetline ! if no changes are made return original string on error call journal ( 'sc' , '*replace* must specify OLD and NEW or CMD' ) return endif if ( present ( ignorecase )) then ignorecase_local = ignorecase else ignorecase_local = . false . endif if ( present ( occurrence )) then range_local ( 1 ) = abs ( occurrence ) else range_local ( 1 ) = 1 endif if ( present ( repeat )) then range_local ( 2 ) = range_local ( 1 ) + repeat - 1 else range_local ( 2 ) = original_input_length endif if ( ignorecase_local ) then targetline_for_comparison = lower ( targetline ) old_local_for_comparison = lower ( old_local ) else targetline_for_comparison = targetline old_local_for_comparison = old_local endif if ( present ( occurrence )) then if ( occurrence < 0 ) then flip = . true . targetline_for_comparison = reverse ( targetline_for_comparison ) targetline_local = reverse ( targetline ) old_local_for_comparison = reverse ( old_local_for_comparison ) old_local = reverse ( old_local ) new_local = reverse ( new_local ) else targetline_local = targetline endif else targetline_local = targetline endif icount = 0 ! initialize error flag/change count ichange = 0 ! initialize error flag/change count len_old = len ( old_local ) ! length of old substring to be replaced len_new = len ( new_local ) ! length of new substring to replace old substring left_margin = 1 ! left_margin is left margin of window to change right_margin = len ( targetline ) ! right_margin is right margin of window to change newline = '' ! begin with a blank line as output string if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichr = len_new + original_input_length if ( len_new > 0 ) then newline = new_local (: len_new ) // targetline_local ( left_margin : original_input_length ) else newline = targetline_local ( left_margin : original_input_length ) endif ichange = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ichange if ( flip ) newline = reverse ( newline ) return endif ichr = left_margin ! place to put characters into output string ic = left_margin ! place looking at in input string loop : do ! try finding start of OLD in remaining part of input in change window ind = index ( targetline_for_comparison ( ic :), old_local_for_comparison (: len_old )) + ic - 1 if ( ind == ic - 1. or . ind > right_margin ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif icount = icount + 1 ! found an old string to change, so increment count of change candidates if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output newline = newline (: ichr - 1 ) // targetline_local ( ic : ind - 1 ) ichr = ichr + ladd endif if ( icount >= range_local ( 1 ). and . icount <= range_local ( 2 )) then ! check if this is an instance to change or keep ichange = ichange + 1 if ( len_new /= 0 ) then ! put in new string newline = newline (: ichr - 1 ) // new_local (: len_new ) ichr = ichr + len_new endif else if ( len_old /= 0 ) then ! put in copy of old string newline = newline (: ichr - 1 ) // old_local (: len_old ) ichr = ichr + len_old endif endif ic = ind + len_old enddo loop select case ( ichange ) case ( 0 ) ! there were no changes made to the window newline = targetline_local ! if no changes made output should be input case default if ( ic <= len ( targetline )) then ! if there is more after last change on original line add it newline = newline (: ichr - 1 ) // targetline_local ( ic : max ( ic , original_input_length )) endif end select if ( present ( ierr )) ierr = ichange if ( flip ) newline = reverse ( newline ) end function replace subroutine substitute ( targetline , old , new , ierr , start , end ) character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichr if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option ! change to optional parameter(s) len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id <= 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichr = len_new + original_input_length if ( ichr > maxlengthout ) then call journal ( 'sc' , '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new > 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif ichr = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind == ic - 1. or . ind > ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichr - 1 + ladd > maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichr :) = targetline ( ic : ind - 1 ) ichr = ichr + ladd endif if ( ichr - 1 + len_new > maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new /= 0 ) then dum1 ( ichr :) = new (: len_new ) ichr = ichr + len_new endif ic = ind + len_old enddo loop select case ( ier1 ) case (: - 1 ) call journal ( 'sc' , '*substitute* new line will be too long' ) case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichr + ladd > maxlengthout ) then call journal ( 'sc' , '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic < len ( targetline )) then dum1 ( ichr :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 end subroutine substitute subroutine change ( target_string , cmd , ierr ) character ( len =* ), intent ( inout ) :: target_string ! line to be changed character ( len =* ), intent ( in ) :: cmd ! contains the instructions changing the string character ( len = 1 ) :: delimiters integer :: ierr ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made integer :: itoken integer , parameter :: id = 2 ! expected location of delimiter character ( len = :), allocatable :: old , new ! scratch string buffers logical :: ifok integer :: lmax ! length of target string integer :: start_token , end_token lmax = len_trim ( cmd ) ! significant length of change directive if ( lmax >= 4 ) then ! strtok ignores blank tokens so look for special case where first token is really null delimiters = cmd ( id : id ) ! find delimiter in expected location itoken = 0 ! initialize strtok(3f) procedure if ( strtok ( cmd ( id :), itoken , start_token , end_token , delimiters )) then ! find OLD string old = cmd ( start_token + id - 1 : end_token + id - 1 ) else old = '' endif if ( cmd ( id : id ) == cmd ( id + 1 : id + 1 )) then new = old old = '' else ! normal case ifok = strtok ( cmd ( id :), itoken , start_token , end_token , delimiters ) ! find NEW string if ( end_token == ( len ( cmd ) - id + 1 ) ) end_token = len_trim ( cmd ( id :)) ! if missing ending delimiter new = cmd ( start_token + id - 1 : min ( end_token + id - 1 , lmax )) endif call substitute ( target_string , old , new , ierr , 1 , len_trim ( target_string )) ! change old substrings to new substrings else ! command was two or less characters ierr =- 1 call journal ( 'sc' , '*change* incorrect change directive -too short' ) endif end subroutine change FUNCTION strtok ( source_string , itoken , token_start , token_end , delimiters ) result ( strtok_status ) character ( len =* ), intent ( in ) :: source_string ! Source string to tokenize. character ( len =* ), intent ( in ) :: delimiters ! list of separator characters. May change between calls integer , intent ( inout ) :: itoken ! token count since started logical :: strtok_status ! returned value integer , intent ( out ) :: token_start ! beginning of token found if function result is .true. integer , intent ( inout ) :: token_end ! end of token found if function result is .true. integer , save :: isource_len if ( itoken <= 0 ) then ! this is assumed to be the first call token_start = 1 else ! increment start to previous end + 1 token_start = token_end + 1 endif isource_len = len ( source_string ) ! length of input string if ( token_start > isource_len ) then ! user input error or at end of string token_end = isource_len ! assume end of token is end of string until proven otherwise so it is set strtok_status = . false . return endif ! find beginning of token do while ( token_start <= isource_len ) ! step thru each character to find next delimiter, if any if ( index ( delimiters , source_string ( token_start : token_start )) /= 0 ) then token_start = token_start + 1 else exit endif enddo token_end = token_start do while ( token_end <= isource_len - 1 ) ! step thru each character to find next delimiter, if any if ( index ( delimiters , source_string ( token_end + 1 : token_end + 1 )) /= 0 ) then ! found a delimiter in next character exit endif token_end = token_end + 1 enddo if ( token_start > isource_len ) then ! determine if finished strtok_status = . false . ! flag that input string has been completely processed else itoken = itoken + 1 ! increment count of tokens found strtok_status = . true . ! flag more tokens may remain endif end function strtok subroutine modif ( cline , mod ) character ( len =* ) :: cline !STRING TO BE MODIFIED character ( len =* ), intent ( in ) :: mod !STRING TO DIRECT MODIFICATION character ( len = len ( cline )) :: cmod character ( len = 3 ), parameter :: c = '#&&#94;' !ASSIGN DEFAULT EDIT CHARACTERS integer :: maxscra !LENGTH OF SCRATCH BUFFER character ( len = len ( cline )) :: dum2 !SCRATCH CHARACTER BUFFER logical :: linsrt !FLAG FOR INSERTING DATA ON LINE integer :: i , j , ic , ichr , iend , lmax , lmx1 maxscra = len ( cline ) cmod = trim ( mod ) lmax = min0 ( len ( cline ), maxscra ) !DETERMINE MAXIMUM LINE LENGTH lmx1 = lmax - 1 !MAX LINE LENGTH -1 dum2 = ' ' !INITIALIZE NEW LINE linsrt = . false . !INITIALIZE INSERT MODE iend = len_trim ( cmod ) !DETERMINE END OF MODS i = 0 !CHAR COUNTER FOR MOD LINE CMOD ic = 0 !CHAR COUNTER FOR CURRENT LINE CLINE ichr = 0 !CHAR COUNTER NEW LINE DUM2 11 continue i = i + 1 !NEXT CHAR IN MOD LINE if ( ichr > lmx1 ) goto 999 !IF TOO MANY CHARS IN NEW LINE if ( linsrt ) then !IF INSERTING NEW CHARS if ( i > iend ) cmod ( i : i ) = c ( 1 : 1 ) !FORCE END OF INSERT MODE if ( cmod ( i : i ) == c ( 1 : 1 )) then !IF END OF INSERT MODE linsrt = . false . !RESET INSERT MODE FLAG if ( ic + 1 == i ) then !NULL INSERT STRING ichr = ichr + 1 !INCREMENT COUNTER FOR NEW LINE dum2 ( ichr : ichr ) = c ( 1 : 1 ) !INSERT INSERT MODE TERMINATOR endif do j = ic , i !LOOP OF NUMBER OF CHARS INSERTED ichr = ichr + 1 !INCREMENT COUNTER FOR NEW LINE if ( ichr > lmax ) goto 999 !IF AT BUFFER LIMIT, QUIT dum2 ( ichr : ichr ) = cline ( j : j ) !APPEND CHARS FROM ORIG LINE enddo !...WHICH ALIGN WITH INSERTED CHARS ic = i !RESET CHAR COUNT TO END OF INSERT goto 1 !CHECK NEW LINE LENGTH AND CYCLE endif !END OF TERMINATED INSERT LOGIC ichr = ichr + 1 !INCREMENT NEW LINE COUNT dum2 ( ichr : ichr ) = cmod ( i : i ) !SET NEWLINE CHAR TO INSERTED CHAR else !IF NOT INSERTING CHARACTERS ic = ic + 1 !INCREMENT ORIGINAL LINE COUNTER if ( cmod ( i : i ) == c ( 1 : 1 )) goto 1 !IF DELETE CHAR. NO COPY AND CYCLE if ( cmod ( i : i ) == c ( 3 : 3 )) then !IF BEGIN INSERT MODE linsrt = . true . !SET INSERT FLAG TRUE goto 1 !CHECK LINE LENGTH AND CONTINUE endif !IF NOT BEGINNING INSERT MODE ichr = ichr + 1 !INCREMENT NEW LINE COUNTER if ( cmod ( i : i ) == c ( 2 : 2 )) then !IF REPLACE WITH BLANK dum2 ( ichr : ichr ) = ' ' !SET NEWLINE CHAR TO BLANK goto 1 !CHECK LINE LENGTH AND CYCLE endif !IF NOT REPLACE WITH BLANK if ( cmod ( i : i ) == ' ' ) then !IF BLANK, KEEP ORIGINAL CHARACTER dum2 ( ichr : ichr ) = cline ( ic : ic ) !SET NEW CHAR TO ORIGINAL CHAR else !IF NOT KEEPING OLD CHAR dum2 ( ichr : ichr ) = cmod ( i : i ) !REPLACE ORIGINAL CHAR WITH NEW endif !END CHAR KEEP OR REPLACE endif !END INSERT OR NO-INSERT 1 continue if ( i < lmax ) goto 11 !CHECK FOR END OF LINE REACHED !AND CYCLE IF OK 999 continue cline = dum2 !SET ORIGINAL CHARS TO NEW CHARS end subroutine modif !RETURN elemental integer function len_white ( string ) character ( len =* ), intent ( in ) :: string ! input string to determine length of integer :: i10 intrinsic len len_white = 0 do i10 = len ( string ), 1 , - 1 select case ( string ( i10 : i10 )) case ( ' ' ) ! space(32) case ( char ( 0 )) ! null(0) case ( char ( 9 ): char ( 13 )) ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13) case default len_white = i10 exit end select enddo end function len_white function crop ( strin ) result ( strout ) character ( len =* ), intent ( in ) :: strin character ( len = :), allocatable :: strout strout = trim ( adjustl ( noesc ( dilate ( strin )))) end function crop function clip ( string ) result ( lopped ) logical , parameter :: T = . true ., F = . false . character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: lopped integer :: ends ( 2 ) ends = verify ( string , \" \" , [ F , T ] ) if ( ends ( 1 ) == 0 ) then lopped = \"\" else lopped = string ( ends ( 1 ): ends ( 2 )) endif end function clip PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj jj = LEN ( new_set ) IF ( jj /= 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii /= 0 ) THEN if ( ii <= jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii == 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate function rotate13 ( input ) implicit none character ( len =* ), intent ( in ) :: input character ( len = len ( input )) :: rotate13 integer :: itemp integer :: i rotate13 = ' ' do i = 1 , len_trim ( input ) itemp = iachar ( input ( i : i )) select case ( itemp ) case ( 65 : 77 , 97 : 109 ) itemp = itemp + 13 case ( 78 : 90 , 110 : 122 ) itemp = itemp - 13 end select rotate13 ( i : i ) = char ( itemp ) enddo end function rotate13 pure function join ( str , sep , trm , left , right , start , end ) result ( string ) character ( len =* ), intent ( in ) :: str (:) character ( len =* ), intent ( in ), optional :: sep , right , left , start , end logical , intent ( in ), optional :: trm character ( len = :), allocatable :: sep_local , left_local , right_local character ( len = :), allocatable :: string logical :: trm_local integer :: i if ( present ( sep )) then ; sep_local = sep ; else ; sep_local = '' ; endif if ( present ( trm )) then ; trm_local = trm ; else ; trm_local = . true . ; endif if ( present ( left )) then ; left_local = left ; else ; left_local = '' ; endif if ( present ( right )) then ; right_local = right ; else ; right_local = '' ; endif string = '' if ( size ( str ) == 0 ) then string = string // left_local // right_local else do i = 1 , size ( str ) - 1 if ( trm_local ) then string = string // left_local // trim ( str ( i )) // right_local // sep_local else string = string // left_local // str ( i ) // right_local // sep_local endif enddo if ( trm_local ) then string = string // left_local // trim ( str ( i )) // right_local else string = string // left_local // str ( i ) // right_local endif endif if ( present ( start )) string = start // string if ( present ( end )) string = string // end end function join elemental function reverse ( string ) result ( rev ) character ( len =* ), intent ( in ) :: string ! string to reverse character ( len = len ( string )) :: rev ! return value (reversed string) integer :: length integer :: i length = len ( string ) do i = 1 , length rev ( i : i ) = string ( length - i + 1 : length - i + 1 ) enddo end function reverse elemental pure function upper_quoted ( str ) result ( string ) character ( len =* ), intent ( in ) :: str ! The input string character ( len = len ( str )) :: string ! The output string logical :: toggle character ( len = 1 ) :: togglechar integer :: irnk integer :: i character ( len = 26 ), parameter :: large = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len = 26 ), parameter :: small = \"abcdefghijklmnopqrstuvwxyz\" string = str toggle = . TRUE . do i = 1 , len_trim ( string ) if ( toggle ) then if ( string ( i : i ) == '\"' . or . string ( i : i ) == \"'\" ) then toggle = . not . toggle togglechar = string ( i : i ) endif irnk = index ( small , string ( i : i )) if ( irnk > 0 ) then string ( i : i ) = large ( irnk : irnk ) endif else if ( string ( i : i ) == togglechar ) toggle = . not . toggle endif enddo end function upper_quoted elemental pure function upper ( str , begin , end ) result ( string ) character ( * ), intent ( in ) :: str ! input string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ! initialize output string to input string ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( ibegin , begin ), iend ) endif if ( present ( end )) then iend = max ( 1 , min ( iend , end )) endif do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = achar ( iachar ( str ( i : i )) + diff ) ! change miniscule letter to majascule end select enddo end function upper elemental pure function lower ( str , begin , end ) result ( string ) character ( * ), intent ( in ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str ibegin = 1 iend = len_trim ( str ) if ( present ( begin )) then ibegin = min ( max ( 1 , begin ), iend ) endif if ( present ( end )) then iend = max ( 1 , min ( iend , end )) endif do concurrent ( i = ibegin : iend ) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select enddo end function lower pure function a2s ( array ) result ( string ) character ( len = 1 ), intent ( in ) :: array (:) character ( len = SIZE ( array )) :: string integer :: i forall ( i = 1 : size ( array )) string ( i : i ) = array ( i ) end function a2s pure function s2a ( string ) RESULT ( array ) character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: array ( len ( string )) integer :: i forall ( i = 1 : len ( string )) array ( i ) = string ( i : i ) end function s2a pure function s2c ( string ) RESULT ( array ) use , intrinsic :: ISO_C_BINDING , only : C_CHAR character ( len =* ), intent ( in ) :: string character ( kind = C_CHAR , len = 1 ) :: array ( len_trim ( string ) + 1 ) integer :: i do i = 1 , size ( array ) - 1 array ( i ) = string ( i : i ) enddo array ( size ( array ):) = achar ( 0 ) end function s2c function c2s ( c_string_pointer ) result ( f_string ) use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer , c_char , c_null_char integer , parameter :: max_length = 4096 type ( c_ptr ), intent ( in ) :: c_string_pointer character ( len = :), allocatable :: f_string character ( kind = c_char ), dimension (:), pointer :: char_array_pointer => null () character ( len = max_length ) :: aux_string integer :: i , length = 0 call c_f_pointer ( c_string_pointer , char_array_pointer ,[ max_length ]) if (. not . associated ( char_array_pointer )) then allocate ( character ( len = 4 ) :: f_string ) f_string = \"NULL\" return endif aux_string = \" \" do i = 1 , max_length if ( char_array_pointer ( i ) == c_null_char ) then length = i - 1 exit endif aux_string ( i : i ) = char_array_pointer ( i ) enddo allocate ( character ( len = length ) :: f_string ) f_string = aux_string ( 1 : length ) end function c2s function indent ( line ) implicit none integer :: indent character ( len =* ), intent ( in ) :: line integer :: i indent = 0 NOTSPACE : block SCAN : do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' ) then indent = i - 1 exit NOTSPACE endif enddo SCAN indent = len ( line ) endblock NOTSPACE end function indent function visible ( input ) result ( output ) character ( len =* ), intent ( in ) :: input character ( len = :), allocatable :: output integer :: i character ( len = 1 ) :: c character ( len =* ), parameter :: chars ( 0 : 255 ) = [ & '&#94;@  ' , '&#94;A  ' , '&#94;B  ' , '&#94;C  ' , '&#94;D  ' , '&#94;E  ' , '&#94;F  ' , '&#94;G  ' , '&#94;H  ' , '&#94;I  ' , & '&#94;J  ' , '&#94;K  ' , '&#94;L  ' , '&#94;M  ' , '&#94;N  ' , '&#94;O  ' , '&#94;P  ' , '&#94;Q  ' , '&#94;R  ' , '&#94;S  ' , & '&#94;T  ' , '&#94;U  ' , '&#94;V  ' , '&#94;W  ' , '&#94;X  ' , '&#94;Y  ' , '&#94;Z  ' , '&#94;[  ' , '&#94;\\  ' , '&#94;]  ' , & '&#94;&#94;  ' , '&#94;_  ' , '    ' , '!   ' , '\"   ' , '#   ' , '$   ' , '%   ' , '&   ' , '''   ' , & '(   ' , ')   ' , '*   ' , '+   ' , ',   ' , '-   ' , '.   ' , '/   ' , '0   ' , '1   ' , & '2   ' , '3   ' , '4   ' , '5   ' , '6   ' , '7   ' , '8   ' , '9   ' , ':   ' , ';   ' , & '<   ' , '=   ' , '>   ' , '?   ' , '@   ' , 'A   ' , 'B   ' , 'C   ' , 'D   ' , 'E   ' , & 'F   ' , 'G   ' , 'H   ' , 'I   ' , 'J   ' , 'K   ' , 'L   ' , 'M   ' , 'N   ' , 'O   ' , & 'P   ' , 'Q   ' , 'R   ' , 'S   ' , 'T   ' , 'U   ' , 'V   ' , 'W   ' , 'X   ' , 'Y   ' , & 'Z   ' , '[   ' , '\\   ' , ']   ' , '&#94;   ' , '_   ' , '`   ' , 'a   ' , 'b   ' , 'c   ' , & 'd   ' , 'e   ' , 'f   ' , 'g   ' , 'h   ' , 'i   ' , 'j   ' , 'k   ' , 'l   ' , 'm   ' , & 'n   ' , 'o   ' , 'p   ' , 'q   ' , 'r   ' , 's   ' , 't   ' , 'u   ' , 'v   ' , 'w   ' , & 'x   ' , 'y   ' , 'z   ' , '{   ' , '|   ' , '}   ' , '~   ' , '&#94;?  ' , 'M-&#94;@' , 'M-&#94;A' , & 'M-&#94;B' , 'M-&#94;C' , 'M-&#94;D' , 'M-&#94;E' , 'M-&#94;F' , 'M-&#94;G' , 'M-&#94;H' , 'M-&#94;I' , 'M-&#94;J' , 'M-&#94;K' , & 'M-&#94;L' , 'M-&#94;M' , 'M-&#94;N' , 'M-&#94;O' , 'M-&#94;P' , 'M-&#94;Q' , 'M-&#94;R' , 'M-&#94;S' , 'M-&#94;T' , 'M-&#94;U' , & 'M-&#94;V' , 'M-&#94;W' , 'M-&#94;X' , 'M-&#94;Y' , 'M-&#94;Z' , 'M-&#94;[' , 'M-&#94;\\', ' M - &#94; ] ', ' M - &#94;&#94; ', ' M - &#94;_ ', & ' M - ', ' M - ! ', 'M-\" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', & 'M-* ' , 'M-+ ' , 'M-, ' , 'M-- ' , 'M-. ' , 'M-/ ' , 'M-0 ' , 'M-1 ' , 'M-2 ' , 'M-3 ' , & 'M-4 ' , 'M-5 ' , 'M-6 ' , 'M-7 ' , 'M-8 ' , 'M-9 ' , 'M-: ' , 'M-; ' , 'M-< ' , 'M-= ' , & 'M-> ' , 'M-? ' , 'M-@ ' , 'M-A ' , 'M-B ' , 'M-C ' , 'M-D ' , 'M-E ' , 'M-F ' , 'M-G ' , & 'M-H ' , 'M-I ' , 'M-J ' , 'M-K ' , 'M-L ' , 'M-M ' , 'M-N ' , 'M-O ' , 'M-P ' , 'M-Q ' , & 'M-R ' , 'M-S ' , 'M-T ' , 'M-U ' , 'M-V ' , 'M-W ' , 'M-X ' , 'M-Y ' , 'M-Z ' , 'M-[ ' , & 'M-\\ ' , 'M-] ' , 'M-&#94; ' , 'M-_ ' , 'M-` ' , 'M-a ' , 'M-b ' , 'M-c ' , 'M-d ' , 'M-e ' , & 'M-f ' , 'M-g ' , 'M-h ' , 'M-i ' , 'M-j ' , 'M-k ' , 'M-l ' , 'M-m ' , 'M-n ' , 'M-o ' , & 'M-p ' , 'M-q ' , 'M-r ' , 'M-s ' , 'M-t ' , 'M-u ' , 'M-v ' , 'M-w ' , 'M-x ' , 'M-y ' , & 'M-z ' , 'M-{ ' , 'M-| ' , 'M-} ' , 'M-~ ' , 'M-&#94;?' ] output = '' do i = 1 , len ( input ) c = input ( i : i ) if ( c == ' ' ) then output = output // ' ' else output = output // trim ( chars ( iachar ( c ))) endif enddo end function visible function expand ( line , escape ) result ( lineout ) implicit none character ( len =* ), parameter :: c_horizontal_tab = char ( 9 ) character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( in ), optional :: escape ! escape character. Default is backslash character ( len = 1 ) :: esc ! escape character. Default is % character ( len = :), allocatable :: lineout integer :: i integer :: lgth character ( len = 3 ) :: thr integer :: xxx integer :: ios i = 0 ! pointer into input lgth = len_trim ( line ) lineout = '' if ( lgth == 0 ) return if ( present ( escape )) then esc = escape else esc = char ( 92 ) endif EXP : do i = i + 1 if ( i > lgth ) exit if ( line ( i : i ) == esc ) then i = i + 1 if ( i > lgth ) exit if ( line ( i : i ) /= esc ) then BACKSLASH : select case ( line ( i : i )) case ( 'a' , 'A' , 'g' , 'G' ); lineout = lineout // char ( 7 ) ! %a     alert (BEL) case ( 'b' , 'B' ); lineout = lineout // char ( 8 ) ! %b     backspace case ( 'c' , 'C' ); exit EXP ! %c     suppress further output case ( 'd' , 'D' ) ! %d     Dnnn decimal value thr = line ( i + 1 :) read ( thr , '(i3)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 3 case ( 'e' , 'E' ); lineout = lineout // char ( 27 ) ! %e     escape case ( 'f' , 'F' ); lineout = lineout // char ( 12 ) ! %f     form feed case ( 'n' , 'N' ); lineout = lineout // char ( 10 ) ! %n     new line !case('n','N');lineout=lineout//new_line('A')     ! %n     new line case ( 'o' , 'O' ) thr = line ( i + 1 :) read ( thr , '(o3)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 3 case ( 'r' , 'R' ); lineout = lineout // char ( 13 ) ! %r     carriage return case ( 't' , 'T' ); lineout = lineout // c_horizontal_tab ! %t     horizontal tab case ( 'v' , 'V' ); lineout = lineout // char ( 11 ) ! %v     vertical tab case ( 'x' , 'X' , 'h' , 'H' ) ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits) thr = line ( i + 1 :) read ( thr , '(z2)' , iostat = ios ) xxx lineout = lineout // char ( xxx ) i = i + 2 end select BACKSLASH else lineout = lineout // esc ! escape character, defaults to backslash endif else lineout = lineout // line ( i : i ) endif if ( i >= lgth ) exit EXP enddo EXP end function expand elemental impure subroutine notabs ( instr , outstr , lgth ) character ( len =* ), intent ( in ) :: instr ! input line to scan for tab characters character ( len =* ), intent ( out ) :: outstr ! tab-expanded version of INSTR produced integer , intent ( out ) :: lgth ! column position of last character put into output string ! that is, lgth holds the position of the last non-blank character in OUTSTR integer , parameter :: tabsize = 8 ! assume a tab stop is set every 8th column integer :: ipos ! position in OUTSTR to put next character of INSTR integer :: lenin ! length of input string trimmed of trailing spaces integer :: lenout ! number of characters output string can hold integer :: istep ! counter that advances thru input string INSTR one character at a time character ( len = 1 ) :: c ! character in input line being processed integer :: iade ! ADE (ASCII Decimal Equivalent) of character being tested ipos = 1 ! where to put next character in output string OUTSTR lenin = len_trim ( instr ( 1 : len ( instr ) )) ! length of INSTR trimmed of trailing spaces lenout = len ( outstr ) ! number of characters output string OUTSTR can hold outstr = \" \" ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters SCAN_LINE : do istep = 1 , lenin ! look through input string one character at a time c = instr ( istep : istep ) ! get next character iade = iachar ( c ) ! get ADE of the character EXPAND_TABS : select case ( iade ) ! take different actions depending on which character was found case ( 9 ) ! test if character is a tab and move pointer out to appropriate column ipos = ipos + ( tabsize - ( mod ( ipos - 1 , tabsize ))) case ( 10 , 13 ) ! convert carriage-return and new-line to space ,typically to handle DOS-format files ipos = ipos + 1 case default ! c is anything else other than a tab,newline,or return  insert it in output string if ( ipos > lenout ) then call journal ( \"*notabs* output string overflow\" ) exit else outstr ( ipos : ipos ) = c ipos = ipos + 1 endif end select EXPAND_TABS enddo SCAN_LINE ipos = min ( ipos , lenout ) ! tabs or newline or return characters or last character might have gone too far lgth = len_trim ( outstr (: ipos )) ! trim trailing spaces end subroutine notabs function dilate ( INSTR ) result ( OUTSTR ) CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input line to scan for tab characters CHARACTER ( LEN = :), allocatable :: outstr ! tab-expanded version of INSTR produced integer :: i integer :: icount integer :: lgth icount = 0 do i = 1 , len ( instr ) if ( instr ( i : i ) == char ( 9 )) icount = icount + 1 enddo allocate ( character ( len = ( len ( instr ) + 8 * icount )) :: outstr ) call notabs ( instr , outstr , lgth ) outstr = outstr (: lgth ) END function dilate pure function adjustc ( string , length ) character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen <= 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft > 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc function nospace ( line ) character ( len =* ), intent ( in ) :: line ! remove whitespace from this string and return it character ( len = :), allocatable :: nospace ! returned string integer :: ipos ! position to place next output character at integer :: i ! counter to increment from beginning to end of input string allocate ( nospace , mold = line ) ! initially make output line length of input line nospace (: len_trim ( nospace )) = ' ' ipos = 0 do i = 1 , len_trim ( line ) ! increment from first to last character of the input line if ( isspace ( line ( i : i ) ) ) cycle ! if a blank is encountered skip it ipos = ipos + 1 ! increment count of non-blank characters found nospace ( ipos : ipos ) = line ( i : i ) ! store non-blank character in output enddo nospace = trim ( nospace ) ! blank out unpacked part of line end function nospace function stretch ( line , length , pattern , suffix ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len =* ), intent ( in ), optional :: pattern character ( len =* ), intent ( in ), optional :: suffix character ( len = :), allocatable :: strout if ( present ( pattern )) then strout = pad ( line , length , pattern ) else strout = pad ( line , length ) endif if ( present ( suffix )) then strout = strout // suffix endif end function stretch function rpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )) strout = pad ( valuein , length , ' ' , clip = . true .) return class default stop '<ERROR>*rpad* unknown type' end select strout = pad ( line , length , ' ' , clip = . true .) end function rpad function cpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )); line = valuein class default stop '<ERROR>*cpad* unknown type' end select strout = adjustc ( crop ( line ), length ) end function cpad function lpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein type is ( character ( len =* )) strout = pad ( valuein , length , ' ' , right = . false ., clip = . true .) return class default stop '<ERROR>*lpad* unknown type' end select strout = pad ( line , length , ' ' , clip = . true ., right = . false .) end function lpad function zpad ( valuein , length ) result ( strout ) class ( * ), intent ( in ) :: valuein integer , intent ( in ) :: length character ( len = :), allocatable :: strout character ( len = 4096 ) :: line select type ( valuein ) type is ( integer ( kind = int8 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int16 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int32 )); write ( line , '(i0)' ) valuein type is ( integer ( kind = int64 )); write ( line , '(i0)' ) valuein type is ( real ( kind = real32 )); write ( line , '(1pg0)' ) valuein type is ( real ( kind = real64 )); write ( line , '(1pg0)' ) valuein type is ( logical ); write ( line , '(l1)' ) valuein type is ( character ( len =* )); line = valuein type is ( complex ); write ( line , '(\"(\",1pg0,\",\",1pg0,\")\")' ) valuein end select strout = pad ( trim ( line ), length , '0' , clip = . true ., right = . false .) end function zpad function pad ( line , length , pattern , right , clip ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len =* ), intent ( in ), optional :: pattern logical , optional , intent ( in ) :: right logical , optional , intent ( in ) :: clip character ( len = :), allocatable :: strout logical :: local_right logical :: local_clip character ( len = :), allocatable :: local_pattern character ( len = :), allocatable :: local_line if ( present ( right ) ) then ; local_right = right ; else ; local_right = . true .; endif if ( present ( clip ) ) then ; local_clip = clip ; else ; local_clip = . false .; endif if ( present ( pattern ) ) then ; local_pattern = pattern ; else ; local_pattern = ' ' ; endif if ( len ( local_pattern ). eq . 0 ) then strout = line else if ( local_clip ) then local_line = trim ( adjustl ( line )) allocate ( character ( len = max ( length , len ( local_line ))) :: strout ) else local_line = line allocate ( character ( len = max ( length , len ( line ))) :: strout ) endif if ( local_right ) then strout (:) = local_line // repeat ( local_pattern , len ( strout ) / len ( local_pattern ) + 1 ) else strout (:) = repeat ( local_pattern , ceiling ( real ( len ( strout )) / len ( local_pattern ))) strout ( len ( strout ) - len ( local_line ) + 1 :) = local_line endif endif end function pad function lenset ( line , length ) result ( strout ) character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = length ) :: strout strout = line end function lenset function merge_str ( str1 , str2 , expr ) result ( strout ) character ( len =* ), intent ( in ), optional :: str1 character ( len =* ), intent ( in ), optional :: str2 character ( len = :), allocatable :: str1_local character ( len = :), allocatable :: str2_local logical , intent ( in ) :: expr character ( len = :), allocatable :: strout integer :: big if ( present ( str2 )) then str2_local = str2 else str2_local = '' endif if ( present ( str1 )) then str1_local = str1 else str1_local = '' endif big = max ( len ( str1_local ), len ( str2_local )) ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning '' strout = trim ( merge ( lenset ( str1_local , big ), lenset ( str2_local , big ), expr )) end function merge_str function squeeze ( str , charp ) result ( outstr ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), intent ( in ) :: charp character ( len = :), allocatable :: outstr character ( len = 1 ) :: ch , last_one integer :: i , pio ! position in output outstr = repeat ( ' ' , len ( str )) ! start with a string big enough to hold any output if ( len ( outstr ) == 0 ) return ! handle edge condition last_one = str ( 1 : 1 ) ! since at least this long start output with first character outstr ( 1 : 1 ) = last_one pio = 1 do i = 2 , len ( str ) ch = str ( i : i ) pio = pio + merge ( 0 , 1 , ch == last_one . and . ch == charp ) ! decide whether to advance before saving outstr ( pio : pio ) = ch ! store new one or overlay the duplcation last_one = ch enddo outstr = outstr (: pio ) ! trim the output string to just what was set end function squeeze function compact ( str , char ) result ( outstr ) character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ) == 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( iachar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output == 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select enddo IFSPACE end function compact elemental function noesc ( INSTR ) character ( len =* ), intent ( in ) :: INSTR ! string that might contain nonprintable characters character ( len = len ( instr )) :: noesc integer :: ic , i10 noesc = '' ! initialize output string do i10 = 1 , len_trim ( INSTR ( 1 : len ( INSTR ))) ic = iachar ( INSTR ( i10 : i10 )) if ( ic <= 3 1. or . ic == 127 ) then ! find characters with ADE of 0-31, 127 noesc ( I10 : I10 ) = ' ' ! replace non-printable characters with a space else noesc ( I10 : I10 ) = INSTR ( i10 : i10 ) ! copy other characters as-is from input string to output string endif enddo end function noesc subroutine a2r ( chars , valu , ierr ) character ( len =* ), intent ( in ) :: chars ! input string real , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( ierr == 0 ) then if ( valu8 <= huge ( valu )) then valu = real ( valu8 ) else call journal ( 'sc' , '*a2r*' , '- value too large' , valu8 , '>' , huge ( valu )) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2r subroutine a2i ( chars , valu , ierr ) character ( len =* ), intent ( in ) :: chars ! input string integer , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( valu8 <= huge ( valu )) then if ( valu8 <= huge ( valu )) then valu = int ( valu8 ) else call journal ( 'sc' , '*a2i*' , '- value too large' , valu8 , '>' , huge ( valu )) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2i subroutine a2d ( chars , valu , ierr , onerr ) character ( len =* ), intent ( in ) :: chars ! input string character ( len = :), allocatable :: local_chars doubleprecision , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) class ( * ), optional , intent ( in ) :: onerr character ( len =* ), parameter :: fmt = \"('(bn,g',i5,'.0)')\" ! format used to build frmt character ( len = 15 ) :: frmt ! holds format built to read input string character ( len = 256 ) :: msg ! hold message from I/O errors integer :: intg integer :: pnd integer :: basevalue , ivalu character ( len = 3 ), save :: nan_string = 'NaN' ierr = 0 ! initialize error flag to zero local_chars = unquote ( chars ) msg = '' if ( len ( local_chars ) == 0 ) local_chars = ' ' call substitute ( local_chars , ',' , '' ) ! remove any comma characters pnd = scan ( local_chars , '#:' ) if ( pnd /= 0 ) then write ( frmt , fmt ) pnd - 1 ! build format of form '(BN,Gn.0)' read ( local_chars (: pnd - 1 ), fmt = frmt , iostat = ierr , iomsg = msg ) basevalue ! try to read value from string if ( decodebase ( local_chars ( pnd + 1 :), basevalue , ivalu )) then valu = real ( ivalu , kind = kind ( 0.0d0 )) else valu = 0.0d0 ierr =- 1 endif else select case ( local_chars ( 1 : 1 )) case ( 'z' , 'Z' , 'h' , 'H' ) ! assume hexadecimal frmt = '(Z' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'b' , 'B' ) ! assume binary (base 2) frmt = '(B' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'o' , 'O' ) ! assume octal frmt = '(O' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case default write ( frmt , fmt ) len ( local_chars ) ! build format of form '(BN,Gn.0)' read ( local_chars , fmt = frmt , iostat = ierr , iomsg = msg ) valu ! try to read value from string end select endif if ( ierr /= 0 ) then ! if an error occurred ierr will be non-zero. if ( present ( onerr )) then select type ( onerr ) type is ( integer ) valu = onerr type is ( real ) valu = onerr type is ( doubleprecision ) valu = onerr end select else ! set return value to NaN read ( nan_string , '(g3.3)' ) valu endif if ( local_chars /= 'eod' ) then ! print warning message except for special value \"eod\" call journal ( 'sc' , '*a2d* - cannot produce number from string [' // trim ( chars ) // ']' ) if ( msg /= '' ) then call journal ( 'sc' , '*a2d* - [' // trim ( msg ) // ']' ) endif endif endif end subroutine a2d doubleprecision function s2v ( chars , ierr , onerr ) character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local /= 0 ) then write ( * , * ) '*s2v* stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v impure elemental doubleprecision function dble_s2v ( chars ) character ( len =* ), intent ( in ) :: chars dble_s2v = s2v ( chars ) end function dble_s2v impure elemental real function real_s2v ( chars ) character ( len =* ), intent ( in ) :: chars real_s2v = real ( s2v ( chars )) end function real_s2v impure elemental integer function int_s2v ( chars ) character ( len =* ), intent ( in ) :: chars int_s2v = int ( s2v ( chars )) end function int_s2v impure elemental integer function nint_s2v ( chars ) character ( len =* ), intent ( in ) :: chars nint_s2v = nint ( s2v ( chars )) end function nint_s2v subroutine value_to_string ( gval , chars , length , err , fmt , trimz ) class ( * ), intent ( in ) :: gval character ( len =* ), intent ( out ) :: chars integer , intent ( out ), optional :: length integer , optional :: err integer :: err_local character ( len =* ), optional , intent ( in ) :: fmt ! format to write value with logical , intent ( in ), optional :: trimz character ( len = :), allocatable :: fmt_local character ( len = 1024 ) :: msg if ( present ( fmt )) then select type ( gval ) type is ( integer ) fmt_local = '(i0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( real ) fmt_local = '(bz,g23.10e3)' fmt_local = '(bz,g0.8)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) fmt_local = '(bz,g0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( logical ) fmt_local = '(l1)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval class default call journal ( '*value_to_string* UNKNOWN TYPE' ) chars = ' ' end select if ( fmt == '' ) then chars = adjustl ( chars ) call trimzeros_ ( chars ) endif else ! no explicit format option present err_local =- 1 select type ( gval ) type is ( integer ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( real ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( logical ) write ( chars , * , iostat = err_local , iomsg = msg ) gval class default chars = '' end select chars = adjustl ( chars ) if ( index ( chars , '.' ) /= 0 ) call trimzeros_ ( chars ) endif if ( present ( trimz )) then if ( trimz ) then chars = adjustl ( chars ) call trimzeros_ ( chars ) endif endif if ( present ( length )) then length = len_trim ( chars ) endif if ( present ( err )) then err = err_local elseif ( err_local /= 0 ) then ! cannot currently do I/O from a function being called from I/O !write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']' chars = chars // ' *value_to_string* WARNING:[' // trim ( msg ) // ']' endif end subroutine value_to_string function v2s_bug ( gval ) result ( outstr ) class ( * ), intent ( in ) :: gval ! input value to convert to a string character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string call value_to_string ( gval , string ) outstr = trim ( string ) end function v2s_bug function d2s ( dvalue , fmt ) result ( outstr ) doubleprecision , intent ( in ) :: dvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( dvalue , string , fmt = fmt ) else call value_to_string ( dvalue , string ) endif outstr = trim ( string ) end function d2s function r2s ( rvalue , fmt ) result ( outstr ) real , intent ( in ) :: rvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( rvalue , string , fmt = fmt ) else call value_to_string ( rvalue , string ) endif outstr = trim ( string ) end function r2s function i2s ( ivalue , fmt ) result ( outstr ) integer , intent ( in ) :: ivalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( ivalue , string , fmt = fmt ) else call value_to_string ( ivalue , string ) endif outstr = trim ( string ) end function i2s function l2s ( lvalue , fmt ) result ( outstr ) logical , intent ( in ) :: lvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( lvalue , string , fmt = fmt ) else call value_to_string ( lvalue , string ) endif outstr = trim ( string ) end function l2s function isNumber ( string , msg , verbose ) implicit none character ( len =* ), intent ( in ) :: string character ( len = :), intent ( out ), allocatable , optional :: msg logical , intent ( in ), optional :: verbose integer :: isnumber integer :: i , iend character ( len = 1 ), allocatable :: z (:) character ( len = :), allocatable :: message logical :: founddigit logical :: verbose_local i = 1 founddigit = . false . isnumber = 0 z = switch ( trim ( nospace ( string ))) iend = size ( z ) message = 'not a number' if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif DONE : block if ( iend == 0 ) then isnumber =- 1 ! string is null message = 'null string' exit DONE endif if ( index ( '+-' , z ( i )) /= 0 ) i = i + 1 ! skip optional leading sign if ( i > iend ) then isnumber =- 2 ! string was just a sign message = 'just a sign' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 1 ! [+-]NNNNNN message = 'integer' exit DONE endif if ( z ( i ) == '.' ) then ! a period would be OK at this point i = i + 1 endif if ( i > iend ) then ! [+-]NNNNNN. isnumber = 2 message = 'whole number' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 3 ! [+-]NNNNNN.MMMM message = 'real number' exit DONE endif if ( index ( 'eEdD' , z ( i )) /= 0 ) then i = i + 1 if ( i == 2 ) then isnumber =- 6 ! [+-]NNNNNN[.[MMMM]]e but a value must follow message = 'missing leading value before exponent' exit DONE endif endif if ( i > iend ) then isnumber =- 3 ! [+-]NNNNNN[.[MMMM]]e but a value must follow message = 'missing exponent' exit DONE endif if (. not . founddigit ) then isnumber =- 7 message = 'missing value before exponent' exit DONE endif if ( index ( '+-' , z ( i )) /= 0 ) i = i + 1 if ( i > iend ) then isnumber =- 4 ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow message = 'missing exponent after sign' exit DONE endif call next () ! position I to next non-digit or end of string+1 if ( i > iend ) then isnumber = 4 ! [+-]NNNNNN.MMMMe[+-]LL message = 'value with exponent' exit DONE endif isnumber =- 5 message = 'bad number' endblock DONE if ( verbose_local ) then write ( * , * ) trim ( string ) // ' is ' // message endif if ( present ( msg )) then msg = message endif contains subroutine next () ! move to next non-digit or end of string+1 integer :: j do j = i , iend if (. not . isdigit ( z ( j ))) then exit endif founddigit = . true . if ( verbose_local ) write ( * , * ) 'I=' , i , ' J=' , j , ' Z(j)=' , z ( j ) enddo i = j if ( verbose_local ) then write ( * , * ) 'I and J=' , i if ( i <= iend ) then write ( * , * ) 'Z(I)=' , z ( i ) else write ( * , * ) '====>' endif endif end subroutine next end function isNumber subroutine trimzeros_ ( string ) character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: exp ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found exp = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ) == 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i <= 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select enddo if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( exp ) else string = str endif end subroutine trimzeros_ subroutine listout ( icurve_lists , icurve_expanded , inums_out , ierr ) implicit none integer , intent ( in ) :: icurve_lists (:) ! input array integer , intent ( out ) :: icurve_expanded (:) ! output array integer , intent ( out ) :: inums_out ! number of icurve_expanded numbers on output integer , intent ( out ) :: ierr ! status variable character ( len = 80 ) :: temp1 integer :: i80 , i90 integer :: imin , imax integer :: idirection , icount integer :: iin integer :: inums_max ierr = 0 icurve_expanded = 0 ! initialize output array inums_out = 0 ! initialize number of significant values in output array inums_max = size ( icurve_expanded ) if ( inums_max == 0 ) then ierr =- 2 return endif iin = size ( icurve_lists ) if ( iin > 0 ) then icurve_expanded ( 1 ) = icurve_lists ( 1 ) endif icount = 2 do i90 = 2 , iin if ( icurve_lists ( i90 ) < 0 ) then imax = abs ( icurve_lists ( i90 )) imin = abs ( icurve_lists ( i90 - 1 )) if ( imin > imax ) then idirection =- 1 imin = imin - 1 elseif ( imax > imin ) then idirection = 1 imin = imin + 1 else idirection = 1 endif do i80 = imin , imax , idirection if ( icount > inums_max ) then write ( temp1 , '(a,i5,a)' ) '*listout* only ' , inums_max , ' values allowed' ierr =- 1 call journal ( temp1 ) inums_out = icount - 1 exit endif icurve_expanded ( icount ) = i80 icount = icount + 1 enddo else icurve_expanded ( icount ) = icurve_lists ( i90 ) icount = icount + 1 endif enddo inums_out = icount - 1 end subroutine listout function quote ( str , mode , clip ) result ( quoted_str ) character ( len =* ), intent ( in ) :: str ! the string to be quoted character ( len =* ), optional , intent ( in ) :: mode logical , optional , intent ( in ) :: clip character ( len = :), allocatable :: quoted_str character ( len = 1 ), parameter :: double_quote = '\"' character ( len = 20 ) :: local_mode if ( present ( clip )) then if ( clip ) then quoted_str = adjustl ( str ) else quoted_str = str endif else quoted_str = str endif local_mode = merge_str ( mode , 'DOUBLE' , present ( mode )) select case ( lower ( local_mode )) case ( 'double' ) quoted_str = double_quote // trim ( replace ( quoted_str , '\"' , '\"\"' )) // double_quote case ( 'escape' ) quoted_str = double_quote // trim ( replace ( quoted_str , '\"' , '\\\"' )) // double_quote case default call journal ( 'sc' , '*quote* ERROR: unknown quote mode ' , local_mode ) quoted_str = str end select end function quote function unquote ( quoted_str , esc ) result ( unquoted_str ) character ( len =* ), intent ( in ) :: quoted_str ! the string to be unquoted character ( len = 1 ), optional , intent ( in ) :: esc ! escape character character ( len = :), allocatable :: unquoted_str integer :: inlen character ( len = 1 ), parameter :: single_quote = \"'\" character ( len = 1 ), parameter :: double_quote = '\"' integer :: quote ! whichever quote is to be used integer :: before integer :: current integer :: iesc integer :: iput integer :: i logical :: inside if ( present ( esc )) then ! select escape character as specified character or special value meaning not set iesc = iachar ( esc ) ! allow for an escape character else iesc =- 1 ! set to value that matches no character endif inlen = len ( quoted_str ) ! find length of input string allocate ( character ( len = inlen ) :: unquoted_str ) ! initially make output string length of input string if ( inlen >= 1 ) then ! double_quote is the default quote unless the first character is single_quote if ( quoted_str ( 1 : 1 ) == single_quote ) then quote = iachar ( single_quote ) else quote = iachar ( double_quote ) endif else quote = iachar ( double_quote ) endif before =- 2 ! initially set previous character to impossible value unquoted_str (:) = '' ! initialize output string to null string iput = 1 inside = . false . STEPTHROUGH : do i = 1 , inlen current = iachar ( quoted_str ( i : i )) if ( before == iesc ) then ! if previous character was escape use current character unconditionally iput = iput - 1 ! backup unquoted_str ( iput : iput ) = char ( current ) iput = iput + 1 before =- 2 ! this could be second esc or quote elseif ( current == quote ) then ! if current is a quote it depends on whether previous character was a quote if ( before == quote ) then unquoted_str ( iput : iput ) = char ( quote ) ! this is second quote so retain it iput = iput + 1 before =- 2 elseif (. not . inside . and . before /= iesc ) then inside = . true . else ! this is first quote so ignore it except remember it in case next is a quote before = current endif else unquoted_str ( iput : iput ) = char ( current ) iput = iput + 1 before = current endif enddo STEPTHROUGH unquoted_str = unquoted_str (: iput - 1 ) end function unquote pure elemental integer function edit_distance ( a , b ) character ( len =* ), intent ( in ) :: a , b integer :: len_a , len_b , i , j , cost integer , allocatable :: matrix (:,:) len_a = len_trim ( a ) len_b = len_trim ( b ) !-------------------------------------- ! required by older compilers instead of above declaration if ( allocated ( matrix )) deallocate ( matrix ) allocate ( matrix ( 0 : len_a , 0 : len_b )) !-------------------------------------- matrix (:, 0 ) = [( i , i = 0 , len_a )] matrix ( 0 ,:) = [( j , j = 0 , len_b )] do i = 1 , len_a do j = 1 , len_b cost = merge ( 0 , 1 , a ( i : i ) == b ( j : j )) matrix ( i , j ) = min ( matrix ( i - 1 , j ) + 1 , matrix ( i , j - 1 ) + 1 , matrix ( i - 1 , j - 1 ) + cost ) enddo enddo edit_distance = matrix ( len_a , len_b ) end function edit_distance function bundle ( x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 , x11 , x12 , x13 , x14 , x15 , x16 , x17 , x18 , x19 , x20 , len ) result ( vec ) character ( len =* ), intent ( in ), optional :: x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 character ( len =* ), intent ( in ), optional :: x11 , x12 , x13 , x14 , x15 , x16 , x17 , x18 , x19 , x20 integer , intent ( in ), optional :: len character ( len = :), allocatable :: vec (:) integer :: ilen , icount , iset ilen = 0 icount = 0 iset = 0 call increment ( x1 ) call increment ( x2 ) call increment ( x3 ) call increment ( x4 ) call increment ( x5 ) call increment ( x6 ) call increment ( x7 ) call increment ( x8 ) call increment ( x9 ) call increment ( x10 ) call increment ( x11 ) call increment ( x12 ) call increment ( x13 ) call increment ( x14 ) call increment ( x15 ) call increment ( x16 ) call increment ( x17 ) call increment ( x18 ) call increment ( x19 ) call increment ( x20 ) if ( present ( len )) ilen = len allocate ( character ( len = ilen ) :: vec ( icount )) call set ( x1 ) call set ( x2 ) call set ( x3 ) call set ( x4 ) call set ( x5 ) call set ( x6 ) call set ( x7 ) call set ( x8 ) call set ( x9 ) call set ( x10 ) call set ( x11 ) call set ( x12 ) call set ( x13 ) call set ( x14 ) call set ( x15 ) call set ( x16 ) call set ( x17 ) call set ( x18 ) call set ( x19 ) call set ( x20 ) contains subroutine increment ( str ) character ( len =* ), intent ( in ), optional :: str if ( present ( str )) then ilen = max ( ilen , len_trim ( str )) icount = icount + 1 endif end subroutine increment subroutine set ( str ) character ( len =* ), intent ( in ), optional :: str if ( present ( str )) then iset = iset + 1 vec ( iset ) = str endif end subroutine set end function bundle function describe ( ch ) result ( string ) character ( len = 1 ), intent ( in ) :: ch character ( len = :), allocatable :: string select case ( iachar ( ch )) case ( 0 ); STRING = \"ctrl-@ or ctrl-? (NUL) null\" case ( 1 ); STRING = \"ctrl-A (SOH) start of heading\" case ( 2 ); STRING = \"ctrl-B (STX) start of text\" case ( 3 ); STRING = \"ctrl-C (ETX) end of text\" case ( 4 ); STRING = \"ctrl-D (EOT) end of transmission\" case ( 5 ); STRING = \"ctrl-E (ENQ) enquiry\" case ( 6 ); STRING = \"ctrl-F (ACK) acknowledge\" case ( 7 ); STRING = \"ctrl-G (BEL) bell\" case ( 8 ); STRING = \"ctrl-H (BS) backspace\" case ( 9 ); STRING = \"ctrl-I (HT) horizontal tabulation\" case ( 10 ); STRING = \"ctrl-J (LF) line feed\" case ( 11 ); STRING = \"ctrl-K (VT) vertical tabulation\" case ( 12 ); STRING = \"ctrl-L (FF) form feed\" case ( 13 ); STRING = \"ctrl-M (CR) carriage return\" case ( 14 ); STRING = \"ctrl-N (SO) shift out\" case ( 15 ); STRING = \"ctrl-O (SI) shift in\" case ( 16 ); STRING = \"ctrl-P (DLE) data link escape\" case ( 17 ); STRING = \"ctrl-Q (DC1) device control 1\" case ( 18 ); STRING = \"ctrl-R (DC2) device control 2\" case ( 19 ); STRING = \"ctrl-S (DC3) device control 3\" case ( 20 ); STRING = \"ctrl-T (DC4) device control 4\" case ( 21 ); STRING = \"ctrl-U (NAK) negative acknowledge\" case ( 22 ); STRING = \"ctrl-V (SYN) synchronous idle\" case ( 23 ); STRING = \"ctrl-W (ETB) end of transmission block\" case ( 24 ); STRING = \"ctrl-X (CAN) cancel\" case ( 25 ); STRING = \"ctrl-Y (EM) end of medium\" case ( 26 ); STRING = \"ctrl-Z (SUB) substitute\" case ( 27 ); STRING = \"ctrl-[ (ESC) escape\" case ( 28 ); STRING = \"ctrl-\\ or ctrl-@ (FS) file separator\" case ( 29 ); STRING = \"ctrl-] (GS) group separator\" case ( 30 ); STRING = \"ctrl-&#94; or ctrl-= (RS) record separator\" case ( 31 ); STRING = \"ctrl-_ (US) unit separator\" case ( 32 ); STRING = \"space\" case ( 33 ); STRING = \"! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)\" case ( 34 ); STRING = \"\"\" quotation marks\" case ( 35 ); STRING = \"# number sign (hash, pound sign, hashtag)\" case ( 36 ); STRING = \"$ currency symbol\" case ( 37 ); STRING = \"% percent\" case ( 38 ); STRING = \"& ampersand\" case ( 39 ); STRING = \"' apostrophe\" case ( 40 ); STRING = \"( left parenthesis\" case ( 41 ); STRING = \") right parenthesis\" case ( 42 ); STRING = \"* asterisk\" case ( 43 ); STRING = \"+ plus\" case ( 44 ); STRING = \", comma\" case ( 45 ); STRING = \"- minus\" case ( 46 ); STRING = \". period\" case ( 47 ); STRING = \"/ slash\" case ( 48 ); STRING = \"0 zero\" case ( 49 ); STRING = \"1 one\" case ( 50 ); STRING = \"2 two\" case ( 51 ); STRING = \"3 three\" case ( 52 ); STRING = \"4 four\" case ( 53 ); STRING = \"5 five\" case ( 54 ); STRING = \"6 six\" case ( 55 ); STRING = \"7 seven\" case ( 56 ); STRING = \"8 eight\" case ( 57 ); STRING = \"9 nine\" case ( 58 ); STRING = \": colon\" case ( 59 ); STRING = \"; semicolon\" case ( 60 ); STRING = \"< less than\" case ( 61 ); STRING = \"= equals\" case ( 62 ); STRING = \"> greater than\" case ( 63 ); STRING = \"? question mark\" case ( 64 ); STRING = \"@ at sign\" case ( 65 ); STRING = \"A majuscule A\" case ( 66 ); STRING = \"B majuscule B\" case ( 67 ); STRING = \"C majuscule C\" case ( 68 ); STRING = \"D majuscule D\" case ( 69 ); STRING = \"E majuscule E\" case ( 70 ); STRING = \"F majuscule F\" case ( 71 ); STRING = \"G majuscule G\" case ( 72 ); STRING = \"H majuscule H\" case ( 73 ); STRING = \"I majuscule I\" case ( 74 ); STRING = \"J majuscule J\" case ( 75 ); STRING = \"K majuscule K\" case ( 76 ); STRING = \"L majuscule L\" case ( 77 ); STRING = \"M majuscule M\" case ( 78 ); STRING = \"N majuscule N\" case ( 79 ); STRING = \"O majuscule O\" case ( 80 ); STRING = \"P majuscule P\" case ( 81 ); STRING = \"Q majuscule Q\" case ( 82 ); STRING = \"R majuscule R\" case ( 83 ); STRING = \"S majuscule S\" case ( 84 ); STRING = \"T majuscule T\" case ( 85 ); STRING = \"U majuscule U\" case ( 86 ); STRING = \"V majuscule V\" case ( 87 ); STRING = \"W majuscule W\" case ( 88 ); STRING = \"X majuscule X\" case ( 89 ); STRING = \"Y majuscule Y\" case ( 90 ); STRING = \"Z majuscule Z\" case ( 91 ); STRING = \"[ left bracket\" case ( 92 ); STRING = \"\\ backslash\" case ( 93 ); STRING = \"] right bracket\" case ( 94 ); STRING = \"&#94; caret\" case ( 95 ); STRING = \"_ underscore\" case ( 96 ); STRING = \"` grave accent\" case ( 97 ); STRING = \"a miniscule a\" case ( 98 ); STRING = \"b miniscule b\" case ( 99 ); STRING = \"c miniscule c\" case ( 100 ); STRING = \"d miniscule d\" case ( 101 ); STRING = \"e miniscule e\" case ( 102 ); STRING = \"f miniscule f\" case ( 103 ); STRING = \"g miniscule g\" case ( 104 ); STRING = \"h miniscule h\" case ( 105 ); STRING = \"i miniscule i\" case ( 106 ); STRING = \"j miniscule j\" case ( 107 ); STRING = \"k miniscule k\" case ( 108 ); STRING = \"l miniscule l\" case ( 109 ); STRING = \"m miniscule m\" case ( 110 ); STRING = \"n miniscule n\" case ( 111 ); STRING = \"o miniscule o\" case ( 112 ); STRING = \"p miniscule p\" case ( 113 ); STRING = \"q miniscule q\" case ( 114 ); STRING = \"r miniscule r\" case ( 115 ); STRING = \"s miniscule s\" case ( 116 ); STRING = \"t miniscule t\" case ( 117 ); STRING = \"u miniscule u\" case ( 118 ); STRING = \"v miniscule v\" case ( 119 ); STRING = \"w miniscule w\" case ( 120 ); STRING = \"x miniscule x\" case ( 121 ); STRING = \"y miniscule y\" case ( 122 ); STRING = \"z miniscule z\" case ( 123 ); STRING = \"{ left brace\" case ( 124 ); STRING = \"| vertical line\" case ( 125 ); STRING = \"} right brace\" case ( 126 ); STRING = \"~ tilde\" case ( 127 ); STRING = \"ctrl-? (DEL) delete\" case default STRING = 'UNKNOWN' // v2s ( IACHAR ( ch )) end select end function describe subroutine getvals ( line , values , icount , ierr ) implicit none character ( len =* ), intent ( in ) :: line class ( * ), intent ( out ) :: values (:) integer , intent ( out ) :: icount integer , intent ( out ), optional :: ierr character ( len = :), allocatable :: buffer character ( len = len ( line )) :: words ( size ( values )) integer :: ios , i , ierr_local , isize isize = 0 select type ( values ) type is ( integer ); isize = size ( values ) type is ( real ); isize = size ( values ) type is ( doubleprecision ); isize = size ( values ) type is ( character ( len =* )); isize = size ( values ) end select ierr_local = 0 words = ' ' ! make sure words() is initialized to null+blanks buffer = trim ( unquote ( line )) // \"/\" ! add a slash to the end so how the read behaves with missing values is clearly defined read ( buffer , * , iostat = ios ) words ! undelimited strings are read into an array icount = 0 do i = 1 , isize ! loop thru array and convert non-blank words to numbers if ( words ( i ) == ' ' ) cycle select type ( values ) type is ( integer ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( real ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( doubleprecision ); read ( words ( i ), * , iostat = ios ) values ( icount + 1 ) type is ( character ( len =* )); values ( icount + 1 ) = words ( i ) end select if ( ios == 0 ) then icount = icount + 1 else ierr_local = ios write ( ERROR_UNIT , * ) '*getvals* WARNING:[' // trim ( words ( i )) // '] is not a number of specified type' endif enddo if ( present ( ierr )) then ierr = ierr_local elseif ( ierr_local /= 0 ) then ! error occurred and not returning error to main program to print message and stop program write ( ERROR_UNIT , * ) '*getval* error reading line [' // trim ( line ) // ']' stop 2 endif end subroutine getvals subroutine string_to_values ( line , iread , values , inums , delims , ierr ) implicit none character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , lgth , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local == '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 lgth = 0 ! lgth will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )) == 0 ) then ! found a non-delimiter lgth = i20 exit endif enddo if ( lgth == 0 ) then ! command was totally composed of delimiters call journal ( '*string_to_values* blank line passed as a list of numbers' ) return endif icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol > lgth ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )) == 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , lgth ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )) /= 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend == 0 ) iend = lgth + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier == 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP end subroutine string_to_values function s2vs ( string , delim ) result ( darray ) character ( len =* ), intent ( in ) :: string ! keyword to retrieve value for from dictionary character ( len =* ), optional :: delim ! delimiter characters character ( len = :), allocatable :: delim_local doubleprecision , allocatable :: darray (:) ! function type character ( len = :), allocatable :: carray (:) ! convert value to an array using split(3f) integer :: i integer :: ier if ( present ( delim )) then delim_local = delim else delim_local = ' ;,' endif call split ( string , carray , delimiters = delim_local ) ! split string into an array allocate ( darray ( size ( carray ))) ! create the output array do i = 1 , size ( carray ) call string_to_value ( carray ( i ), darray ( i ), ier ) ! convert the string to a numeric value enddo end function s2vs elemental function isprint ( onechar ) character , intent ( in ) :: onechar logical :: isprint select case ( onechar ) case ( ' ' : '~' ) ; isprint = . TRUE . case default ; isprint = . FALSE . end select end function isprint elemental function isgraph ( onechar ) character , intent ( in ) :: onechar logical :: isgraph select case ( iachar ( onechar )) case ( 33 : 126 ) isgraph = . TRUE . case default isgraph = . FALSE . end select end function isgraph elemental function isalpha ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'Z' , 'a' : 'z' ) res = . true . case default res = . false . end select end function isalpha elemental function isxdigit ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'F' , 'a' : 'f' , '0' : '9' ) res = . true . case default res = . false . end select end function isxdigit elemental function isdigit ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( '0' : '9' ) res = . true . case default res = . false . end select end function isdigit elemental function isblank ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( ' ' , char ( 9 )) res = . true . case default res = . false . end select end function isblank elemental function isascii ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( iachar ( ch )) case ( 0 : 127 ) res = . true . case default res = . false . end select end function isascii elemental function isspace ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( ' ' ) ! space(32) res = . true . case ( char ( 0 )) ! null(0) res = . true . case ( char ( 9 ): char ( 13 )) ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13), res = . true . case default res = . false . end select end function isspace elemental function iscntrl ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( char ( 127 ), char ( 0 ): char ( 31 )) res = . true . case default res = . false . end select end function iscntrl elemental function ispunct ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( char ( 33 ): char ( 47 ), char ( 58 ): char ( 64 ), char ( 91 ): char ( 96 ), char ( 123 ): char ( 126 )) res = . true . case default res = . false . end select end function ispunct elemental function fortran_name ( line ) result ( lout ) character ( len =* ), parameter :: int = '0123456789' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: allowed = upper // lower // int // '_' character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: name logical :: lout name = trim ( line ) if ( len ( name ) /= 0 ) then lout = verify ( name ( 1 : 1 ), lower // upper ) == 0 & & . and . verify ( name , allowed ) == 0 & & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name pure elemental function isupper ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'A' : 'Z' ) res = . true . case default res = . false . end select end function isupper elemental function islower ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'a' : 'z' ) res = . true . case default res = . false . end select end function islower elemental function isalnum ( ch ) result ( res ) character , intent ( in ) :: ch logical :: res select case ( ch ) case ( 'a' : 'z' , 'A' : 'Z' , '0' : '9' ) res = . true . case default res = . false . end select end function isalnum logical function base ( x , b , y , a ) implicit none character ( len =* ), intent ( in ) :: x character ( len =* ), intent ( out ) :: y integer , intent ( in ) :: b , a integer :: temp base = . true . if ( decodebase ( x , b , temp )) then if ( codebase ( temp , a , y )) then else print * , 'Error in coding number.' base = . false . endif else print * , 'Error in decoding number.' base = . false . endif end function base function base2 ( x ) result ( str ) integer , intent ( in ) :: x integer :: i character ( len = max ( 1 , bit_size ( x ) - leadz ( x ))) :: str associate ( n => len ( str )) str = repeat ( '0' , n ) do i = 0 , n - 1 if ( btest ( x , i )) str ( n - i : n - i ) = '1' end do end associate end function base2 function base2_fdo ( x ) result ( str ) integer , intent ( in ) :: x character ( len = max ( 1 , bit_size ( x ) - leadz ( x ))) :: str integer :: n , i if ( x == 0 ) then str ( 1 : 1 ) = '0' return endif n = len ( str ) str = repeat ( '0' , n ) do concurrent ( i = 0 : n - 1 , btest ( x , i )) str ( n - i : n - i ) = '1' end do end function base2_fdo function base2_a ( x ) result ( str ) integer , intent ( in ) :: x character ( len = :), allocatable :: str integer :: n , i n = max ( 1 , bit_size ( x ) - leadz ( x )) allocate ( character ( len = n ) :: str ) if ( x == 0 ) then str ( 1 : 1 ) = '0' return endif str = repeat ( '0' , n ) do concurrent ( i = 0 : n - 1 , btest ( x , i )) str ( n - i : n - i ) = '1' end do end function base2_a function base2_c ( x ) result ( str ) integer , intent ( in ) :: x character ( len = max ( 1 , bit_size ( x ) - leadz ( x ))) :: str write ( str , fmt = \"(b0)\" ) x end function base2_c logical function decodebase ( string , basein , out_baseten ) implicit none character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: basein integer , intent ( out ) :: out_baseten character ( len = len ( string )) :: string_local integer :: long , i , j , k real :: y real :: mult character ( len = 1 ) :: ch real , parameter :: XMAXREAL = real ( huge ( 1 )) integer :: out_sign integer :: basein_local integer :: ipound integer :: ierr string_local = upper ( trim ( adjustl ( string ))) decodebase = . false . ipound = index ( string_local , '#' ) ! determine if in form [-]base#whole if ( basein == 0. and . ipound > 1 ) then ! split string into two values call string_to_value ( string_local (: ipound - 1 ), basein_local , ierr ) ! get the decimal value of the base string_local = string_local ( ipound + 1 :) ! now that base is known make string just the value if ( basein_local >= 0 ) then ! allow for a negative sign prefix out_sign = 1 else out_sign =- 1 endif basein_local = abs ( basein_local ) else ! assume string is a simple positive value basein_local = abs ( basein ) out_sign = 1 endif out_baseten = 0 y = 0.0 ALL : if ( basein_local < 2. or . basein_local > 36 ) then print * , '(*decodebase* ERROR: Base must be between 2 and 36. base=' , basein_local else ALL out_baseten = 0 ; y = 0.0 ; mult = 1.0 long = LEN_TRIM ( string_local ) do i = 1 , long k = long + 1 - i ch = string_local ( k : k ) if ( ch == '-' . and . k == 1 ) then out_sign =- 1 cycle endif if ( ch < '0' . or . ch > 'Z' . or .( ch > '9' . and . ch < 'A' )) then write ( * , * ) '*decodebase* ERROR: invalid character ' , ch exit ALL endif if ( ch <= '9' ) then j = IACHAR ( ch ) - IACHAR ( '0' ) else j = IACHAR ( ch ) - IACHAR ( 'A' ) + 10 endif if ( j >= basein_local ) then exit ALL endif y = y + mult * j if ( mult > XMAXREAL / basein_local ) then exit ALL endif mult = mult * basein_local enddo decodebase = . true . out_baseten = nint ( out_sign * y ) * sign ( 1 , basein ) endif ALL end function decodebase logical function codebase ( inval10 , outbase , answer ) implicit none integer , intent ( in ) :: inval10 integer , intent ( in ) :: outbase character ( len =* ), intent ( out ) :: answer integer :: n real :: inval10_local integer :: outbase_local integer :: in_sign answer = '' in_sign = sign ( 1 , inval10 ) * sign ( 1 , outbase ) inval10_local = abs ( inval10 ) outbase_local = abs ( outbase ) if ( outbase_local < 2. or . outbase_local > 36 ) then print * , '*codebase* ERROR: base must be between 2 and 36. base was' , outbase_local codebase = . false . else do while ( inval10_local > 0.0 ) n = INT ( inval10_local - outbase_local * INT ( inval10_local / outbase_local )) if ( n < 10 ) then answer = ACHAR ( IACHAR ( '0' ) + n ) // answer else answer = ACHAR ( IACHAR ( 'A' ) + n - 10 ) // answer endif inval10_local = INT ( inval10_local / outbase_local ) enddo codebase = . true . endif if ( in_sign == - 1 ) then answer = '-' // trim ( answer ) endif if ( answer == '' ) then answer = '0' endif end function codebase function todecimal ( base , instr ) character ( len = 36 ), parameter :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\" integer , intent ( in ) :: base character ( * ), intent ( in ) :: instr character ( len = :), allocatable :: instr_local integer :: todecimal integer :: length , i , n instr_local = trim ( lower ( instr )) todecimal = 0 length = len ( instr_local ) do i = 1 , length n = index ( alphanum , instr_local ( i : i )) - 1 n = n * base ** ( length - i ) todecimal = todecimal + n enddo end function todecimal function tobase ( base , number ) character ( len = 36 ), parameter :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\" integer , intent ( in ) :: base integer , intent ( in ) :: number character ( len = :), allocatable :: tobase character ( len = 31 ) :: holdit integer :: number_local , i , rem number_local = number holdit = \"                               \" do i = 31 , 1 , - 1 if ( number_local < base ) then holdit ( i : i ) = alphanum ( number_local + 1 : number_local + 1 ) exit endif rem = mod ( number_local , base ) holdit ( i : i ) = alphanum ( rem + 1 : rem + 1 ) number_local = number_local / base enddo tobase = adjustl ( holdit ) end function tobase function paragraph ( source_string , length ) character ( len =* ), intent ( in ) :: source_string integer , intent ( in ) :: length integer :: itoken integer :: istart integer :: iend character ( len =* ), parameter :: delimiters = ' ' character ( len = :), allocatable :: paragraph (:) integer :: ilines integer :: ilength integer :: iword , iword_max integer :: i do i = 1 , 2 iword_max = 0 ! length of longest token ilines = 1 ! number of output line output will go on ilength = 0 ! length of output line so far itoken = 0 ! must set ITOKEN=0 before looping on strtok(3f) on a new string. do while ( strtok ( source_string , itoken , istart , iend , delimiters ) ) iword = iend - istart + 1 iword_max = max ( iword_max , iword ) if ( iword > length ) then ! this token is longer than the desired line length so put it on a line by itself if ( ilength /= 0 ) then ilines = ilines + 1 endif if ( i == 2 ) then ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph paragraph ( ilines ) = source_string ( istart : iend ) // ' ' endif ilength = iword + 1 elseif ( ilength + iword <= length ) then ! this word will fit on current line if ( i == 2 ) then paragraph ( ilines ) = paragraph ( ilines )(: ilength ) // source_string ( istart : iend ) endif ilength = ilength + iword + 1 else ! adding this word would make line too long so start new line ilines = ilines + 1 ilength = 0 if ( i == 2 ) then paragraph ( ilines ) = paragraph ( ilines )(: ilength ) // source_string ( istart : iend ) endif ilength = iword + 1 endif enddo if ( i == 1 ) then ! determined number of lines needed so allocate output array allocate ( character ( len = max ( length , iword_max )) :: paragraph ( ilines )) paragraph = ' ' endif enddo paragraph = paragraph (: ilines ) end function paragraph function setbits8 ( string ) result ( answer ) implicit none integer ( kind = int8 ) :: answer character ( len = 8 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int8 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits8* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , lgth select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits8* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits8 function setbits16 ( string ) result ( answer ) implicit none integer ( kind = int16 ) :: answer character ( len = 16 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int16 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits16* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits16* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits16 function setbits32 ( string ) result ( answer ) implicit none integer ( kind = int32 ) :: answer character ( len = 32 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int32 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits32* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits32* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits32 function setbits64 ( string ) result ( answer ) implicit none integer ( kind = int64 ) :: answer character ( len = 64 ), intent ( in ) :: string integer :: pos integer :: lgth answer = 0_int64 lgth = len ( string ) if ( lgth /= bit_size ( answer )) then write ( stderr , * ) '*setbits64* wrong string length =' , lgth lgth = min ( lgth , int ( bit_size ( answer ))) endif do pos = 1 , len ( string ) select case ( string ( pos : pos )) case ( '1' ) answer = ibset ( answer , pos - 1 ) case ( '0' ) answer = ibclr ( answer , pos - 1 ) case default write ( stderr , * ) '*setbits64* unknown value. must be 0 or 1. found [' , string ( pos : pos ), '] at position ' , pos , ' in ' , string end select enddo end function setbits64 function msg_scalar ( generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , sep ) implicit none class ( * ), intent ( in ), optional :: generic1 , generic2 , generic3 , generic4 , generic5 class ( * ), intent ( in ), optional :: generic6 , generic7 , generic8 , generic9 character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local character ( len = :), allocatable :: msg_scalar character ( len = 4096 ) :: line integer :: istart integer :: increment if ( present ( sep )) then sep_local = sep increment = len ( sep ) + 1 else sep_local = ' ' increment = 2 endif istart = 1 line = ' ' if ( present ( generic1 )) call print_generic ( generic1 ) if ( present ( generic2 )) call print_generic ( generic2 ) if ( present ( generic3 )) call print_generic ( generic3 ) if ( present ( generic4 )) call print_generic ( generic4 ) if ( present ( generic5 )) call print_generic ( generic5 ) if ( present ( generic6 )) call print_generic ( generic6 ) if ( present ( generic7 )) call print_generic ( generic7 ) if ( present ( generic8 )) call print_generic ( generic8 ) if ( present ( generic9 )) call print_generic ( generic9 ) msg_scalar = trim ( line ) contains subroutine print_generic ( generic ) class ( * ), intent ( in ) :: generic select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic !x!type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic !x!type is (real(kind=real256));     write(line(istart:),'(1pg0)') generic type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep_local end subroutine print_generic end function msg_scalar function msg_one ( generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , sep ) implicit none class ( * ), intent ( in ) :: generic1 (:) class ( * ), intent ( in ), optional :: generic2 (:), generic3 (:), generic4 (:), generic5 (:) class ( * ), intent ( in ), optional :: generic6 (:), generic7 (:), generic8 (:), generic9 (:) character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local character ( len = :), allocatable :: msg_one character ( len = 4096 ) :: line integer :: istart integer :: increment if ( present ( sep )) then sep_local = sep increment = len ( sep ) + 1 else sep_local = ' ' increment = 2 endif istart = 1 line = ' ' call print_generic ( generic1 ) if ( present ( generic2 )) call print_generic ( generic2 ) if ( present ( generic3 )) call print_generic ( generic3 ) if ( present ( generic4 )) call print_generic ( generic4 ) if ( present ( generic5 )) call print_generic ( generic5 ) if ( present ( generic6 )) call print_generic ( generic6 ) if ( present ( generic7 )) call print_generic ( generic7 ) if ( present ( generic8 )) call print_generic ( generic8 ) if ( present ( generic9 )) call print_generic ( generic9 ) msg_one = trim ( line ) contains subroutine print_generic ( generic ) class ( * ), intent ( in ), optional :: generic (:) integer :: i select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic !x!type is (real(kind=real128));     write(line(istart:),'(\"[\",*(1pg0,1x))') generic !x!type is (real(kind=real256));     write(line(istart:),'(\"[\",*(1pg0,1x))') generic type is ( logical ); write ( line ( istart :), '(\"[\",*(l1,1x))' ) generic type is ( character ( len =* )); write ( line ( istart :), '(\"[\",:*(\"\"\"\",a,\"\"\"\",1x))' ) ( trim ( generic ( i )), i = 1 , size ( generic )) type is ( complex ); write ( line ( istart :), '(\"[\",*(\"(\",1pg0,\",\",1pg0,\")\",1x))' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // \"]\" // sep_local end subroutine print_generic end function msg_one subroutine find_field ( string , field , position , delims , delim , found ) character * ( * ), intent ( in ) :: string character * ( * ), intent ( out ) :: field integer , optional , intent ( inout ) :: position character * ( * ), optional , intent ( in ) :: delims character * ( * ), optional , intent ( out ) :: delim logical , optional , intent ( out ) :: found character :: delimiter * 1 integer :: pos , field_start , field_end , i logical :: trim_blanks field = '' delimiter = char ( 0 ) pos = 1 if ( present ( found )) found = . false . if ( present ( position )) pos = position if ( pos > len ( string )) goto 9000 !if (pos < 1) error stop 'Illegal position in find_field' if ( pos < 1 ) stop 'Illegal position in find_field' !-- Skip leading blanks if blank is a delimiter. field_start = pos trim_blanks = . true . if ( present ( delims )) trim_blanks = index ( delims , ' ' ) /= 0 if ( trim_blanks ) then i = verify ( string ( pos :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 goto 9000 end if field_start = pos + i - 1 end if if ( present ( found )) found = . true . !-- Find the end of the field. if ( present ( delims )) then i = scan ( string ( field_start :), delims ) else i = scan ( string ( field_start :), ' ' ) end if if ( i == 0 ) then field_end = len ( string ) delimiter = char ( 0 ) pos = field_end + 1 else field_end = field_start + i - 2 delimiter = string ( field_end + 1 : field_end + 1 ) pos = field_end + 2 end if !-- Return the field. field = string ( field_start : field_end ) !-- Skip trailing blanks if blank is a delimiter. if ( trim_blanks ) then i = verify ( string ( field_end + 1 :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 goto 9000 end if pos = field_end + i !-- If the first non-blank character is a delimiter, !-- skip blanks after it. i = 0 if ( present ( delims )) i = index ( delims , string ( pos : pos )) if ( i /= 0 ) then delimiter = string ( pos : pos ) pos = pos + 1 i = verify ( string ( pos :), ' ' ) if ( i == 0 ) then pos = len ( string ) + 1 else pos = pos + i - 1 end if end if end if !---------- Normal exit. 9000 continue if ( present ( delim )) delim = delimiter if ( present ( position )) position = pos end subroutine find_field pure subroutine split_tokens ( string , set , tokens , separator ) ! Splits a string into tokens using characters in set as token delimiters. ! If present, separator contains the array of token delimiters. character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: set character (:), allocatable , intent ( out ) :: tokens (:) character , allocatable , intent ( out ), optional :: separator (:) integer , allocatable :: first (:), last (:) integer :: n call split2020 ( string , set , first , last ) allocate ( character ( len = maxval ( last - first ) + 1 ) :: tokens ( size ( first ))) do concurrent ( n = 1 : size ( tokens )) tokens ( n ) = string ( first ( n ): last ( n )) enddo if ( present ( separator )) then allocate ( separator ( size ( tokens ) - 1 )) do concurrent ( n = 1 : size ( tokens ) - 1 ) separator ( n ) = string ( first ( n + 1 ) - 1 : first ( n + 1 ) - 1 ) enddo endif end subroutine split_tokens pure subroutine split_first_last ( string , set , first , last ) ! Computes the first and last indices of tokens in input string, delimited ! by the characters in set, and stores them into first and last output ! arrays. character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) character :: set_array ( len ( set )) logical , dimension ( len ( string )) :: is_first , is_last , is_separator integer :: n , slen slen = len ( string ) do concurrent ( n = 1 : len ( set )) set_array ( n ) = set ( n : n ) enddo do concurrent ( n = 1 : slen ) is_separator ( n ) = any ( string ( n : n ) == set_array ) enddo is_first = . false . is_last = . false . if (. not . is_separator ( 1 )) is_first ( 1 ) = . true . do concurrent ( n = 2 : slen - 1 ) if (. not . is_separator ( n )) then if ( is_separator ( n - 1 )) is_first ( n ) = . true . if ( is_separator ( n + 1 )) is_last ( n ) = . true . else if ( is_separator ( n - 1 )) then is_first ( n ) = . true . is_last ( n - 1 ) = . true . endif endif enddo if (. not . is_separator ( slen )) is_last ( slen ) = . true . first = pack ([( n , n = 1 , slen )], is_first ) last = pack ([( n , n = 1 , slen )], is_last ) end subroutine split_first_last pure subroutine split_pos ( string , set , pos , back ) ! If back is absent, computes the leftmost token delimiter in string whose ! position is > pos. If back is present and true, computes the rightmost ! token delimiter in string whose position is < pos. The result is stored ! in pos. character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: set integer , intent ( in out ) :: pos logical , intent ( in ), optional :: back logical :: backward character :: set_array ( len ( set )) integer :: n , result_pos !TODO use optval when implemented in stdlib !backward = optval(back, .false.) backward = . false . if ( present ( back )) backward = back do concurrent ( n = 1 : len ( set )) set_array ( n ) = set ( n : n ) enddo if ( backward ) then result_pos = 0 do n = pos - 1 , 1 , - 1 if ( any ( string ( n : n ) == set_array )) then result_pos = n exit endif enddo else result_pos = len ( string ) + 1 do n = pos + 1 , len ( string ) if ( any ( string ( n : n ) == set_array )) then result_pos = n exit endif enddo endif pos = result_pos end subroutine split_pos pure function string_tokens ( string , set ) result ( tokens ) ! Splits a string into tokens using characters in set as token delimiters. character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: set character (:), allocatable :: tokens (:) call split_tokens ( string , set , tokens ) end function string_tokens subroutine where_write_message ( where , msg ) character ( len =* ), intent ( in ) :: where character ( len =* ), intent ( in ) :: msg logical , save :: trailopen = . false . integer , save :: itrail character , save :: comment = '#' integer :: i integer :: ios integer :: times ! number of times written to stdout character ( len = 3 ) :: adv ! whether remaining writes from this call use advancing I/O character ( len = :), allocatable , save :: prefix_template ! string to run thru now_ex(3f) to make prefix character ( len = :), allocatable :: prefix ! the prefix string to add to output logical , save :: prefix_it = . false . ! flag whether time prefix mode is on or not character ( len = 4096 ) :: mssge adv = 'yes' prefix = '' times = 0 do i = 1 , len_trim ( where ) select case ( where ( i : i )) case ( 'T' , 't' ) if ( trailopen ) then write ( itrail , '(a)' , advance = adv ) prefix // trim ( msg ) !elseif(times == 0)then !   write(stdout,'(a)',advance=adv)prefix//trim(msg) !   times=times+1 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'S' , 's' ) write ( stdout , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( 'E' , 'e' ) write ( stderr , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( '+' ); adv = 'no' !----------------------------------------------------------------------------------------------------------------------------- case ( '>' ); debug = . true . !----------------------------------------------------------------------------------------------------------------------------- case ( '<' ); debug = . false . !----------------------------------------------------------------------------------------------------------------------------- case ( '%' ) ! setting timestamp prefix if ( msg == '' ) then ! if message is blank turn off prefix prefix_it = . false . else ! store message as string to pass to now_ex() on subsequent calls to make prefix prefix_template = msg prefix_it = . true . endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'N' ) ! new name for stdout if ( msg /= ' ' . and . msg /= '#N#' . and . msg /= '\"#N#\"' ) then ! if filename not special or blank open new file close ( unit = last_int , iostat = ios ) open ( unit = last_int , file = adjustl ( trim ( msg )), iostat = ios ) if ( ios == 0 ) then stdout = last_int else write ( * , * ) '*journal* error opening redirected output file, ioerr=' , ios write ( * , * ) '*journal* msg=' // trim ( msg ) endif elseif ( msg == ' ' ) then close ( unit = last_int , iostat = ios ) stdout = 6 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'C' , 'c' ) if ( trailopen ) then write ( itrail , '(3a)' , advance = adv ) prefix , comment , trim ( msg ) elseif ( times == 0 ) then ! write(stdout,'(2a)',advance=adv)prefix,trim(msg) ! times=times+1 endif case ( 'D' , 'd' ) if ( debug ) then if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'DEBUG: ' , trim ( msg ) elseif ( times == 0 ) then write ( stdout , '(3a)' , advance = adv ) prefix , 'DEBUG:' , trim ( msg ) times = times + 1 endif endif case ( 'F' , 'f' ) flush ( unit = itrail , iostat = ios , iomsg = mssge ) if ( ios /= 0 ) then write ( * , '(a)' ) trim ( mssge ) endif case ( 'A' , 'a' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )),& & form = 'formatted' , iostat = ios , position = 'append' ) trailopen = . true . endif case ( 'O' , 'o' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )), form = 'formatted' , iostat = ios ) trailopen = . true . else if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'closing trail file:' , trim ( msg ) endif close ( unit = itrail , iostat = ios ) trailopen = . false . endif case default write ( stdout , '(a)' , advance = adv ) '*journal* bad WHERE value ' // trim ( where ) // ' when msg=[' // trim ( msg ) // ']' end select enddo end subroutine where_write_message subroutine flush_trail () call where_write_message ( 'F' , 'IGNORE THIS STRING' ) end subroutine flush_trail subroutine set_stdout_lun ( iounit ) integer , intent ( in ) :: iounit stdout = iounit end subroutine set_stdout_lun subroutine where_write_message_all ( where , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , nospace ) implicit none character ( len =* ), intent ( in ) :: where class ( * ), intent ( in ) :: g0 class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 logical , intent ( in ), optional :: nospace !call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,nospace)) end subroutine where_write_message_all subroutine write_message_only ( message ) character ( len =* ), intent ( in ) :: message call where_write_message ( 'sc' , trim ( message )) end subroutine write_message_only function str_scalar ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , & & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj , & & sep ) implicit none class ( * ), intent ( in ), optional :: generic0 , generic1 , generic2 , generic3 , generic4 class ( * ), intent ( in ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 class ( * ), intent ( in ), optional :: generica , genericb , genericc , genericd , generice class ( * ), intent ( in ), optional :: genericf , genericg , generich , generici , genericj character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: str_scalar character ( len = 4096 ) :: line integer :: istart integer :: increment character ( len = :), allocatable :: sep_local if ( present ( sep )) then sep_local = sep increment = len ( sep ) + 1 else sep_local = ' ' increment = 2 endif istart = 1 line = '' if ( present ( generic0 )) call print_generic ( generic0 ) if ( present ( generic1 )) call print_generic ( generic1 ) if ( present ( generic2 )) call print_generic ( generic2 ) if ( present ( generic3 )) call print_generic ( generic3 ) if ( present ( generic4 )) call print_generic ( generic4 ) if ( present ( generic5 )) call print_generic ( generic5 ) if ( present ( generic6 )) call print_generic ( generic6 ) if ( present ( generic7 )) call print_generic ( generic7 ) if ( present ( generic8 )) call print_generic ( generic8 ) if ( present ( generic9 )) call print_generic ( generic9 ) if ( present ( generica )) call print_generic ( generica ) if ( present ( genericb )) call print_generic ( genericb ) if ( present ( genericc )) call print_generic ( genericc ) if ( present ( genericd )) call print_generic ( genericd ) if ( present ( generice )) call print_generic ( generice ) if ( present ( genericf )) call print_generic ( genericf ) if ( present ( genericg )) call print_generic ( genericg ) if ( present ( generich )) call print_generic ( generich ) if ( present ( generici )) call print_generic ( generici ) if ( present ( genericj )) call print_generic ( genericj ) str_scalar = trim ( line ) contains subroutine print_generic ( generic ) class ( * ), intent ( in ) :: generic select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic !x!type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic !x!type is (real(kind=real256));     write(line(istart:),'(1pg0)') generic type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep_local end subroutine print_generic end function str_scalar function str_one ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , sep ) implicit none class ( * ), intent ( in ) :: generic0 (:) class ( * ), intent ( in ), optional :: generic1 (:), generic2 (:), generic3 (:), generic4 (:), generic5 (:) class ( * ), intent ( in ), optional :: generic6 (:), generic7 (:), generic8 (:), generic9 (:) character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local character ( len = :), allocatable :: str_one character ( len = 4096 ) :: line integer :: istart integer :: increment if ( present ( sep )) then sep_local = sep increment = len ( sep ) + 1 else sep_local = ' ' increment = 2 endif istart = 1 line = ' ' call print_generic ( generic0 ) if ( present ( generic1 )) call print_generic ( generic1 ) if ( present ( generic2 )) call print_generic ( generic2 ) if ( present ( generic3 )) call print_generic ( generic3 ) if ( present ( generic4 )) call print_generic ( generic4 ) if ( present ( generic5 )) call print_generic ( generic5 ) if ( present ( generic6 )) call print_generic ( generic6 ) if ( present ( generic7 )) call print_generic ( generic7 ) if ( present ( generic8 )) call print_generic ( generic8 ) if ( present ( generic9 )) call print_generic ( generic9 ) str_one = trim ( line ) contains subroutine print_generic ( generic ) class ( * ), intent ( in ), optional :: generic (:) integer :: i select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic !x!type is (real(kind=real128));     write(line(istart:),'(\"[\",*(1pg0,1x))') generic !x!type is (real(kind=real256));     write(line(istart:),'(\"[\",*(1pg0,1x))') generic type is ( logical ); write ( line ( istart :), '(\"[\",*(l1,1x))' ) generic type is ( character ( len =* )); write ( line ( istart :), '(\"[\",:*(\"\"\"\",a,\"\"\"\",1x))' ) ( trim ( generic ( i )), i = 1 , size ( generic )) type is ( complex ); write ( line ( istart :), '(\"[\",*(\"(\",1pg0,\",\",1pg0,\")\",1x))' ) generic class default stop 'unknown type in *print_generic*' end select line = trim ( line ) // \"]\" // sep_local istart = len_trim ( line ) + increment end subroutine print_generic end function str_one function lowercase ( str ) result ( lcstr ) character ( len =* ) :: str character ( len = len_trim ( str )) :: lcstr integer :: lgth integer :: ioffset integer :: iquote integer :: i integer :: iav integer :: iqc lgth = len_trim ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 lcstr = str do i = 1 , lgth iav = iachar ( str ( i : i )) if ( iquote == 0 . and . ( iav == 34 . or . iav == 39 )) then iquote = 1 iqc = iav cycle endif if ( iquote == 1 . and . iav == iqc ) then iquote = 0 cycle endif if ( iquote == 1 ) cycle if ( iav >= iachar ( 'A' ) . and . iav <= iachar ( 'Z' )) then lcstr ( i : i ) = achar ( iav - ioffset ) else lcstr ( i : i ) = str ( i : i ) endif enddo end function lowercase function uppercase ( str ) result ( ucstr ) character ( len =* ) :: str character ( len = len_trim ( str )) :: ucstr integer :: lgth integer :: ioffset integer :: iquote integer :: i integer :: iav integer :: iqc lgth = len_trim ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 ucstr = str do i = 1 , lgth iav = iachar ( str ( i : i )) if ( iquote == 0 . and . ( iav == 34 . or . iav == 39 )) then iquote = 1 iqc = iav cycle endif if ( iquote == 1 . and . iav == iqc ) then iquote = 0 cycle endif if ( iquote == 1 ) cycle if ( iav >= iachar ( 'a' ) . and . iav <= iachar ( 'z' )) then ucstr ( i : i ) = achar ( iav + ioffset ) else ucstr ( i : i ) = str ( i : i ) endif enddo end function uppercase impure elemental subroutine matching_delimiter ( str , ipos , imatch ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: ipos integer , intent ( out ) :: imatch character :: delim1 , delim2 , ch integer :: lenstr integer :: idelim2 integer :: istart , iend integer :: inc integer :: isum integer :: i imatch = 0 lenstr = len_trim ( str ) delim1 = str ( ipos : ipos ) select case ( delim1 ) case ( '(' ) idelim2 = iachar ( delim1 ) + 1 istart = ipos + 1 iend = lenstr inc = 1 case ( ')' ) idelim2 = iachar ( delim1 ) - 1 istart = ipos - 1 iend = 1 inc =- 1 case ( '[' , '{' , '<' ) idelim2 = iachar ( delim1 ) + 2 istart = ipos + 1 iend = lenstr inc = 1 case ( ']' , '}' , '>' ) idelim2 = iachar ( delim1 ) - 2 istart = ipos - 1 iend = 1 inc =- 1 case default write ( * , * ) delim1 , ' is not a valid delimiter' return end select if ( istart < 1 . or . istart > lenstr ) then write ( * , * ) delim1 , ' has no matching delimiter' return endif delim2 = achar ( idelim2 ) ! matching delimiter isum = 1 do i = istart , iend , inc ch = str ( i : i ) if ( ch /= delim1 . and . ch /= delim2 ) cycle if ( ch == delim1 ) isum = isum + 1 if ( ch == delim2 ) isum = isum - 1 if ( isum == 0 ) exit enddo if ( isum /= 0 ) then write ( * , * ) delim1 , ' has no matching delimiter' return endif imatch = i end subroutine matching_delimiter function longest_common_substring ( a , b ) result ( match ) character ( len =* ), intent ( in ) :: a , b character ( len = :), allocatable :: match character ( len = :), allocatable :: a2 , b2 integer :: left , foundat , len_a , i if ( len ( a ) < len ( b )) then ! to reduce required comparisions look for shortest string in longest string a2 = a b2 = b else a2 = b b2 = a endif match = '' do i = 1 , len ( a2 ) - 1 len_a = len ( a2 ) do left = 1 , len_a foundat = index ( b2 , a2 ( left :)) if ( foundat /= 0. and . len ( match ) < len_a - left + 1 ) then if ( len ( a2 ( left :)) > len ( match )) then match = a2 ( left :) exit endif endif enddo if ( len ( a2 ) < len ( match )) exit a2 = a2 (: len ( a2 ) - 1 ) enddo end function longest_common_substring end module M_strings","tags":"","loc":"sourcefile/m_strings.f90.html"},{"title":"M_strings_oop.f90 – M_strings","text":"Contents Modules M_strings_oop Source Code M_strings_oop.f90 Source Code !> !!##NAME !!    M_strings_oop(3f) - [M_strings::INTRO::OOPS] OOP Fortran string module !! !!##SYNOPSIS !! !!    use M_strings_oop !! !!##DESCRIPTION !!    The M_strings(3fm) module is a collection of Fortran procedures !!    that supplement the built-in intrinsic string routines. Routines !!    for parsing, tokenizing, changing case, substituting new strings for !!    substrings, locating strings with simple wildcard expressions, removing !!    tabs and line terminators and other string manipulations are included. !! !!    M_strings_oop(3fm) is a companion module that provides an OOP interface !!    to the M_strings module. !! !!##SEE ALSO !!    There are additional routines in other GPF modules for working with !!    expressions (M_calculator), time strings (M_time), random strings !!    (M_random, M_uuid), lists (M_list), and interfacing with the C regular !!    expression library (M_regex). !! !!##EXAMPLES !! !!    Each of the procedural functions in M_strings(3fm) includes an example !!    program in the corresponding man(1) page for the function. The !!    object-oriented interface does not have individual man(1) pages, !!    but is instead demonstrated using the following example program: !! !!     program demo_M_strings_oop !!     ! !!     ! This is an example using the object-oriented class/type model !!     ! defined in M_strings_oop !!     ! This is essentially the same functionality as the procedures !!     ! combined with several Fortran intrinsics and overloaded operators !!     ! !!     use M_strings_oop,only : string, p !!     implicit none !!     TYPE(string) :: str1 !!     TYPE(string) :: str2 !!     TYPE(string) :: str3 !!     TYPE(string) :: str4 !!     !==================================================================== !!       write(*,*)'exercise the M_STRING_OOP module interface' !!       ! draw a break line in the output !!       write(*,*)repeat('=',68) !!       write(*,*)'Call methods of type(STRING)' !!       ! define TYPE(STRING) with constructor !!       str2=string('   This  is  a  String!       ') !!       str4=string(' a  String ') !!       write(*,*)repeat('=',68) !!       ! print members of type !!       write(*,101)'str2%str is ................ ',str2%str !!       ! same as intrinsic LEN() !!       write(*,202)'len ........................ ',str2%len() !!       ! same as intrinsic LEN_TRIM() !!       write(*,202)'len_trim ................... ',str2%len_trim() !!       ! same as intrinsic INDEX() !!       write(*,202)'index(\"is\")................. ',str2%index(\"is\") !!       ! same as intrinsic INDEX() !!       write(*,202)'index(\"is\",back=.T.) ....... ',str2%index(\"is\",back=.TRUE.) !!       ! output TYPE(STRING) with %str all uppercase !!       write(*,101)'upper ...................... ',p(str2%upper()) !!       ! output TYPE(STRING) with %str all miniscule !!       write(*,101)'lower ...................... ',p(str2%lower()) !!       ! output TYPE(STRING) with %str reversed !!       write(*,101)'reverse .................... ',p(str2%reverse()) !!       ! same as intrinsic ADJUSTL() !!       write(*,101)'adjustl .................... ',p(str2%adjustl()) !!       ! same as intrinsic ADJUSTR() !!       write(*,101)'adjustr .................... ',p(str2%adjustr()) !!       ! center string in current string length !!       write(*,101)'adjustc .................... ',p(str2%adjustc()) !!       ! center string in string length of NN !!       write(*,101)'adjustc(40) ................ ',p(str2%adjustc(40)) !!       ! force %str to be NN characters long !!       write(*,101)'lenset(40) ................. ',p(str2%lenset(40)) !!       ! same as intrinsic TRIM() !!       write(*,101)'trim ....................... ',p(str2%trim()) !!       ! trim leading and trailing spaces !!       write(*,101)'crop ....................... ',p(str2%crop()) !!       ! calls M_strings procedure SUBSTITUTE() !!       write(*,101)'substitute(\"This\",\"Here\") .. ',& !!               & p(str2%substitute(\"This\",\"Here\")) !!       ! calls M_strings procedure COMPACT() !!       write(*,101)'compact .................... ',p(str2%compact()) !!       write(*,101)'compact(\"\") ................ ',p(str2%compact(\"\")) !!       write(*,101)'compact(\":\") ............... ',p(str2%compact(\":\")) !!       ! calls M_strings procedure TRANSLITERATE() !!       write(*,101)'transliterate(\"aei\",\"VWX\") . ',& !!               & p(str2%transliterate(\"aei\",\"VWX\")) !!       write(*,101)'transliterate(\"aeiou\",\" \") . ',& !!               & p(str2%transliterate(\"aeiou\",\" \")) !!       write(*,101)'transliterate(\"aeiou\",\"\") .. ',& !!               & p(str2%transliterate(\"aeiou\",\"\")) !!       write(*,101)'transliterate(\" aeiou\",\"\") . ',& !!               & p(str2%transliterate(\" aeiou\",\"\")) !!       ! calls M_strings procedure SWITCH() !!       write(*,404)'chars .................... . ',str4%chars() !! !!       write(*,*)repeat('=',68) !!       str2%str='\\t\\tSome tabs\\t   x\\bX ' !!       write(*,101)'str2%str ................... ',str2%str !!       write(*,101)'expand ..................... ',p(str2%expand()) !!       str2=str2%expand() !!       ! calls M_strings procedure NOTABS() !!       write(*,101)'notabs ..................... ',p(str2%notabs()) !!       ! calls M_strings procedure NOESC() !!       write(*,101)'noesc ...................... ',p(str2%noesc()) !! !!       write(*,*)repeat('=',68) !!       write(*,*)'Casting to numeric variables' !!       str3=string('   12.345678901234567e1        ') !!       write(*,101)'str3%str ................... ',str3%str !!       ! calls M_strings procedure STRING_TO_VALUE() !!       write(*,*)'int  ....................... ', str3%int() !!       ! calls M_strings procedure STRING_TO_VALUE() !!       write(*,*)'real ....................... ', str3%real() !!       ! calls M_strings procedure STRING_TO_VALUE() !!       write(*,*)'dble ....................... ', str3%dble() !! !!       write(*,*)repeat('=',68) !!       write(*,*)'Matching simple globbing patterns' !!       str3=string('   12.345678901234567e1        ') !!       str3=string('Four score and seven years ago') !!       write(*,101)'str3%str ................... ',str3%str !!       ! calls M_strings procedure MATCHW !!       write(*,*)'match(\"Fo*\") ............... ', str3%match(\"Fo*\") !!       ! calls M_strings procedure MATCHW !!       write(*,*)'match(\"and\") ............... ', str3%match(\"and\") !!       ! calls M_strings procedure MATCHW !!       write(*,*)'match(\"*and*\") ............. ', str3%match(\"*and*\") !! !!       101 format(1x,a,\"[\",a,\"]\") !!       202 format(1x,a,i0) !!       303 format(1x,*(l3)) !!       404 format(1x,a,*(\"[\",a1,\"]\":)) !! !!       write(*,*)repeat('=',68) !!       write(*,*)'OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))' !!       str1%str='123.456' !!       str2%str='AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj' !!       write(*,101)'str1%str ................... ',str1%str !!       write(*,101)'str2%str ................... ',str2%str !!       write(*,*)'str1 + str2 ................ ',p(str1 + str2) !!       ! a string that looks like a numeric value can have a value added !!       write(*,*)'str1 + 20000 ............... ',p(str1 +20000) !!       write(*,*)'str1 - 20.0 ................ ',p(str1 -20.0) !!       write(*,*)'str2 - \"Aa\" (removes ALL) .. ',p(str2 - 'Aa') !! !!       write(*,*)repeat('=',68) !!       write(*,*)'OVERLOADED OPERATORS (multiply,return TYPE(STRING))' !!       str1%str='AaBbCcDdEeFfGgHhIiJj' !!       write(*,101)'str1%str ................... ',str1%str !!       write(*,*)'str1 * 2 ................... ',p(str1 * 2) !! !!       write(*,*)repeat('=',68) !!       write(*,*)'OVERLOADED OPERATORS (//,return TYPE(STRING))' !!       str1%str='String one:' !!       str2%str='String two:' !!       write(*,101)'str1%str ................... ',str1%str !!       write(*,101)'str2%str ................... ',str2%str !!       write(*,*)'str1 // str2 ................ ',p(str1 // str2) !!       ! numeric values are converted to strings !!       write(*,*)'str1 // 20000 ............... ',p(str1 // 20000) !!       write(*,*)'str1 // 20.0 ................ ',p(str1 // 20.0) !! !!       write(*,*)repeat('=',68) !!       write(*,*)'OVERLOADED OPERATORS (logical comparisons,return logical)' !!       ! NOTE: comparisons are performed on the character variable members !!       !       of the type(string) !!       str1%str='abcdefghij' !!       str2%str='klmnopqrst' !!       write(*,101)'str1%str ................... ',str1%str !!       write(*,101)'str2%str ................... ',str2%str !!       write(*,*)': EQ LT GT LE GE NE' !!       write(*,*)'compare str1 to str1' !!       write(*,303)str1 == str1  ,str1 < str1  ,str1 > str1  ,str1 <= str1 & !!                  & ,str1 >= str1  ,str1 /= str1 !!       write(*,*)'compare str1 to str2' !!       write(*,303)str1 == str2  ,str1 < str2  ,str1 > str2  ,str1 <= str2 & !!                  & ,str1 >= str2  ,str1 /= str2 !!       write(*,*)'compare str2 to str1' !!       write(*,303)str2 == str1  ,str2 < str1  ,str2 > str1  ,str2 <= str1 & !!                  & ,str2 >= str1  ,str2 /= str1 !! !!       write(*,*)repeat('=',68) !! !!     end program demo_M_strings_oop !! !! Expected output !! !!   exercise the M_STRING_OOP module interface !!   =================================================================== !!   Call methods of type(STRING) !!   =================================================================== !!   str2%str is ................ [   This  is  a  String!             ] !!   len ........................ 36 !!   len_trim ................... 23 !!   index(\"is\")................. 6 !!   index(\"is\",back=.T.) ....... 10 !!   upper ...................... [   THIS  IS  A  STRING!             ] !!   lower ...................... [   this  is  a  string!             ] !!   reverse .................... [             !gnirtS  a  si  sihT   ] !!   adjustl .................... [This  is  a  String!                ] !!   adjustr .................... [                This  is  a  String!] !!   adjustc .................... [        This  is  a  String!        ] !!   adjustc(40) ................ [              This  is  a  String!      ] !!   lenset(40) ................. [   This  is  a  String!                 ] !!   trim ....................... [   This  is  a  String!] !!   crop ....................... [This  is  a  String!] !!   substitute(\"This\",\"Here\") .. [   Here  is  a  String!             ] !!   compact .................... [This is a String!] !!   compact(\"\") ................ [ThisisaString!] !!   compact(\":\") ............... [This:is:a:String!] !!   transliterate(\"aei\",\"VWX\") . [   ThXs  Xs  V  StrXng!             ] !!   transliterate(\"aeiou\",\" \") . [   Th s   s     Str ng!             ] !!   transliterate(\"aeiou\",\"\") .. [   Ths  s    Strng!                 ] !!   transliterate(\" aeiou\",\"\") . [ThssStrng!                          ] !!   chars .................... . [ ][a][ ][s][t][r][i][n][g][ ] !!   =================================================================== !!   str2%str ................... [\\t\\tSome tabs\\t   x\\bX ] !!   expand ..................... [         Some tabs          x   X] !!   notabs ..................... [                Some tabs          x    X] !!   noesc ...................... [  Some tabs    x X] !!   =================================================================== !!   Casting to numeric variables !!   str3%str ................... [   12.345678901234567e1        ] !!   int  .......................          123 !!   real .......................    123.456787 !!   dble .......................    123.45678901234567 !!   =================================================================== !!   Matching simple globbing patterns !!   str3%str ................... [Four score and seven years ago] !!   match(\"Fo*\") ...............  T !!   match(\"and\") ...............  F !!   match(\"*and*\") .............  T !!   ==================================================================== !!   OVERLOADED OPERATORS (add and subtract, return TYPE(STRING)) !!   str1%str ................... [123.456] !!   str2%str ................... [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj] !!   str1 + str2 ................ 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj !!   str1 + 20000 ............... 20123.455999999998 !!   str1 - 20.0 ................ -103.456 !!   str2 - \"Aa\" (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj !!   =================================================================== !!   OVERLOADED OPERATORS (multiply, return TYPE(STRING)) !!   str1%str ................... [AaBbCcDdEeFfGgHhIiJj] !!   str1 * 2 ................... AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj !!   =================================================================== !!   OVERLOADED OPERATORS (//, return TYPE(STRING)) !!   str1%str ................... [String one:] !!   str2%str ................... [String two:] !!   str1 // str2 ................ String one:String two: !!   str1 // 20000 ............... String one:20000 !!   str1 // 20.0 ................ String one:20.0 !!   =================================================================== !!   OVERLOADED OPERATORS (logical comparisons, return logical) !!   str1%str ................... [abcdefghij] !!   str2%str ................... [klmnopqrst] !!   : EQ LT GT LE GE NE !!   compare str1 to str1 !!   :  T  F  F  T  T  F !!   compare str1 to str2 !!   :  F  T  F  T  F  T !!   compare str2 to str1 !!   :  F  F  T  F  T  T !!   =================================================================== !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_strings_oop ! ! Define an OOP (Object-Oriented Programming) interface for the M_strings module. ! ! Leveraging the existing procedural functions in module M_strings to do the calculations allows ! this to be a definition of a derived type ( TYPE(STRING) ) and the ! methods it supports and overloading of operators to support the new data type. ! use M_strings , only : upper , lower ! case use M_strings , only : lenset , pad , lpad , cpad , rpad , zpad , adjustc , compact , crop ! whitespace use M_strings , only : reverse use M_strings , only : notabs , noesc , expand use M_strings , only : substitute , transliterate use M_strings , only : string_to_value , switch , v2s , s2v use M_strings , only : switch , split , matchw implicit none private integer , parameter , private :: dp = kind ( 0.0d0 ) public p !----------------------------------------------------------------------------------------------------------------------------------- public string !----------------------------------------------------------------------------------------------------------------------------------- !DERIVED TYPE STRING ! type string ! COMPONENTS: character ( len = :), allocatable :: str contains ! METHODS: procedure :: adjustc => oop_adjustc procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: compact => oop_compact procedure :: crop => oop_crop procedure :: dble => oop_dble procedure :: expand => oop_expand procedure :: index => oop_index procedure :: init => init_string procedure :: int => oop_int procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: lenset => oop_lenset procedure :: pad => oop_pad procedure :: lpad => oop_lpad procedure :: cpad => oop_cpad procedure :: rpad => oop_rpad procedure :: zpad => oop_zpad procedure :: match => oop_matchw procedure :: lower => oop_lower procedure :: noesc => oop_noesc procedure :: notabs => oop_notabs procedure :: real => oop_real procedure :: reverse => oop_reverse procedure :: substitute => oop_substitute procedure :: transliterate => oop_transliterate procedure :: trim => oop_trim procedure :: upper => oop_upper procedure :: chars => oop_switch !-!   procedure  ::  split          =>  oop_split !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(STRING) procedure , private :: eq generic :: operator ( == ) => eq procedure , private :: lt generic :: operator ( < ) => lt procedure , private :: gt generic :: operator ( > ) => gt procedure , private :: ge generic :: operator ( >= ) => ge procedure , private :: le generic :: operator ( <= ) => le procedure , private :: ne generic :: operator ( /= ) => ne procedure , private :: string_plus_value generic :: operator ( + ) => string_plus_value ! string + integer|real|doubleprecision|string|character procedure , private :: string_minus_value generic :: operator ( - ) => string_minus_value ! string - integer|real|doubleprecision|string|character procedure , private :: string_multiply_value generic :: operator ( * ) => string_multiply_value ! string * integer|real|doubleprecision procedure , private :: string_append_value generic :: operator ( // ) => string_append_value !-!   procedure,private :: minus_string !-!   generic           :: operator(-)  => minus_string end type !=================================================================================================================================== ! User-defined constructors are created by defining a generic interface ! with the same name as the derived type they're supposed to construct. interface string module procedure construct_from_fill end interface string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! this function is used internally in the module, but is also declared to be a constructor for creating TYPE(DATE_TYPE) structures ! function construct_from_fill ( chars , len ) ! ident_1=\"@(#) M_strings construct_from_fill(3f) construct TYPE(STRING)\" character ( len =* ), intent ( in ), optional :: chars integer , intent ( in ), optional :: len type ( string ) :: construct_from_fill if ( present ( chars )) then construct_from_fill % str = chars else construct_from_fill % str = '' endif if ( present ( len )) then construct_from_fill % str = lenset ( construct_from_fill % str , len ) endif end function construct_from_fill !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! DEFINE THE METHODS FOR THE TYPE ! These functions are privately used to define the methods that TYPE(STRING) will support !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_len ( self ) result ( length ) ! ident_2=\"@(#) M_strings oop_len(3f) length of string\" class ( string ), intent ( in ) :: self integer :: length length = len ( self % str ) end function oop_len !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_len_trim ( self ) result ( length ) ! ident_3=\"@(#) M_strings oop_len_trim(3f) trimmed length of string\" class ( string ), intent ( in ) :: self integer :: length length = len_trim ( self % str ) end function oop_len_trim !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_switch ( self ) result ( array ) ! ident_4=\"@(#) M_strings oop_switch(3f) convert string to array of single characters\" class ( string ), intent ( in ) :: self character ( len = 1 ) :: array ( len ( self % str )) array = switch ( self % str ) end function oop_switch !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_index ( self , substring , back ) result ( location ) ! ident_5=\"@(#) M_strings oop_index(3f) find starting position of a substring in a string\" class ( string ), intent ( in ) :: self character ( len =* ), intent ( in ) :: substring integer :: location logical , optional , intent ( in ) :: back if ( present ( back )) then location = index ( self % str , substring , back ) else location = index ( self % str , substring ) endif end function oop_index !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_upper ( self ) result ( string_out ) ! ident_6=\"@(#) M_strings oop_upper(3f) convert string to uppercase\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = upper ( self % str ) end function oop_upper !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_lower ( self ) result ( string_out ) ! ident_7=\"@(#) M_strings oop_lower(3f) convert string to miniscule\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = lower ( self % str ) end function oop_lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_expand ( self , escape_char ) result ( string_out ) ! ident_8=\"@(#) M_strings oop_expand(3f) expand common escape sequences by calling expand(3f)\" class ( string ), intent ( in ) :: self character , intent ( in ), optional :: escape_char type ( string ) :: string_out if ( present ( escape_char )) then string_out % str = expand ( self % str , escape_char ) else string_out % str = expand ( self % str ) endif end function oop_expand !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_trim ( self ) result ( string_out ) ! ident_9=\"@(#) M_strings oop_trim(3f) trim trailing spaces\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = trim ( self % str ) end function oop_trim !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_crop ( self ) result ( string_out ) ! ident_10=\"@(#) M_strings oop_crop(3f) crop leading and trailing spaces\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = crop ( self % str ) end function oop_crop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_reverse ( self ) result ( string_out ) ! ident_11=\"@(#) M_strings oop_reverse(3f) reverse string\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = reverse ( self % str ) end function oop_reverse !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_adjustl ( self ) result ( string_out ) ! ident_12=\"@(#) M_strings oop_adjustl(3f) adjust string to left\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = adjustl ( self % str ) end function oop_adjustl !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_adjustr ( self ) result ( string_out ) ! ident_13=\"@(#) M_strings oop_adjustr(3f) adjust string to right\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = adjustr ( self % str ) end function oop_adjustr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_adjustc ( self , length ) result ( string_out ) ! ident_14=\"@(#) M_strings oop_adjustc(3f) adjust string to center\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ), optional :: length if ( present ( length )) then string_out % str = lenset ( adjustc ( self % str , length ), length ) else string_out % str = adjustc ( self % str ) endif end function oop_adjustc !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_int ( self ) result ( value ) ! ident_15=\"@(#) M_strings oop_int(3f) string to integer\" class ( string ), intent ( in ) :: self integer :: value integer :: ierr call string_to_value ( self % str , value , ierr ) end function oop_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_real ( self ) result ( value ) ! ident_16=\"@(#) M_strings oop_real(3f) string to real\" class ( string ), intent ( in ) :: self real :: value integer :: ierr call string_to_value ( self % str , value , ierr ) end function oop_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_dble ( self ) result ( value ) ! ident_17=\"@(#) M_strings oop_dble(3f) string to double\" class ( string ), intent ( in ) :: self doubleprecision :: value integer :: ierr call string_to_value ( self % str , value , ierr ) end function oop_dble !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_compact ( self , char ) result ( string_out ) ! ident_18=\"@(#) M_strings oop_compact(3f) adjust string to center\" class ( string ), intent ( in ) :: self type ( string ) :: string_out character ( len =* ), optional :: char if ( present ( char )) then string_out % str = compact ( self % str , char ) else string_out % str = compact ( self % str ) endif string_out % str = trim ( string_out % str ) end function oop_compact !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_substitute ( self , old , new ) result ( string_out ) ! ident_19=\"@(#) M_strings oop_substitute(3f) change all occurrences of oldstring to newstring non-recursively\" class ( string ), intent ( in ) :: self type ( string ) :: string_out character ( len =* ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new string_out % str = self % str call substitute ( string_out % str , old , new ) end function oop_substitute !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_transliterate ( self , old , new ) result ( string_out ) ! ident_20=\"@(#) M_strings oop_transliterate(3f) change all occurrences of oldstring to newstring non-recursively\" class ( string ), intent ( in ) :: self type ( string ) :: string_out character ( len =* ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new string_out % str = transliterate ( self % str , old , new ) end function oop_transliterate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_pad ( self , length ) result ( string_out ) ! ident_21=\"@(#) M_strings oop_pad(3f) set string to at least specified length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = pad ( self % str , length ) end function oop_pad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_zpad ( self , length ) result ( string_out ) ! ident_22=\"@(#) M_strings oop_zpad(3f) set string to at least specified length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = zpad ( self % str , length ) end function oop_zpad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_cpad ( self , length ) result ( string_out ) ! ident_23=\"@(#) M_strings oop_cpad(3f) set string to at least specified length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = cpad ( self % str , length ) end function oop_cpad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_lpad ( self , length ) result ( string_out ) ! ident_24=\"@(#) M_strings oop_lpad(3f) set string to at least specified length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = lpad ( self % str , length ) end function oop_lpad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_rpad ( self , length ) result ( string_out ) ! ident_25=\"@(#) M_strings oop_rpad(3f) set string to at least specified length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = rpad ( self % str , length ) end function oop_rpad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_lenset ( self , length ) result ( string_out ) ! ident_26=\"@(#) M_strings oop_lenset(3f) set string to specific length\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer , intent ( in ) :: length string_out % str = lenset ( self % str , length ) end function oop_lenset !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_matchw ( self , pattern ) result ( answer ) ! ident_27=\"@(#) M_strings oop_matchw(3f) test if wildcard pattern matches string\" class ( string ), intent ( in ) :: self character ( len =* ), intent ( in ) :: pattern logical :: answer answer = matchw ( self % str , pattern ) end function oop_matchw !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_notabs ( self ) result ( string_out ) ! ident_28=\"@(#) M_strings oop_notabs(3f) expand tab characters assuming tab stops every eight(8) characters\" class ( string ), intent ( in ) :: self type ( string ) :: string_out integer :: length string_out % str = lenset ( '' , 8 * len ( self % str )) ! make long enough assuming all tab characters call notabs ( self % str , string_out % str , length ) string_out % str = trim ( string_out % str ) end function oop_notabs !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_noesc ( self ) result ( string_out ) ! ident_29=\"@(#) M_strings oop_noesc(3f) replace non-printable characters with spaces\" class ( string ), intent ( in ) :: self type ( string ) :: string_out string_out % str = noesc ( self % str ) end function oop_noesc !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function p ( self ) result ( string_out ) ! ident_30=\"@(#) M_strings oop_p(3f) return CHARACTER string from TYPE(STRING)\" class ( string ), intent ( in ) :: self character ( len = len ( self % str )) :: string_out string_out = self % str end function p !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine init_string ( self ) ! ! allow for TYPE(STRING) object to be initialized. ! ! ident_31=\"@(#) M_strings init_dt(3f) initialize TYPE(STRING)\" class ( string ) :: self self % str = '' end subroutine init_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! FUNCTIONS FOR DEFINING OVERLOADED OPERATORS !=================================================================================================================================== function string_plus_value ( self , value ) result ( other ) ! ident_32=\"@(#) M_strings string_plus_value(3f) add value to TYPE(STRING)\" class ( string ), intent ( in ) :: self type ( string ) :: other class ( * ), intent ( in ) :: value !  This function is primarily intended to provide behaviors for the \"+\" operator for TYPE(STRING) values !  Notice that the value can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,CHARACTER,TYPE(STRING) ) select type ( value ) type is ( integer ); other % str = v2s ( value + s2v ( self % str )) ! convert string%str to integer, add to value type is ( real ); other % str = v2s ( value + s2v ( self % str )) ! convert string%str to real, add to value type is ( doubleprecision ); other % str = v2s ( value + s2v ( self % str )) ! convert string%str to doubleprecision, add to value type is ( character ( len =* )); other % str = self % str // ' ' // value ! append space and CHARACTER to string %str type is ( string ); other % str = self % str // ' ' // value % str ! append string %str values with space between end select end function string_plus_value !=================================================================================================================================== function string_minus_value ( self , value ) result ( other ) ! ident_33=\"@(#) M_strings string_minus_value(3f) subtract value from TYPE(STRING)\" class ( string ), intent ( in ) :: self type ( string ) :: other class ( * ), intent ( in ) :: value !  This function is primarily intended to provide behaviors for the \"-\" operator for TYPE(STRING) values !  Notice that the value can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,CHARACTER,TYPE(STRING) ) select type ( value ) type is ( integer ); other % str = v2s ( value - s2v ( self % str )) type is ( real ); other % str = v2s ( value - s2v ( self % str )) type is ( doubleprecision ); other % str = v2s ( value - s2v ( self % str )) type is ( character ( len =* )) other % str = self % str call substitute ( other % str , value , '' ) type is ( string ) other % str = self % str call substitute ( other % str , value % str , '' ) end select end function string_minus_value !=================================================================================================================================== function string_append_value ( self , value ) result ( other ) ! ident_34=\"@(#) M_strings string_append_value(3f) append value to TYPE(STRING)\" class ( string ), intent ( in ) :: self type ( string ) :: other class ( * ), intent ( in ) :: value !  This function is primarily intended to provide behaviors for the \"//\" operator for TYPE(STRING) values !  Notice that the value can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,CHARACTER,TYPE(STRING) ) select type ( value ) type is ( integer ); other % str = self % str // v2s ( value ) type is ( real ); other % str = self % str // v2s ( value ) type is ( doubleprecision ); other % str = self % str // v2s ( value ) type is ( character ( len =* )); other % str = self % str // value type is ( string ); other % str = self % str // value % str end select end function string_append_value !=================================================================================================================================== function string_multiply_value ( self , value ) result ( other ) ! ident_35=\"@(#) M_strings string_multiply_value(3f) multiply TYPE(STRING) value times\" class ( string ), intent ( in ) :: self type ( string ) :: other class ( * ), intent ( in ) :: value !  This function is primarily intended to provide behaviors for the \"//\" operator for TYPE(STRING) values !  Notice that the value can be any of several types ( INTEGER,REAL,DOUBLEPRECISION ) select type ( value ) type is ( integer ); other % str = repeat ( self % str , value ) type is ( real ); other % str = repeat ( self % str , nint ( value )) type is ( doubleprecision ); other % str = repeat ( self % str , nint ( value )) end select end function string_multiply_value !=================================================================================================================================== logical function eq ( self , other ) ! ident_36=\"@(#) M_strings eq(3f) compare derived type string objects (eq lt gt le ge ne)\" class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other eq = self % str == other % str end function eq logical function lt ( self , other ) class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other lt = self % str < other % str end function lt logical function gt ( self , other ) class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other gt = self % str > other % str end function gt logical function le ( self , other ) class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other le = self % str <= other % str end function le logical function ge ( self , other ) class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other ge = self % str >= other % str end function ge logical function ne ( self , other ) class ( string ), intent ( in ) :: self type ( string ), intent ( in ) :: other ne = self % str /= other % str end function ne !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_strings_oop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_strings_oop.f90.html"}]}