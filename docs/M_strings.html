<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="github-markdown.css" />
  <style>
  <![CDATA[

  .markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
  }

  .markdown-body td,
  .markdown-body th {
  padding: 0;
  }

  .markdown-body blockquote,
  .markdown-body dl,
  .markdown-body ol,
  .markdown-body p,
  .markdown-body pre,
  .markdown-body table,
  .markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
  }

  .markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
  }

  .markdown-body table th {
  font-weight: 600;
  }

  .markdown-body table td,
  .markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
  }

  .markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
  }

  .markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
  }

  ]]>
  </style>
  <style>
  <![CDATA[
  .markdown-body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
  }

  @media (max-width: 767px) {
  .markdown-body {
   padding: 15px;
  }
  }
  ]]>
  </style>
  <style>
  <![CDATA[

  px {font-family: "Lucida Console", Monaco, monospace}
  p { font-size:100%; line-height:1.1em; }
  body {xfont-style: sans-serif}
  body {
  color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
  a:visited { color:#666; }
  h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
  h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
  h2 { font-size:143%;color:teal; }
  h3 { font-size:134%;color:blue; }
  h4 { font-size:120%;color:gray; }
  img { max-width: 55em}
  p{ padding: 0;margin:0; }
  p{ padding-right:1.4em; }
  p{ padding-bottom:1em; }
  p{ padding-top:1em; }
  p{ whitespace: pre-wrap; }
  h5,h6 { font-size:100% }
  a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
  XXtable { border:double #000; border-collapse:collapse; }
  XXtable { border-collapse:collapse; }
  XXtd { border:thin solid #888; }
  XXtd { border:none; }
  li { margin-bottom:0.5em; }
  blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
  pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
  a,li span { color:#000; }
  a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
  #Container { margin:0 10px; text-align:center; background-color: #BBB}
  #Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
  span.webName { font-size:.5em; }
  textarea#content { font-size: 1em; line-height: 1.125; }
  h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
  .property { color:#666; font-size:100%; }
  a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
  .byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
  ]]>
  </style>
  <title></title>
  <style type="text/css">
  /*<![CDATA[*/
  p.c1 {page-break-before: always}
  /*]]>*/
  </style>
<style> 
px {font-family: "Lucida Console", Monaco, monospace}
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<body>
  <article class="markdown-body">
    <?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c1"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>M_strings(3f)</b> - [M_strings:INTRO] Fortran string module
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="5" id="5">DESCRIPTION</a></h3>
        <blockquote>
          <p>The <b>M_strings</b>(3fm) module is a collection of Fortran procedures that supplement the built-in intrinsic string routines. Routines for
          parsing, tokenizing, changing case, substituting new strings for substrings, locating strings with simple wildcard expressions, removing tabs and
          line terminators and other string manipulations are included.</p>
          <p><b>M_strings_oop</b>(3fm) is a companion module that provides an OOP interface to the M_strings module.</p>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
<b>public</b> entities:
<br />   use M_strings, only : split,delim,chomp
   use M_strings, only : substitute,change,modif,transliterate,reverse,replace,join
   use M_strings, only : upper,lower,upper_quoted
   use M_strings, only : rotate13
   use M_strings, only : adjustc,compact,nospace,indent,crop,unquote,quote
   use M_strings, only : len_white,atleast,stretch,lenset,merge_str
   use M_strings, only : switch,s2c,c2s
   use M_strings, only : noesc,notabs,expand,visible
   use M_strings, only : string_to_value,string_to_values,s2v,s2vs,value_to_string,v2s,msg
   use M_strings, only : listout,getvals
   use M_strings, only : matchw
   use M_strings, only : fmt
   use M_strings, only : base, decodebase, codebase
   use M_strings, only : isalnum, isalpha, iscntrl, isdigit, isgraph, islower,
                         isprint, ispunct, isspace, isupper, isascii, isblank, isxdigit
<br />
</pre>
        </blockquote><a name=""></a>
        <h4><a name="">TOKENS</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">split</td>
              <td valign="bottom">subroutine parses string using specified delimiter characters and stores tokens into an array</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">delim</td>
              <td valign="bottom">subroutine parses string using specified delimiter characters and store tokens into an array</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">chomp</td>
              <td valign="bottom">function consumes input line as it returns next token in a string using specified delimiters</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">fmt</td>
              <td valign="bottom">convert a string into a paragraph</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">EDITING</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">substitute</td>
              <td>subroutine non-recursively globally replaces old substring with new substring</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">replace</td>
              <td>function non-recursively globally replaces old substring with new substring using allocatable string (version of <b>substitute</b>(3f)
              without limitation on length of output string)</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">change</td>
              <td valign="bottom">subroutine non-recursively globally replaces old substring with new substring with a directive like line editor</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">modif</td>
              <td valign="bottom">subroutine modifies a string with a directive like the XEDIT line editor MODIFY command</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">transliterate</td>
              <td>replace characters found in set one with characters from set two</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">reverse</td>
              <td>reverse character order in a string</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">join</td>
              <td valign="bottom">join an array of CHARACTER variables with specified separator</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">rotate13</td>
              <td>apply trivial encryption algorithm ROT13 to a string</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">CASE</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">upper</td>
              <td valign="bottom">function converts string to uppercase</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">lower</td>
              <td valign="bottom">function converts string to miniscule</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">upper</td>
              <td valign="bottom">function converts string to uppercase skipping strings quoted per Fortran rules</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">WHITE SPACE</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">adjustc</td>
              <td>elemental function centers text within the length of the input string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">compact</td>
              <td>left justify string and replace duplicate whitespace with single characters or nothing</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">nospace</td>
              <td>function replaces whitespace with nothing</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">indent</td>
              <td valign="bottom">find number of leading spaces</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">crop</td>
              <td valign="bottom">function trims leading and trailing spaces</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">QUOTES</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">unquote</td>
              <td>remove quotes from string as if read with list-directed input</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">quote</td>
              <td valign="bottom">add quotes to string as if written with list-directed input</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">STRING LENGTH</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">len_white</td>
              <td>find location of last non-whitespace character</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">lenset</td>
              <td valign="bottom">return a string of specified length</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">atleast</td>
              <td>return a string of at least specified length</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">stretch</td>
              <td>return a string of at least specified length with suffix</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">merge_str</td>
              <td>make strings of equal length and then call <b>MERGE</b>(3f) intrinsic</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">CHARACTER ARRAY VERSUS STRING</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">switch</td>
              <td valign="bottom">switch between a string and an array of single characters</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">s2c</td>
              <td valign="bottom">convert string to array of single characters and add null terminator for passing to C</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">c2s</td>
              <td valign="bottom">convert null-terminated array of single characters to string for converting strings returned from C</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">NONALPHA</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">noesc</td>
              <td valign="bottom">convert non-printable ASCII8 characters to a space</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">notabs</td>
              <td valign="bottom">convert tabs to spaces while maintaining columns, assuming tabs are set every 8 characters</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">expand</td>
              <td valign="bottom">expand escape sequences in a string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">visible</td>
              <td>expand escape sequences in a string to control and meta-control representations</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">NUMERIC STRINGS</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">string_to_value</td>
              <td>generic subroutine returns numeric value (REAL, DOUBLEPRECISION, INTEGER) from string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">string_to_values</td>
              <td>subroutine reads an array of numbers from a string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">getvals</td>
              <td>subroutine reads a relatively arbitrary number of values from a string using list-directed read</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">s2v</td>
              <td valign="bottom">function returns DOUBLEPRECISION numeric value from string</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">s2vs</td>
              <td valign="bottom">function returns a DOUBLEPRECISION array of numbers from a string</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">msg</td>
              <td valign="bottom">append the values of up to nine values into a string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">value_to_string</td>
              <td>generic subroutine returns string given numeric value (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">v2s</td>
              <td valign="bottom">generic function returns string from numeric value (REAL, DOUBLEPRECISION, INTEGER )</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">trimzeros</td>
              <td>delete trailing zeros from numeric decimal string</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">listout</td>
              <td>expand a list of numbers where negative numbers denote range ends (1 <b>-10</b> means 1 thru 10)</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isnumber</td>
              <td>determine if string represents a number</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">CHARACTER TESTS</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">matchw</td>
              <td valign="bottom">compares given string for match to pattern which may contain wildcard characters</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isalnum</td>
              <td>returns .true. if character is a letter or digit</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isalpha</td>
              <td>returns .true. if character is a letter and .false. otherwise</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">iscntrl</td>
              <td>returns .true. if character is a delete character or ordinary control character</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isdigit</td>
              <td>returns .true. if character is a digit (0,1,...,9) and .false. otherwise</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isgraph</td>
              <td>returns .true. if character is a printable character except a space is considered non-printable</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">islower</td>
              <td>returns .true. if character is a miniscule letter (a-z)</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isprint</td>
              <td>returns .true. if character is an ASCII printable character</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">ispunct</td>
              <td>returns .true. if character is a printable punctuation character</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isspace</td>
              <td>returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isupper</td>
              <td>returns .true. if character is an uppercase letter (A-Z)</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isascii</td>
              <td>returns .true. if the character is in the range <b>char</b>(0) to <b>char</b>(127)</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isblank</td>
              <td>returns .true. if character is a blank character (space or horizontal tab.</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">isxdigit</td>
              <td>returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">BASE CONVERSION</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">base</td>
              <td valign="bottom">convert whole number string in base [2-36] to string in alternate base [2-36]</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">codebase</td>
              <td>convert whole number string in base [2-36] to base 10 number decodebase convert whole number in base 10 to string in base [2-36]</td>
            </tr>
          </table>
        </blockquote><a name=""></a>
        <h4><a name="">MISCELLANEOUS</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">describe</td>
              <td>returns a string describing the name of a single character</td>
            </tr>
          </table>
        </blockquote>
        <p><a name=""></a></p>
        <h4><a name="">INTRINSICS</a></h4>
        <blockquote>
          <p>The <b>M_strings</b>(3fm) module supplements and works in combination with the Fortran built-in intrinsics. Stand-alone Fortran lets you access
          the characters in a string using ranges much like they are character arrays, assignment, comparisons with standard operators, supports dynamically
          allocatable strings and supports concatenation using the // operator, as well as a number of intrinsic string routines:</p>
          <pre>
       adjustl   Left adjust a string
       adjustr   Right adjust a string
       index     Position of a substring within a string
       repeat    Repeated string concatenation
       scan      Scan a string for the presence of a set of characters
       trim      Remove trailing blank characters of a string
       verify    Scan a string for the absence of a set of characters
       len       It returns the length of a character string
       achar     converts an integer into a character
       iachar    converts a character into an integer
       len_trim  finds length of string with trailing spaces ignored
       new_line  Newline character
       selected_char_kind  Choose character kind
       lge       Lexical greater than or equal
       lgt       Lexical greater than
       lle       Lexical less than or equal
       llt       Lexical less than
<br /><br /><br />
</pre>
        </blockquote><a name=""></a>
        <h4><a name="">OOPS INTERFACE</a></h4>
        <blockquote>
          <p>The <b>M_strings_oop</b>(3fm) module (included with the <b>M_strings</b>(3fm) module) provides an OOP (Object-Oriented Programming) interface
          to the <b>M_strings</b>(3fm) module; as described in the example program OBJECT_ORIENTED shown below...</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">SEE ALSO</a></h3>
        <blockquote>
          <p>There are additional routines in other GPF modules for working with expressions (M_calculator), time strings (M_time), random strings
          (M_random, M_uuid), lists (M_list), and interfacing with the C regular expression library (M_regex).</p>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          <p>Each of the procedural functions includes an example program in the corresponding <b>man</b>(1) page for the function. The object-oriented
          interface does not have individual <b>man</b>(1) pages, but is instead demonstrated using the following example program:</p>
          <pre>
 program demo_M_strings
 !
 ! This is an example using the object-oriented class/type model 
 ! defined in M_strings_oop
 ! This is essentially the same functionality as the procedures combined with 
 ! several Fortran intrinsics and overloaded operators
 !
 use M_strings_oop,only : string, p
 implicit none
 TYPE(string) :: str1
 TYPE(string) :: str2
 TYPE(string) :: str3
 !==============================================================================
   write(*,*)'exercise the M_STRING_OOP module interface'
   ! draw a break line in the output
   write(*,*)repeat('=',78)
   write(*,*)'Call methods of type(STRING)'
   ! define TYPE(STRING) with constructor
   str2=string('   This  is  a  String!       ')
   write(*,*)repeat('=',78)
   ! print members of type
   write(*,101)'str2%str is ................ ',str2%str
   ! same as intrinsic LEN()
   write(*,202)'len ........................ ',str2%len()
   ! same as intrinsic INDEX()
   write(*,202)'len_trim ................... ',str2%len_trim()
   ! same as intrinsic INDEX()
   write(*,202)'index("is")................. ',str2%index("is")
   ! same as intrinsic INDEX()
   write(*,202)'index("is",back=.T.) ....... ',str2%index("is",back=.TRUE.)
   ! output TYPE(STRING) with %str all uppercase
   write(*,101)'upper ...................... ',p(str2%upper())
   ! output TYPE(STRING) with %str all miniscule
   write(*,101)'lower ...................... ',p(str2%lower())
   ! output TYPE(STRING) with %str reversed
   write(*,101)'reverse .................... ',p(str2%reverse())
   ! same as intrinsic ADJUSTL()
   write(*,101)'adjustl .................... ',p(str2%adjustl())
   ! same as intrinsic ADJUSTR()
   write(*,101)'adjustr .................... ',p(str2%adjustr())
   ! center string in current string length
   write(*,101)'adjustc .................... ',p(str2%adjustc())
   ! center string in string length of NN
   write(*,101)'adjustc(49) ................ ',p(str2%adjustc(49))
   ! force %str to be NN characters long
   write(*,101)'lenset(49) ................. ',p(str2%lenset(49))
   ! same as intrinsic TRIM()
   write(*,101)'trim ....................... ',p(str2%trim())
   ! trim leading and trailing spaces
   write(*,101)'crop ....................... ',p(str2%crop())
   ! calls M_strings procedure SUBSTITUTE()
   write(*,101)'substitute("This","Here") .. ',p(str2%substitute("This","Here"))
   ! calls M_strings procedure COMPACT()
   write(*,101)'compact .................... ',p(str2%compact())
   write(*,101)'compact("") ................ ',p(str2%compact(""))
   write(*,101)'compact(":") ............... ',p(str2%compact(":"))
   ! calls M_strings procedure TRANSLITERATE()
   write(*,101)'transliterate("aei","VWX") . ',p(str2%transliterate("aei","VWX"))
   write(*,101)'transliterate("aeiou"," ") . ',p(str2%transliterate("aeiou"," "))
   write(*,101)'transliterate("aeiou","") .. ',p(str2%transliterate("aeiou",""))
   write(*,101)'transliterate(" aeiou","") . ',p(str2%transliterate(" aeiou",""))
   ! calls M_strings procedure SWITCH()
   write(*,404)'chars .................... . ',str2%chars()
<br />   write(*,*)repeat('=',78)
   str2%str='\t\tSome tabs\t   x\bX '
   write(*,101)'str2%str ................... ',str2%str
   write(*,101)'expand ..................... ',p(str2%expand())
   str2=str2%expand()
   ! calls M_strings procedure NOTABS()
   write(*,101)'notabs ..................... ',p(str2%notabs())
   ! calls M_strings procedure NOESC()
   write(*,101)'noesc ...................... ',p(str2%noesc())
<br />   write(*,*)repeat('=',78)
   write(*,*)'Casting to numeric variables'
   str3=string('   12.345678901234567e1        ')
   write(*,101)'str3%str ................... ',str3%str
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)'int  ....................... ', str3%int()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)'real ....................... ', str3%real()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)'dble ....................... ', str3%dble()
<br />   write(*,*)repeat('=',78)
   write(*,*)'Matching simple globbing patterns'
   str3=string('   12.345678901234567e1        ')
   str3=string('Four score and seven years ago')
   write(*,101)'str3%str ................... ',str3%str
   ! calls M_strings procedure MATCHW
   write(*,*)'match("Fo*") ............... ', str3%match("Fo*")
   ! calls M_strings procedure MATCHW
   write(*,*)'match("and") ............... ', str3%match("and")
   ! calls M_strings procedure MATCHW
   write(*,*)'match("*and*") ............. ', str3%match("*and*")
<br />   101 format(1x,a,"[",a,"]")
   202 format(1x,a,i0)
   303 format(1x,*(l3))
   404 format(1x,a,*("[",a1,"]":))
<br />   write(*,*)repeat('=',78)
   write(*,*)'OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))'
   str1%str='123.456'
   str2%str='AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj'
   write(*,101)'str1%str ................... ',str1%str
   write(*,101)'str2%str ................... ',str2%str
   write(*,*)'str1 + str2 ................ ',p(str1 + str2)
   ! a string that looks like a numeric value can have a value added
   write(*,*)'str1 + 20000 ............... ',p(str1 +20000)
   write(*,*)'str1 - 20.0 ................ ',p(str1 -20.0)
   write(*,*)'str2 - "Aa" (removes ALL) .. ',p(str2 - 'Aa')
<br />   write(*,*)repeat('=',78)
   write(*,*)'OVERLOADED OPERATORS (multiply,return TYPE(STRING))'
   str1%str='AaBbCcDdEeFfGgHhIiJj'
   write(*,101)'str1%str ................... ',str1%str
   write(*,*)'str1 * 3 ................... ',p(str1 * 3)
<br />   write(*,*)repeat('=',78)
   write(*,*)'OVERLOADED OPERATORS (//,return TYPE(STRING))'
   str1%str='String one:'
   str2%str='String two:'
   write(*,101)'str1%str ................... ',str1%str
   write(*,101)'str2%str ................... ',str2%str
   write(*,*)'str1 // str2 ................ ',p(str1 // str2)
   ! numeric values are converted to strings
   write(*,*)'str1 // 20000 ............... ',p(str1 // 20000)
   write(*,*)'str1 // 20.0 ................ ',p(str1 // 20.0)
<br />   write(*,*)repeat('=',78)
   write(*,*)'OVERLOADED OPERATORS (logical comparisons,return logical)'
   ! NOTE: comparisons are performed on the character variable members
   !       of the type(string)
   str1%str='abcdefghij'
   str2%str='klmnopqrst'
   write(*,101)'str1%str ................... ',str1%str
   write(*,101)'str2%str ................... ',str2%str
   write(*,*)': EQ LT GT LE GE NE'
   write(*,*)'compare str1 to str1'
   write(*,303)str1.eq.str1  ,str1.lt.str1  ,str1.gt.str1  ,str1.le.str1 &amp;
              &amp; ,str1.ge.str1  ,str1.ne.str1
   write(*,*)'compare str1 to str2'
   write(*,303)str1.eq.str2  ,str1.lt.str2  ,str1.gt.str2  ,str1.le.str2 &amp;
              &amp; ,str1.ge.str2  ,str1.ne.str2
   write(*,*)'compare str2 to str1'
   write(*,303)str2.eq.str1  ,str2.lt.str1  ,str2.gt.str1  ,str2.le.str1 &amp;
              &amp; ,str2.ge.str1  ,str2.ne.str1
<br />   write(*,*)repeat('=',78)
<br /> end program demo_M_strings
<br /> Expected output
<br />  exercise the M_STRING_OOP module interface
  =============================================================================
  Call methods of type(STRING)
  =============================================================================
  str2%str is ................ [   This  is  a  String!             ]
  len ........................ 36
  len_trim ................... 23
  index("is")................. 6
  index("is",back=.T.) ....... 10
  upper ...................... [   THIS  IS  A  STRING!             ]
  lower ...................... [   this  is  a  string!             ]
  reverse .................... [             !gnirtS  a  si  sihT   ]
  adjustl .................... [This  is  a  String!                ]
  adjustr .................... [                This  is  a  String!]
  adjustc .................... [        This  is  a  String!        ]
  adjustc(49) ................ [              This  is  a  String!               ]
  lenset(49) ................. [   This  is  a  String!                          ]
  trim ....................... [   This  is  a  String!]
  crop ....................... [This  is  a  String!]
  substitute("This","Here") .. [   Here  is  a  String!             ]
  compact .................... [This is a String!]
  compact("") ................ [ThisisaString!]
  compact(":") ............... [This:is:a:String!]
  transliterate("aei","VWX") . [   ThXs  Xs  V  StrXng!             ]
  transliterate("aeiou"," ") . [   Th s   s     Str ng!             ]
  transliterate("aeiou","") .. [   Ths  s    Strng!                 ]
  transliterate(" aeiou","") . [ThssStrng!                          ]
  chars .................... . [ ][ ][ ][T][h][i][s][ ][ ][i][s][ ][ ][a][ ][ ][S][t][r][i][n][g][!]
  [ ][ ][ ][ ][ ][ ][ ]
  =============================================================================
  str2%str ................... [\t\tSome tabs\t   x\bX ]
  expand ..................... [         Some tabs          x   X]
  notabs ..................... [                Some tabs          x    X]
  noesc ...................... [  Some tabs    x X]
  =============================================================================
  Casting to numeric variables
  str3%str ................... [   12.345678901234567e1        ]
  int  .......................          123
  real .......................    123.456787
  dble .......................    123.45678901234567
  =============================================================================
  Matching simple globbing patterns
  str3%str ................... [Four score and seven years ago]
  match("Fo*") ...............  T
  match("and") ...............  F
  match("*and*") .............  T
  ==============================================================================
  OVERLOADED OPERATORS (add and subtract, return TYPE(STRING))
  str1%str ................... [123.456]
  str2%str ................... [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj]
  str1 + str2 ................ 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj
  str1 + 20000 ............... 20123.455999999998
  str1 - 20.0 ................ -103.456
  str2 - "Aa" (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (multiply, return TYPE(STRING))
  str1%str ................... [AaBbCcDdEeFfGgHhIiJj]
  str1 * 3 ................... AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (//, return TYPE(STRING))
  str1%str ................... [String one:]
  str2%str ................... [String two:]
  str1 // str2 ................ String one:String two:
  str1 // 20000 ............... String one:20000
  str1 // 20.0 ................ String one:20.0
  =============================================================================
  OVERLOADED OPERATORS (logical comparisons, return logical)
  str1%str ................... [abcdefghij]
  str2%str ................... [klmnopqrst]
  : EQ LT GT LE GE NE
  compare str1 to str1
  :  T  F  F  T  T  F
  compare str1 to str2
  :  F  T  F  T  F  T
  compare str2 to str1
  :  F  F  T  F  T  T
  =============================================================================
</pre>
        </blockquote>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c1"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>adjustc(3f)</b> - [M_strings:WHITESPACE] center text <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
pure function <b>adjustc</b>(string[,length])
<br />
   character(len=*),intent(in)  :: string
   integer,intent(in),optional  :: length
   character(len=:),allocatable :: adjustc
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Centers input text in a string of the length specified. Returns a string of length LENGTH if LENGTH is present. Otherwise returns a string of the
          length of the input string.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">string</td>
              <td valign="bottom">input string to trim and center</td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">length</td>
              <td valign="bottom">line length to center text in, optional.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" colspan="1">adjustc</td>
              <td>centered output string</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_adjustc
   use M_strings, only : adjustc
   !  using length of the input string
      write(*,'(a)')       '================================'
      write(*,'(a)')adjustc('centered string                 ')
      write(*,'(a)')adjustc('                 centered string')
      write(*,'(a)')adjustc('  centered string               ')
   !  using explicit output string length
      write(*,'(a)')repeat('=',50)
      write(*,'(a)')adjustc('this is a centered string',50)
      write(*,'(a)')repeat('=',50)
   end program demo_adjustc
<br />
</pre>Expected output
          <pre>
   ================================
           centered string
           centered string
           centered string
   ==================================================
               this is a centered string
   ==================================================
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <h5><a href="download.html">[UP]</a></h5>
    <div id="Container">
      <div id="Content">
        <div class="c1"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>atleast(3f)</b> - [M_strings:LENGTH] return string padded to at least specified length <b>(LICENSE:PD)</b> <b>!!</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
!!
<b>function</b> <b>atleast</b>(str,length,pattern) <b>result</b>(strout)
!!
</pre>
          <blockquote>
            <table cellpadding="3">
              <tr valign="top">
                <td colspan="1"><b>character</b>(len=*)</td>
                <td>:: <i>str</i></td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>integer,intent</b>(in)</td>
                <td>:: <i>length</i></td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>character</b>(len=max(<i>length</i>,len(trim(line)))) ::</td>
                <td class="c2">strout</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>character</b>(len=*),optional</td>
                <td>:: <i>pattern</i></td>
              </tr>
            </table>
          </blockquote>
          <pre>

</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>atleast</b>(3f) pads a string with spaces to at least the specified <i>length</i>. If the trimmed input string is longer than the requested
          <i>length</i> the trimmed string is returned.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom">the input string to return trimmed, but then padded to the specified <i>length</i> if shorter than <i>length</i></td>
            </tr>
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">length</td>
              <td valign="bottom">The minimum string <i>length</i> to return</td>
            </tr>
            <tr valign="top">
              <td class="c2" colspan="1">pattern</td>
              <td>optional string to use as padding. Defaults to a space.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c2" width="6%" nowrap="nowrap">strout</td>
              <td valign="bottom">The input string padded to the requested <i>length</i> or the trimmed input string if the input string is longer than the
              requested <i>length</i>. !!</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          <pre>
       Sample Program:

          program demo_atleast
           use M_strings, only : atleast
           implicit none
           character(len=10)            :: string='abcdefghij'
           character(len=:),allocatable :: answer
           integer                      :: i
              answer=atleast(string,5)
              write(*,'("[",a,"]")') answer
              answer=atleast(string,20)
              write(*,'("[",a,"]")') answer
              i=30
              write(*,*)
              write(*,'(1x,a,i0)') atleast('CHAPTER 1 : The beginning ',i,'.'), 1
              write(*,'(1x,a,i0)') atleast('CHAPTER 2 : The end ',i,'.'),       1234
              write(*,'(1x,a,i0)') atleast('APPENDIX ',i,'.'),                  1235
              write(*,*)
              write(*,'(1x,a,i7)') atleast('CHAPTER 1 : The beginning ',i,'.'), 1
              write(*,'(1x,a,i7)') atleast('CHAPTER 2 : The end ',i,'.'),       1234
              write(*,'(1x,a,i7)') atleast('APPENDIX ',i,'.'),                  1235
          end program demo_atleast

       </pre>
        </blockquote>
        <p>Results:</p>
        <pre>
  [abcdefghij]
  [abcdefghij          ]
<br />   CHAPTER 1 : The beginning ....1
   CHAPTER 2 : The end ..........1234
   APPENDIX .....................1235
<br />   CHAPTER 1 : The beginning ....      1
   CHAPTER 2 : The end ..........   1234
   APPENDIX .....................   1235
</pre><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c5"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>base(3f)</b> - [M_strings:BASE] convert whole number string in base [2-36] to string in alternate base [2-36] <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
logical function <b>base</b>(x,b,y,a)
<br />
   character(len=*),intent(in)  :: x
   character(len=*),intent(out) :: y
   integer,intent(in)           :: b,a
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p>Convert a numeric string from base B to base A. The function returns FALSE if B is not in the range [2..36] or if string X contains invalid
          characters in base B or if result Y is too big</p>
          <p>The letters A,B,...,Z represent 10,11,...,36 in the base &gt; 10.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c6" width="6%" nowrap="nowrap">x</td>
              <td valign="bottom">input string representing numeric whole value</td>
            </tr>
            <tr valign="top">
              <td class="c6" width="6%" nowrap="nowrap">b</td>
              <td valign="bottom">assumed base of input string</td>
            </tr>
            <tr valign="top">
              <td class="c6" width="6%" nowrap="nowrap">y</td>
              <td valign="bottom">output string</td>
            </tr>
            <tr valign="top">
              <td class="c6" width="6%" nowrap="nowrap">a</td>
              <td valign="bottom">base specified for output string</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_base
   use M_strings, only : base
   implicit none
   integer           :: ba,bd
   character(len=40) :: x,y
<br />
   print *,' BASE CONVERSION'
   write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
   write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
   INFINITE: do
      write(*,'("Enter number in start base: ")',advance='no'); read *, x
      if(x.eq.'0') exit INFINITE
      if(base(x,bd,y,ba))then
           write(*,'("In base ",I2,": ",A20)')  ba, y
       else
         print *,'Error in decoding/encoding number.'
       endif
    enddo INFINITE
<br />
    end program demo_base
<br />
</pre>
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <h5><a href="download.html">[UP]</a></h5>
    <div id="Container">
      <div id="Content">
        <div class="c5"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>c2s(3f)</b> - [M_strings:ARRAY] convert C string pointer to Fortran character string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>c2s</b>(<i>c_string_pointer</i>) <b>result</b>(<i>f_string</i>)
<br />    type(c_ptr), intent(in)       :: c_string_pointer
    character(len=:), allocatable :: f_string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Given a C pointer to a character string return a Fortran character string.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c6" colspan="1">c_string_pointer</td>
              <td>C pointer to convert</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c6" colspan="1">f_string</td>
              <td>Fortran character variable to return</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c9"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>change(3f)</b> - [M_strings:EDITING] change old string to new string with a directive like a line editor <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>change</b>(target_string,cmd,ierr)
<br />
    character(len=*),intent(inout) :: target_string
    character(len=*),intent(in)    :: cmd
    integer                        :: ierr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          change an old substring into a new substring in a character variable like a line editor. Primarily used to create interactive utilities such as
          input history editors for interactive line-mode programs. The output string is assumed long enough to accommodate the change. a directive
          resembles a line editor directive of the form
          <pre>
      C/old_string/new_string/
<br />
</pre>where / may be any character which is not included in old_string or new_string.
          <p>a null old_string implies "beginning of string".</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c10" colspan="1">target_string</td>
              <td>line to be changed</td>
            </tr>
            <tr valign="top">
              <td class="c10" width="6%" nowrap="nowrap">cmd</td>
              <td valign="bottom">contains instructions to change the string</td>
            </tr>
            <tr valign="top">
              <td class="c10" width="6%" nowrap="nowrap">ierr</td>
              <td valign="bottom">
                error code.
                <table width="100%" cellpadding="3">
                  <tr valign="top">
                    <td width="3%">o</td>
                    <td>=<b>-1</b> bad directive</td>
                  </tr>
                  <tr valign="top">
                    <td width="3%">o</td>
                    <td>=0 no changes made</td>
                  </tr>
                  <tr valign="top">
                    <td width="3%">o</td>
                    <td>&gt;0 count of changes made</td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_change
<br />
    use M_strings, only : change
    implicit none
    character(len=132) :: line='This is a test string to change'
    integer            :: ierr
       write(*,*)trim(line)
<br />
       ! change miniscule a to uppercase A
       call change(line,'c/a/A/',ierr)
       write(*,*)trim(line)
<br />
       ! put string at beginning of line
       call change(line,'c//prefix: /',ierr)
       write(*,*)trim(line)
<br />
       ! remove blanks
       call change(line,'c/ //',ierr)
       write(*,*)trim(line)
   end program demo_change
</pre>
          <p>Expected output</p>
          <pre>
    This is a test string to change
    This is A test string to chAnge
    prefix: This is A test string to chAnge
    prefix:ThisisAteststringtochAnge
</pre>
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c13"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>chomp(3f)</b> - [M_strings:TOKENS] Tokenize a string, consuming it one token per call <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>chomp</b>(source_string,token[,delimiters])
<br />
    character(len=*)                     :: source_string
    character(len=:),intent(out),token   :: token
    character(len=:),intent(in),optional :: delimiters
    integer                              :: chomp
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          The <b>CHOMP</b>(3f) function is used to isolate sequential tokens in a string, SOURCE_STRING. These tokens are delimited in the string by at
          least one of the characters in DELIMITERS. This routine consumes the source_string one token per call. It returns <b>-1</b> when complete. The
          default delimiter list is "space,tab,carriage return,newline".
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c14" colspan="1">SOURCE_STRING</td>
              <td>string to tokenize</td>
            </tr>
            <tr valign="top">
              <td class="c14" colspan="1">DELIMITERS</td>
              <td>list of separator characters</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c14" width="6%" nowrap="nowrap">TOKEN</td>
              <td valign="bottom">returned token</td>
            </tr>
            <tr valign="top">
              <td class="c14" width="6%" nowrap="nowrap">CHOMP</td>
              <td valign="bottom">status flag. 0 = success, <b>-1</b> = no tokens remain</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_chomp
<br />
   use M_strings, only : chomp
   implicit none
   character(len=100)            :: inline
   character(len=:),allocatable  :: token
   character(len=*),parameter    :: delimiters=' ;,'
   integer                       :: ios
   integer                       :: icount
   integer                       :: itoken
      icount=0
      do        ! read lines from stdin until end-of-file or error
         read (unit=*,fmt="(a)",iostat=ios) inline
         if(ios.ne.0)stop
         icount=icount+1
         itoken=0
         write(*,*)'INLINE ',trim(inline)
         do while ( chomp(inline,token,delimiters).ge. 0)
            itoken=itoken+1
            print *, itoken,'TOKEN=['//trim(token)//']'
         enddo
      enddo
<br />
   end program demo_chomp
</pre>
          <p>sample input file</p>
          <pre>
      
    this is a test of chomp; A:B :;,C;;
</pre>
          <p>sample output file</p>
          <pre>
    INLINE     this is a test of chomp; A:B :;,C;;
              1 TOKEN=[this]
              2 TOKEN=[is]
              3 TOKEN=[a]
              4 TOKEN=[test]
              5 TOKEN=[of]
              6 TOKEN=[chomp]
              7 TOKEN=[A:B]
              8 TOKEN=[:]
              9 TOKEN=[C]
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c17"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>codebase(3f)</b> - [M_strings:BASE] convert whole number in base 10 to string in base [2-36] <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
logical function <b>codebase</b>(in_base10,out_base,answer)
<br />
   integer,intent(in)           :: in_base10
   integer,intent(in)           :: out_base
   character(len=*),intent(out) :: answer
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p>Convert a number from base 10 to base OUT_BASE. The function returns too big.</p>
          <p>The letters A,B,...,Z represent 10,11,...,36 in the base &gt; 10.</p>
        </blockquote>
        <p><a name="3" id="3"></a></p>
        <h3><a name="3" id="3">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_codebase
   use M_strings, only : codebase
   implicit none
   character(len=20) :: answer
   integer           :: i, j
   logical           :: ierr
   do j=1,100
      do i=2,36
         ierr=codebase(j,i,answer)
         write(*,*)'VALUE=',j,' BASE=',i,' ANSWER=',answer
      enddo
   enddo
   end program demo_codebase
<br />
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c20"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>compact(3f)</b> - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing) <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>compact</b>(STR,CHAR) result (<i>OUTSTR</i>)
<br />
    character(len=*),intent(in)          :: STR
    character(len=*),intent(in),optional :: CHAR
    character(len=len(str))              :: OUTSTR
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>COMPACT</b>(3f) converts multiple spaces, tabs and control characters (called "whitespace") to a single character or nothing. Leading
          whitespace is removed.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c21" width="6%" nowrap="nowrap">STR</td>
              <td valign="bottom">input string to reduce or remove whitespace from</td>
            </tr>
            <tr valign="top">
              <td class="c21" width="6%" nowrap="nowrap">CHAR</td>
              <td valign="bottom">By default the character that replaces adjacent whitespace is a space. If the optional CHAR parameter is supplied it will
              be used to replace the whitespace. If a null character is supplied for CHAR whitespace is removed.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c22" width="6%" nowrap="nowrap">OUTSTR</td>
              <td valign="bottom">string of same length as input string but with all contiguous whitespace reduced to a single space and leading whitespace
              removed</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_compact
    use M_strings, only : compact
    implicit none
    ! produces 'This is a test               '
    write(*,*)compact('  This     is      a     test  ')
    ! produces 'Thisisatest                  '
    write(*,*)compact('  This     is      a     test  ',char='')
    ! produces 'This:is:a:test               '
    write(*,*)compact('  This     is      a     test  ',char=':')
    ! note CHAR is used to replace the whitespace, but if CHAR is
    ! in the original string it is just copied
    write(*,*)compact('A  AA    A   AAAAA',char='A')
    ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
    ! not 'A'
   end program demo_compact
<br />
   Expected output
<br />
    &gt;This is a test
    &gt;Thisisatest
    &gt;This:is:a:test
    &gt;AAAAAAAAAAAA
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c24"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>crop(3f)</b> - [M_strings:WHITESPACE] trim leading blanks and trailing blanks from a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>crop</b>(<i>strin</i>) result (<i>strout</i>)
<br />
    character(len=*),intent(in)  :: strin
    character(len=:),allocatable :: strout
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          trim leading blanks from a string and return position of last non-blank character in the string.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c25" width="6%" nowrap="nowrap">strin</td>
              <td valign="bottom">input string to trim leading and trailing space from</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c25" width="6%" nowrap="nowrap">strout</td>
              <td valign="bottom">cropped version of input string</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_crop
   use M_strings, only: crop
   implicit none
   character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
      write(*,*) 'untrimmed string=[',untrimmed,']'
      write(*,*) 'cropped string=[',crop(untrimmed),']'
   end program demo_crop
<br />
</pre>Expected output
          <pre>
     untrimmed string=[   ABCDEFG abcdefg                      ]
     cropped string=[ABCDEFG abcdefg]
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c27"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>decodebase(3f)</b> - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
logical function <b>decodebase</b>(string,basein,out10)
<br />
   character(len=*),intent(in)  :: string
   integer,intent(in)           :: basein
   integer,intent(out)          :: out10
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p>Convert a numeric string representing a whole number in base BASEIN to base 10. The function returns FALSE if BASEIN is not in the range
          [2..36] or if string STRING contains invalid characters in base BASEIN or if result OUT10 is too big</p>
          <p>The letters A,B,...,Z represent 10,11,...,36 in the base &gt; 10.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c28" width="6%" nowrap="nowrap">string</td>
              <td valign="bottom">input string. It represents a whole number in the base specified by BASEIN unless BASEIN is set to zero. When BASEIN is
              zero STRING is assumed to be of the form BASE#VALUE where BASE represents the function normally provided by BASEIN.</td>
            </tr>
            <tr valign="top">
              <td class="c28" width="6%" nowrap="nowrap">basein</td>
              <td valign="bottom">base of input string; either 0 or from 2 to 36.</td>
            </tr>
            <tr valign="top">
              <td class="c28" width="6%" nowrap="nowrap">out10</td>
              <td valign="bottom">output value in base 10</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_decodebase
   use M_strings, only : codebase, decodebase
   implicit none
   integer           :: ba,bd
   character(len=40) :: x,y
   integer           :: r
<br />
   print *,' BASE CONVERSION'
   write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
   write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
   INFINITE: do
      print *,''
      write(*,'("Enter number in start base: ")',advance='no'); read *, x
      if(x.eq.'0') exit INFINITE
      if(decodebase(x,bd,r)) then
         if(codebase(r,ba,y)) then
           write(*,'("In base ",I2,": ",A20)')  ba, y
         else
           print *,'Error in coding number.'
         endif
      else
         print *,'Error in decoding number.'
      endif
   enddo INFINITE
<br />
   end program demo_decodebase
<br />
</pre>
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c31"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>delim(3f)</b> - [M_strings:TOKENS] parse a string and store tokens into an array <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>delim</b>(line,array,n,icount,ibegin,iterm,ilen,dlim)
<br />
    character(len=*),intent(in)  :: line
    integer,integer(in)          :: n
    integer,intent(out)          :: icount
    character(len=*)             :: array(n)
    integer,intent(out)          :: ibegin(n)
    integer,intent(out)          :: iterm(n)
    integer,intent(out)          :: ilen
    character(len=*)             :: dlim
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p>Given a LINE of structure " par1 par2 par3 ... parn " store each <b>par</b>(n) into a separate variable in ARRAY (UNLESS
          <b>ARRAY</b>(1).eq.'#N#')</p>
          <p>Also set ICOUNT to number of elements of array initialized, and return beginning and ending positions for each element in <b>IBEGIN</b>(N) and
          <b>ITERM</b>(N).</p>
          <p>Return position of last non-blank character (even if more than N elements were found) in ILEN</p>
          <p>No quoting or escaping of delimiter is allowed, so the delimiter character can not be placed in a token.</p>
          <p>No checking for more than N parameters; If any more they are ignored.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c32" width="6%" nowrap="nowrap">LINE</td>
              <td valign="bottom">input string to parse into tokens</td>
            </tr>
            <tr valign="top">
              <td colspan="1"><b>ARRAY</b>(N)</td>
              <td>array that receives tokens</td>
            </tr>
            <tr valign="top">
              <td class="c32" width="6%" nowrap="nowrap">N</td>
              <td valign="bottom">size of arrays ARRAY, IBEGIN, ITERM</td>
            </tr>
            <tr valign="top">
              <td class="c32" width="6%" nowrap="nowrap">ICOUNT</td>
              <td valign="bottom">number of tokens found <b>IBEGIN</b>(N) starting columns of tokens found</td>
            </tr>
            <tr valign="top">
              <td colspan="1"><b>ITERM</b>(N)</td>
              <td>ending columns of tokens found</td>
            </tr>
            <tr valign="top">
              <td class="c32" width="6%" nowrap="nowrap">ILEN</td>
              <td valign="bottom">position of last non-blank character in input string LINE</td>
            </tr>
            <tr valign="top">
              <td class="c32" width="6%" nowrap="nowrap">DLIM</td>
              <td valign="bottom">delimiter characters</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
    program demo_delim
<br />
    use M_strings, only: delim
    character(len=80) :: line
    character(len=80) :: dlm
    integer,parameter :: n=10
    character(len=20) :: array(n)=' '
    integer           :: ibegin(n),iterm(n)
    line=' first  second 10.3 words_of_stuff  '
    do i20=1,4
       ! change delimiter list and what is calculated or parsed
       if(i20.eq.1)dlm=' '
       if(i20.eq.2)dlm='o'
       if(i20.eq.3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
       if(i20.eq.3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
       if(i20.eq.4)line='AAAaBBBBBBbIIIIIi  J K L'
<br />
       ! write out a break line composed of =========== ..
       write(*,'(57("="))')
       ! show line being parsed
       write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
       ! call parsing procedure
       call delim(line,array,n,icount,ibegin,iterm,ilen,dlm)
       write(*,*)'number of tokens found=',icount
       write(*,*)'last character in column ',ilen
       if(icount.gt.0)then
          if(ilen.ne.iterm(icount))then
             write(*,*)'ignored from column ',iterm(icount)+1,' to ',ilen
          endif
          do i10=1,icount
             ! check flag to see if ARRAY() was set
             if(array(1).ne.'#N#')then
                ! from returned array
                write(*,'(a,a,a)',advance='no')&amp;
                &amp;'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
             endif
          enddo
          ! using start and end positions in IBEGIN() and ITERM()
          write(*,*)
          do i10=1,icount
             ! from positions in original line
             write(*,'(a,a,a)',advance='no')&amp;
             &amp;'[',line(ibegin(i10):iterm(i10)),']'
          enddo
          write(*,*)
       endif
    enddo
    end program demo_delim
<br />
</pre>Expected output
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c35"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>describe(3f)</b> - [M_strings] returns a string describing the name of a single character <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>describe</b>(<i>ch</i>) result (<i>string</i>)
<br />
    character(len=1),intent(in)   :: ch
    character(len=:),allocatable  :: string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>describe</b>(3f) returns a <i>string</i> describing long name of a single character
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_describe
    use M_strings, only : describe
    implicit none
    integer :: i
       do i=1,128  ! fill variable with base ASCII character set
          write(*,*)describe(char(i-1))
       enddo
   end program demo_describe
<br />
</pre>Expected output
          <pre>
    ctrl-@ or ctrl-? (NUL) null
    ctrl-A (SOH) start of heading
    ctrl-B (STX) start of text
    ctrl-C (ETX) end of text
    ctrl-D (EOT) end of transmission
    ctrl-E (ENQ) enquiry
    ctrl-F (ACK) acknowledge
    ctrl-G (BEL) bell
    ctrl-H (BS) backspace
    ctrl-I (HT) horizontal tabulation
    ctrl-J (LF) line feed
    ctrl-K (VT) vertical tabulation
    ctrl-L (FF) form feed
    ctrl-M (CR) carriage return
    ctrl-N (SO) shift out
    ctrl-O (SI) shift in
    ctrl-P (DLE) data link escape
    ctrl-Q (DC1) device control 1
    ctrl-R (DC2) device control 2
    ctrl-S (DC3) device control 3
    ctrl-T (DC4) device control 4
    ctrl-U (NAK) negative acknowledge
    ctrl-V (SYN) synchronous idle
    ctrl-W (ETB) end of transmission block
    ctrl-X (CAN) cancel
    ctrl-Y (EM) end of medium
    ctrl-Z (SUB) substitute
    ctrl-[ (ESC) escape
    ctrl-\ or ctrl-@ (FS) file separator
    ctrl-] (GS) group separator
    ctrl-^ or ctrl-= (RS) record separator
    ctrl-_ (US) unit separator
    space
    ! exclamation point
    " quotation marks
    # number sign
    $ currency symbol
    % percent
    &amp; ampersand
    ' apostrophe
    ( left parenthesis
    ) right parenthesis
    * asterisk
    + plus
    , comma
    - minus
    . period
    / slash
    0 zero
    1 one
    2 two
    3 three
    4 four
    5 five
    6 six
    7 seven
    8 eight
    9 nine
    : colon
    ; semicolon
    &lt; less than
    = equals
    &gt; greater than
    ? question mark
    @ at sign
    majuscule A
    majuscule B
    majuscule C
    majuscule D
    majuscule E
    majuscule F
    majuscule G
    majuscule H
    majuscule I
    majuscule J
    majuscule K
    majuscule L
    majuscule M
    majuscule N
    majuscule O
    majuscule P
    majuscule Q
    majuscule R
    majuscule S
    majuscule T
    majuscule U
    majuscule V
    majuscule W
    majuscule X
    majuscule Y
    majuscule Z
    [ left bracket
    \ backslash
    ] right bracket
    ^ caret
    _ underscore
    ' grave accent
    miniscule a
    miniscule b
    miniscule c
    miniscule d
    miniscule e
    miniscule f
    miniscule g
    miniscule h
    miniscule i
    miniscule j
    miniscule k
    miniscule l
    miniscule m
    miniscule n
    miniscule o
    miniscule p
    miniscule q
    miniscule r
    miniscule s
    miniscule t
    miniscule u
    miniscule v
    miniscule w
    miniscule x
    miniscule y
    miniscule z
    { left brace
    | vertical line
    } right brace
    ~ tilde
    ctrl-? (DEL) delete
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c38"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>expand(3f)</b> - [M_strings:NONALPHA] expand C-like escape sequences <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>expand</b>(line,escape) <b>result</b>(<i>lineout</i>)
<br />
   character(len=*)                      :: line
   character(len=1),intent(in),optional  :: escape
   character(len=:),allocatable          :: lineout
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>EXPAND</b>() expands sequences used to represent commonly used escape sequences or control characters. By default ...</p>
          <p>Escape sequences</p>
          <blockquote>
            <table cellpadding="3">
              <!-- tsb: Escape sequences
 -->
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\\</td>
                <td valign="bottom">backslash</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\a</td>
                <td valign="bottom">alert (BEL) -- g is an alias for a</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\b</td>
                <td valign="bottom">backspace</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\c</td>
                <td valign="bottom">suppress further output</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\e</td>
                <td valign="bottom">escape</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\f</td>
                <td valign="bottom">form feed</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\n</td>
                <td valign="bottom">new line</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\r</td>
                <td valign="bottom">carriage return</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\t</td>
                <td valign="bottom">horizontal tab</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\v</td>
                <td valign="bottom">vertical tab</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\oNNN</td>
                <td valign="bottom">byte with octal value NNN (3 digits)</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\dNNN</td>
                <td valign="bottom">byte with decimal value NNN (3 digits)</td>
              </tr>
              <tr valign="top">
                <td class="c39" width="6%" nowrap="nowrap">\xHH</td>
                <td valign="bottom">byte with hexadecimal value HH (2 digits) -- h is an alias for x</td>
              </tr>
            </table>
          </blockquote>
          <p>The default escape character is the backslash, but this may be changed using the optional parameter ESCAPE.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_expand
    !  test filter to expand escape sequences in input lines
    use M_strings, only : expand
    character(len=1024) :: line
    integer             :: ios
       READFILE: block
          do
             read(*,'(A)',iostat=ios)line
             if(ios /= 0) exit READFILE
             write(*,'(a)')trim(expand(line))
          enddo
       endblock READFILE
    end program demo_expand
<br />
</pre>Sample input:
          <pre>
     \e[2J
     \tABC\tabc
     \tA\a
     \nONE\nTWO\nTHREE
<br />
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c42"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>fmt(3f)</b> - [M_strings:TOKENS] Tokenize a string, consuming it one token per call <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>fmt</b>(source_string,length)
<br />
   character(len=*),intent(in)       :: source_string
   integer,intent(in)                :: length
   character(allocatable(len=length)    :: fmt(:)
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>fmt</b>(3f) breaks a long line into a simple paragraph of specified line length.
          <p>Given a long string break it on spaces into an array such that no variable is longer than the specified length. Individual words longer than
          LENGTH will be placed in variables by themselves.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c43" colspan="1">SOURCE_STRING</td>
              <td>input string to break into an array of shorter strings on blank delimiters</td>
            </tr>
            <tr valign="top">
              <td class="c43" width="6%" nowrap="nowrap">LENGTH</td>
              <td valign="bottom">length of lines to break the string into.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c43" width="6%" nowrap="nowrap">FMT</td>
              <td valign="bottom">character array filled with data from source_string broken at spaces into variables of length LENGTH.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          sample program
          <pre>
   program demo_fmt
   use M_strings, only : fmt
   character(len=80),allocatable :: paragraph(:)
   character(len=*),parameter    :: string= '&amp;
    &amp;one two three four five &amp;
    &amp;six seven eight &amp;
    &amp;nine ten eleven twelve &amp;
    &amp;thirteen fourteen fifteen sixteen &amp;
    &amp;seventeen'
<br />
   paragraph=fmt(string,40)
   write(*,'(a)')paragraph
<br />
   write(*,'(a)')fmt(string,0)
   write(*,'(3x,a)')fmt(string,77)
<br />
   end program demo_fmt
<br />
</pre>
          <blockquote>
            Results:
            <pre>
   one two three four five six seven eight
   nine ten eleven twelve thirteen fourteen
   fifteen sixteen seventeen
   one
   two
   three
   four
   five
   six
   seven
   eight
   nine
   ten
   eleven
   twelve
   thirteen
   fourteen
   fifteen
   sixteen
   seventeen
      one two three four five six seven eight nine ten eleven twelve thirteen
      fourteen fifteen sixteen seventeen
</pre>
          </blockquote>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c46"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>getvals(3f)</b> - [M_strings:NUMERIC] read arbitrary number of REAL values from a character variable up to size of <b>VALUES</b>() array
          <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>getvals</b>(line,values,icount,ierr)
<br />
    character(len=*),intent(in)  :: line
    class(*),intent(out)         :: values(:)
    integer,intent(out)          :: icount
    integer,intent(out),optional :: ierr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>GETVALS</b>(3f) reads a relatively arbitrary number of numeric values from a character variable into a REAL array using list-directed
          input.</p>
          <p>NOTE: In this version null values are skipped instead of meaning to leave that value unchanged</p>
          <blockquote>
            <p>1,,,,,,,2 / reads VALUES=[1.0,2.0]</p>
          </blockquote>
          <p>Per list-directed rules when reading values, allowed delimiters are comma, semi-colon and space.</p>
          <p>the slash separator can be used to add inline comments.</p>
          <pre>
       10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
<br />
</pre>Repeat syntax can be used up to the size of the output array. These are equivalent input lines:
          <pre>
       4*10.0
       10.0, 10.0, 10.0, 10.0
<br />
</pre>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c47" width="6%" nowrap="nowrap">LINE</td>
              <td valign="bottom">A character variable containing the characters representing a list of numbers</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td colspan="1"><b>VALUES</b>()</td>
              <td>array holding numbers read from string. May be of type INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the strings are returned
              as simple words instead of numeric values.</td>
            </tr>
            <tr valign="top">
              <td class="c47" width="6%" nowrap="nowrap">ICOUNT</td>
              <td valign="bottom">number of defined numbers in <b>VALUES</b>(). If ICOUNT reaches the size of the <b>VALUES</b>() array parsing stops.</td>
            </tr>
            <tr valign="top">
              <td class="c47" width="6%" nowrap="nowrap">IERR</td>
              <td valign="bottom">zero if no error occurred in reading numbers. Optional. If not present and an error occurs the program is terminated.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
      program demo_getvals
      use M_strings, only: getvals
      implicit none
      integer,parameter  :: longest_line=256
      character(len=longest_line) :: line
      real               :: values(longest_line/2+1)
      integer            :: ios,icount,ierr
      INFINITE: do
         read(*,'(a)',iostat=ios) line
         if(ios.ne.0)exit INFINITE
         call getvals(line,values,icount,ierr)
         write(*,*)'VALUES=',values(:icount)
      enddo INFINITE
      end program demo_getvals
<br />
</pre>Sample input lines
          <pre>
       10,20 30.4
       1 2 3
       1
<br />
       3 4*2.5 8
       32.3333 / comment 1
       30e3;300,    30.0, 3
       even 1 like this! 10
       11,,,,22,,,,33
<br />
</pre>Expected output:
          <pre>
      VALUES=   10.0000000       20.0000000       30.3999996
      VALUES=   1.00000000       2.00000000       3.00000000
      VALUES=   1.00000000
      VALUES=
      VALUES=   3.00000000       2.50000000       2.50000000       2.50000000       2.50000000       8.00000000
      VALUES=   32.3333015
      VALUES=   30000.0000       300.000000       30.0000000       3.00000000
      *getvals* WARNING:[even] is not a number
      *getvals* WARNING:[like] is not a number
      *getvals* WARNING:[this!] is not a number
      VALUES=   1.00000000       10.0000000
      VALUES=   11.0000000       22.0000000       33.0000000
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c50"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>indent(3f)</b> - [M_strings:WHITESPACE] count number of leading spaces in a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>indent</b>(<i>line</i>)
<br />
    integer                        :: indent
    character(len=*),intent(in)    :: line
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Count number of leading spaces in a CHARACTER variable.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_indent
    !  test filter to count leading spaces in a character variable
    !  might want to call notabs(3f) to expand tab characters
    use M_strings, only : indent
    implicit none
    character(len=1024) :: in
    integer             :: ios
       READFILE: do
          read(*,'(A)',iostat=ios)in
          if(ios /= 0) exit READFILE
          write(*,'(i3,"",a)')indent(in),trim(in)
       enddo READFILE
    end program demo_indent
<br />
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c53"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>isalnum,isalpha,iscntrl,isdigit,isgraph,islower,</b> <b>isprint,ispunct,isspace,isupper,isascii,isblank,isxdigit(3f)</b> - [M_strings:COMPARE]
          test membership in subsets of ASCII set <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
Where "FUNCNAME" is one of the function names in the <i>group</i>, the functions are defined by
<br />
    elemental function FUNCNAME(onechar)
    character,intent(in) :: onechar
    logical              :: FUNC_NAME
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p>These elemental functions test if a character belongs to various subsets of the ASCII character set.</p>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c54" colspan="1">isalnum</td>
              <td>returns .true. if character is a letter (a-z,A-Z) or digit (0-9)</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isalpha</td>
              <td>returns .true. if character is a letter and .false. otherwise</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isascii</td>
              <td>returns .true. if character is in the range <b>char</b>(0) to <b>char</b>(127)</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isblank</td>
              <td>returns .true. if character is a blank (space or horizontal tab).</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">iscntrl</td>
              <td>returns .true. if character is a delete character or ordinary control character (0x7F or 0x00-0x1F).</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isdigit</td>
              <td>returns .true. if character is a digit (0,1,...,9) and .false. otherwise</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isgraph</td>
              <td>returns .true. if character is a printable ASCII character excluding space</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">islower</td>
              <td>returns .true. if character is a miniscule letter (a-z)</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isprint</td>
              <td>returns .true. if character is a printable ASCII character</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">ispunct</td>
              <td>returns .true. if character is a printable punctuation character (isgraph(c) &amp;&amp; !isalnum(c)).</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isspace</td>
              <td>returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isupper</td>
              <td>returns .true. if character is an uppercase letter (A-Z)</td>
            </tr>
            <tr valign="top">
              <td class="c54" colspan="1">isxdigit</td>
              <td>returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).</td>
            </tr>
          </table>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_isdigit
<br />
   use M_strings, only : isdigit, isspace, switch
   implicit none
   character(len=10),allocatable :: string(:)
   integer                       :: i
      string=[&amp;
      &amp; '1 2 3 4 5 ' ,&amp;
      &amp; 'letters   ' ,&amp;
      &amp; '1234567890' ,&amp;
      &amp; 'both 8787 ' ]
      ! if string is nothing but digits and whitespace return .true.
      do i=1,size(string)
         write(*,'(a)',advance='no')'For string['//string(i)//']'
         write(*,*) &amp;
         all(isdigit(switch(string(i))).or.isspace(switch(string(i))))
      enddo
<br />
    end program demo_isdigit
<br />
</pre>Expected output:
          <pre>
   For string[1 2 3 4 5 ] T
   For string[letters   ] F
   For string[1234567890] T
   For string[both 8787 ] F
<br />
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c64"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>isnumber(3f)</b> - [M_strings:NUMERIC] determine if a string represents a number <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>isnumber</b>(str,msg)
<br />
    character(len=*),intent(in)  :: str
    character(len=:),intent(out),allocatable,optional  :: msg
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>ISNUMBER</b>(3f) returns a value greater than zero if the string represents a number, and a number less than or equal to zero if it is a bad
          number. Blank characters are ignored.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c65" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom">the string to evaluate as to whether it represents a numeric value or not</td>
            </tr>
            <tr valign="top">
              <td class="c65" width="6%" nowrap="nowrap">msg</td>
              <td valign="bottom">An optional message describing the string</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c65" colspan="1">isnumber</td>
              <td>
                the following values are returned
                <table width="100%" cellpadding="3">
                  <tr valign="top">
                    <td class="c65" colspan="1">1 for an integer</td>
                    <td>[-+]NNNNN</td>
                  </tr>
                  <tr valign="top">
                    <td class="c65" colspan="1">2 for a whole number</td>
                    <td>[-+]NNNNN.</td>
                  </tr>
                  <tr valign="top">
                    <td class="c65" colspan="1">3 for a real value</td>
                    <td>[-+]NNNNN.MMMM</td>
                  </tr>
                  <tr valign="top">
                    <td class="c65" colspan="1">4 for a exponential value</td>
                    <td>[-+]NNNNN.MMMM[-+]LLLL [-+]NNNNN.MMMM[ed][-+]LLLL</td>
                  </tr>
                </table><!-- .PP -->
              </td>
            </tr>
          </table>values less than 1 represent an error
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          As the example shows, you can use an internal <b>READ</b>(3f) along with the IOSTAT= parameter to check (and read) a string as well.
          <pre>
    program demo_isnumber
    use M_strings, only : isnumber
    implicit none
    character(len=256) :: line
    real               :: value
    integer            :: ios
    integer            :: answer
    character(len=256) :: message
    character(len=:),allocatable :: description
       write(*,*)'Begin entering values, one per line'
       do
          read(*,'(a)',iostat=ios)line
          !
          ! try string as number using list-directed input
          line=''
          read(line,*,iostat=ios,iomsg=message) value
          if(ios.eq.0)then
             write(*,*)'VALUE=',value
          else
             write(*,*)'ERROR:',ios,trim(message)
          endif
          !
          ! try string using isnumber(3f)
          answer=isnumber(line,msg=description)
          if(answer.gt.0)then
             write(*,*)' for ',trim(line),' ',answer,':',description
          else
             write(*,*)' ERROR for ',trim(line),' ',answer,':',description
          endif
          !
       enddo
    end program demo_isnumber
<br />
</pre>
        </blockquote>Example run
        <pre>
    Begin entering values
    ERROR:          -1 End of file
     ERROR for            -1 :null string
   10
    VALUE=   10.0000000
     for 10            1 :integer
   20
    VALUE=   20.0000000
     for 20            1 :integer
   20.
    VALUE=   20.0000000
     for 20.            2 :whole number
   30.1
    VALUE=   30.1000004
     for 30.1            3 :real number
   3e1
    VALUE=   30.0000000
     for 3e1            4 :value with exponent
   1-2
    VALUE=   9.99999978E-03
     for 1-2            4 :value with exponent
   100.22d-4
    VALUE=   1.00220004E-02
     for 100.22d-4            4 :value with exponent
   1--2
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for 1--2           -5 :bad number
   e
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for e           -6 :missing leading value before exponent
   e1
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for e1           -6 :missing leading value before exponent
   1e
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for 1e           -3 :missing exponent
   1e+
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for 1e+           -4 :missing exponent after sign
   1e+2.0
    ERROR:        5010 Bad real number in item 1 of list input
     ERROR for 1e+2.0           -5 :bad number
</pre>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c73"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>join(3f)</b> - [M_strings:EDITING] append CHARACTER variable array into a single CHARACTER variable with specified separator
          <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
pure function <b>join</b>(str,sep,trm,left,right) result (<i>string</i>)
<br />
    character(len=*),intent(in)          :: str(:)
    character(len=*),intent(in),optional :: sep
    logical,intent(in),optional          :: trm
    character(len=*),intent(in),optional :: right
    character(len=*),intent(in),optional :: left
    character(len=:),allocatable         :: string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>JOIN</b>(3f) appends the elements of a CHARACTER array into a single CHARACTER variable, with elements 1 to N joined from left to right. By
          default each element is trimmed of trailing spaces and the default separator is a null <i>string</i>.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td width="6%" nowrap="nowrap"><b>STR</b>(:)</td>
              <td valign="bottom">array of CHARACTER variables to be joined</td>
            </tr>
            <tr valign="top">
              <td class="c74" width="6%" nowrap="nowrap">SEP</td>
              <td valign="bottom">separator <i>string</i> to place between each variable. defaults to a null <i>string</i>.</td>
            </tr>
            <tr valign="top">
              <td class="c74" width="6%" nowrap="nowrap">LEFT</td>
              <td valign="bottom"><i>string</i> to place at left of each element</td>
            </tr>
            <tr valign="top">
              <td class="c74" width="6%" nowrap="nowrap">RIGHT</td>
              <td valign="bottom"><i>string</i> to place at right of each element</td>
            </tr>
            <tr valign="top">
              <td class="c74" width="6%" nowrap="nowrap">TRM</td>
              <td valign="bottom">option to trim each element of STR of trailing spaces. Defaults to .TRUE.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULT</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c74" width="6%" nowrap="nowrap">STRING</td>
              <td valign="bottom">CHARACTER variable composed of all of the elements of <b>STR</b>() appended together with the optional separator SEP
              placed between the elements.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
      program demo_join
      use M_strings, only: join
      implicit none
      character(len=:),allocatable  :: s(:)
      character(len=:),allocatable  :: out
      integer                       :: i
         s=[character(len=10) :: 'United',' we',' stand,',' divided',' we fall.']
         out=join(s)
         write(*,'(a)') out
         write(*,'(a)') join(s,trm=.false.)
         write(*,'(a)') (join(s,trm=.false.,sep='|'),i=1,3)
         write(*,'(a)') join(s,sep='&lt;&gt;')
         write(*,'(a)') join(s,sep=';',left='[',right=']')
         write(*,'(a)') join(s,left='[',right=']')
         write(*,'(a)') join(s,left='&gt;&gt;')
      end program demo_join
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c77"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>len_white(3f)</b> - [M_strings:LENGTH] get length of string trimmed of whitespace. <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="9" id="9">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
integer function <b>len_white</b>(<i>string</i>)
<br />
    character(len=*) :: string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>len_white</b>(3f) returns the position of the last character in <i>string</i> that is not a whitespace character. The Fortran90 intrinsic
          <b>LEN_TRIM</b>() should be used when trailing whitespace can be assumed to always be spaces.
          <p>This procedure was heavily used in the past because ANSI FORTRAN 77 character objects are fixed length and blank padded and the
          <b>LEN_TRIM</b>() intrinsic did not exist. It should now be used only when whitespace characters other than blanks are likely.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c78" width="6%" nowrap="nowrap">string</td>
              <td valign="bottom">input <i>string</i> whose trimmed length is being calculated ignoring all trailing whitespace characters.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c79" colspan="1">len_white</td>
              <td>the number of characters in the trimmed <i>string</i></td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_len_white
<br />
    use M_strings, only : len_white
    character(len=80) ::  s
    intrinsic len
<br />
    s=' ABCDEFG abcdefg '
    ilen = len(s)
    lastnb = len_white(s)
<br />
    write(*,*) 'total length of variable is ',ilen
    write(*,*) 'trimmed length of variable is ',lastnb
    write(*,*) 'trimmed string=[',s(:lastnb),']'
<br />
   end program demo_len_white
</pre>
        </blockquote><a name="6" id="6"></a>
        <h3><a name="6" id="6">NOTES</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td width="3%">o</td>
              <td>len_white</td>
            </tr>
          </table><!-- .nf -->
          <pre>
     is a resource-intensive routine. Once the end of
     the string is found, it is probably best to keep track of it in
     order to avoid repeated calls to len_white. Because they
     might be more efficient, consider looking for vendor-supplied or
     system-optimized equivalents. For example:
<br />
        o lnblnk - Solaris f77
        o len_trim - FORTRAN 90
<br />
</pre>
          <table cellpadding="3">
            <tr valign="top">
              <td width="3%">o</td>
              <td>
                <p>Some compilers seem to have trouble passing a <i>string</i> of variable length properly. To be safe, use something like this:</p>
              </td>
            </tr>
          </table><!-- .nf -->
          <pre>
      subroutine message(s)
       character(len=*) :: s ! s is of variable length
          ilen=len(s)        ! get total length of variable
          ! explicitly specify a substring instead of just variable name
          lastnb = len_white(s(:ilen))
          write(*,*)'error:[',s(:lastnb),']'
      end subroutine messages
<br />
</pre>
        </blockquote><a name="7" id="7"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c81"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>lenset(3f)</b> - [M_strings:LENGTH] return string trimmed or padded to specified length <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>lenset</b>(str,length) <b>result</b>(<i>strout</i>)
<br />
    character(len=*)                     :: str
    character(len=length)                :: strout
    integer,intent(in)                   :: length
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>lenset</b>(3f) truncates a string or pads it with spaces to the specified length.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c82" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom">input string</td>
            </tr>
            <tr valign="top">
              <td class="c82" width="6%" nowrap="nowrap">length</td>
              <td valign="bottom">output string length</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c83" width="6%" nowrap="nowrap">strout</td>
              <td valign="bottom">output string</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_lenset
     use M_strings, only : lenset
     implicit none
     character(len=10)            :: string='abcdefghij'
     character(len=:),allocatable :: answer
        answer=lenset(string,5)
        write(*,'("[",a,"]")') answer
        answer=lenset(string,20)
        write(*,'("[",a,"]")') answer
    end program demo_lenset
<br />
</pre>Expected output:
          <pre>
    [abcde]
    [abcdefghij          ]
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c85"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>listout(3f)</b> - [M_strings:NUMERIC] expand a list of numbers where negative numbers denote range ends (1 <b>-10</b> means 1 thru 10)
          <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>listout</b>(icurve_lists,icurve_expanded,inums,ierr)
<br />
   integer,intent(in)    :: icurve_lists(:)
   integer,intent(out)   :: icurve_expanded(:)
   integer,intent(out)   :: inums
   integer,intent(out)   :: ierr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td colspan="1"><b>icurve_lists</b>(:)</td>
              <td>input array</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td colspan="1"><b>icurve_expanded</b>(:)</td>
              <td>output array; assumed large enough to hold returned list</td>
            </tr>
            <tr valign="top">
              <td class="c86" width="6%" nowrap="nowrap">inums</td>
              <td valign="bottom">number of icurve_expanded numbers on output</td>
            </tr>
            <tr valign="top">
              <td class="c86" width="6%" nowrap="nowrap">ierr</td>
              <td valign="bottom">zero if no error occurred</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
    program demo_listout
    use M_strings, only : listout
    implicit none
    integer,allocatable :: icurve_lists(:)        
    integer :: icurve_expanded(1000)  
    ! icurve_lists is input array
    integer :: inums                  
    ! icurve_expanded is output array
    integer :: i
    ! number of icurve_lists values on input, number of icurve_expanded numbers on output
    integer :: ierr
       icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
       inums=size(icurve_lists)
       call listout(icurve_lists,icurve_expanded,inums,ierr)
       if(ierr.eq.0)then
          write(*,'(i0)')(icurve_expanded(i),i=1,inums)
       else
          write(*,'(a,i0)')'error occurred in *listout* ',ierr
          write(*,'(i0)')(icurve_expanded(i),i=1,inums)
       endif
    end program demo_listout
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c89"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>lower(3f)</b> - [M_strings:CASE] changes a string to lowercase over specified range <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="9" id="9">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
elemental pure function <b>lower</b>(str,begin,end) result (<i>string</i>)
<br />
    character(*), intent(in) :: str
    integer,optional         :: begin, end
    character(len(str))      :: string  ! output string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>lower</b>(<i>string</i>) returns a copy of the input <i>string</i> with all characters converted to miniscule over the specified range,
          assuming ASCII character sets are being used. If no range is specified the entire <i>string</i> is converted to miniscule.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c90" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom"><i>string</i> to convert to miniscule</td>
            </tr>
            <tr valign="top">
              <td class="c90" width="6%" nowrap="nowrap">begin</td>
              <td valign="bottom">optional starting position in "str" to begin converting to miniscule</td>
            </tr>
            <tr valign="top">
              <td class="c90" width="6%" nowrap="nowrap">end</td>
              <td valign="bottom">optional ending position in "str" to stop converting to miniscule</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c90" width="6%" nowrap="nowrap">lower</td>
              <td valign="bottom">copy of the input <i>string</i> with all characters converted to miniscule over optionally specified range.</td>
            </tr>
            <tr>
              <td></td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">TRIVIA</a></h3>
        <blockquote>
          The terms "uppercase" and "lowercase" date back to the early days of the mechanical printing press. Individual metal alloy casts of each needed
          letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were
          stored and organized in wooden cases. The more often needed miniscule letters were placed closer to hand, in the lower cases of the work bench.
          The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.
        </blockquote><a name="6" id="6"></a>
        <h3><a name="6" id="6">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
      program demo_lower
      use M_strings, only: lower
      implicit none
      character(len=:),allocatable  :: s
         s=' ABCDEFG abcdefg '
         write(*,*) 'mixed-case input string is ....',s
         write(*,*) 'lower-case output string is ...',lower(s)
      end program demo_lower
<br />
</pre>Expected output
          <pre>
      mixed-case input string is .... ABCDEFG abcdefg
      lower-case output string is ... abcdefg abcdefg
</pre>
        </blockquote><a name="7" id="7"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c93"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>matchw(3f)</b> - [M_strings:COMPARE] compare given string for match to pattern which may contain wildcard characters <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
logical function <b>matchw</b>(<i>string</i>, pattern )
<br />
    character(len=*),intent(in) :: string
    character(len=*),intent(in) :: pattern
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>matchw</b>(3f) compares given <i>string</i> for match to pattern which may contain wildcard characters.</p>
          <p>In this version to get a match entire <i>string</i> must be described by pattern. Trailing whitespace is significant, so trim the input
          <i>string</i> to have trailing whitespace ignored.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c94" width="6%" nowrap="nowrap">string</td>
              <td valign="bottom">the input <i>string</i> to test to see if it contains the pattern.</td>
            </tr>
            <tr valign="top">
              <td class="c95" colspan="1">pattern</td>
              <td>
                the following simple globbing options are available
                <table width="100%" cellpadding="3">
                  <tr valign="top">
                    <td class="c95" width="6%" nowrap="nowrap">o</td>
                    <td valign="bottom">"?" matching any one character</td>
                  </tr>
                  <tr valign="top">
                    <td class="c95" width="6%" nowrap="nowrap">o</td>
                    <td valign="bottom">"*" matching zero or more characters. Do NOT use adjacent asterisks.</td>
                  </tr>
                  <tr valign="top">
                    <td class="c95" width="6%" nowrap="nowrap">o</td>
                    <td valign="bottom">Both strings may have trailing spaces which are ignored.</td>
                  </tr>
                  <tr valign="top">
                    <td class="c95" width="6%" nowrap="nowrap">o</td>
                    <td valign="bottom">There is no escape character, so matching strings with literal question mark and asterisk is problematic.</td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          Example program
          <pre>
   program demo_matchw
   implicit none
   ! This main() routine passes a bunch of test strings into the above code.
   ! In performance comparison mode, it does that over and over.  Otherwise,
   ! it does it just once.  Either way, it outputs a passed/failed result.
   !
   integer :: nReps
   logical :: allpassed
   integer :: i
    allpassed = .true.
<br />
    nReps = 10000
    nReps = 1     ! Can choose as many repetitions as you're expecting in the real world.
<br />
    do i=1,nReps
     ! Cases with repeating character sequences.
     allpassed=allpassed .and. test("a*abab", "a*b", .true.)
     !!cycle
     allpassed=allpassed .and. test("ab", "*?", .true.)
     allpassed=allpassed .and. test("abc", "*?", .true.)
     allpassed=allpassed .and. test("abcccd", "*ccd", .true.)
     allpassed=allpassed .and. test("bLah", "bLaH", .false.)
     allpassed=allpassed .and. test("mississippi", "*sip*", .true.)
     allpassed=allpassed .and. test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.)
     allpassed=allpassed .and. test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.)
     allpassed=allpassed .and. test("mississipissippi", "*issip*ss*", .true.)
     allpassed=allpassed .and. test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.)
     allpassed=allpassed .and. test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.)
     allpassed=allpassed .and. test("xyxyxyzyxyz", "xy*z*xyz", .true.)
     allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.)
     allpassed=allpassed .and. test("mississippi", "mi*sip*", .true.)
     allpassed=allpassed .and. test("ababac", "*abac*", .true.)
     allpassed=allpassed .and. test("aaazz", "a*zz*", .true.)
     allpassed=allpassed .and. test("a12b12", "*12*23", .false.)
     allpassed=allpassed .and. test("a12b12", "a12b", .false.)
     allpassed=allpassed .and. test("a12b12", "*12*12*", .true.)
<br />
     ! Additional cases where the '*' char appears in the tame string.
     allpassed=allpassed .and. test("*", "*", .true.)
     allpassed=allpassed .and. test("a*r", "a*", .true.)
     allpassed=allpassed .and. test("a*ar", "a*aar", .false.)
<br />
     ! More double wildcard scenarios.
     allpassed=allpassed .and. test("XYXYXYZYXYz", "XY*Z*XYz", .true.)
     allpassed=allpassed .and. test("missisSIPpi", "*SIP*", .true.)
     allpassed=allpassed .and. test("mississipPI", "*issip*PI", .true.)
     allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.)
     allpassed=allpassed .and. test("miSsissippi", "mi*sip*", .true.)
     allpassed=allpassed .and. test("miSsissippi", "mi*Sip*", .false.)
     allpassed=allpassed .and. test("abAbac", "*Abac*", .true.)
     allpassed=allpassed .and. test("aAazz", "a*zz*", .true.)
     allpassed=allpassed .and. test("A12b12", "*12*23", .false.)
     allpassed=allpassed .and. test("a12B12", "*12*12*", .true.)
     allpassed=allpassed .and. test("oWn", "*oWn*", .true.)
<br />
     ! Completely tame (no wildcards) cases.
     allpassed=allpassed .and. test("bLah", "bLah", .true.)
<br />
     ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
     allpassed=allpassed .and. test("a", "*?", .true.)
<br />
     ! More mixed wildcard tests including coverage for false positives.
     allpassed=allpassed .and. test("a", "??", .false.)
     allpassed=allpassed .and. test("ab", "?*?", .true.)
     allpassed=allpassed .and. test("ab", "*?*?*", .true.)
     allpassed=allpassed .and. test("abc", "?**?*?", .true.)
     allpassed=allpassed .and. test("abc", "?**?*&amp;?", .false.)
     allpassed=allpassed .and. test("abcd", "?b*??", .true.)
     allpassed=allpassed .and. test("abcd", "?a*??", .false.)
     allpassed=allpassed .and. test("abcd", "?**?c?", .true.)
     allpassed=allpassed .and. test("abcd", "?**?d?", .false.)
     allpassed=allpassed .and. test("abcde", "?*b*?*d*?", .true.)
<br />
     ! Single-character-match cases.
     allpassed=allpassed .and. test("bLah", "bL?h", .true.)
     allpassed=allpassed .and. test("bLaaa", "bLa?", .false.)
     allpassed=allpassed .and. test("bLah", "bLa?", .true.)
     allpassed=allpassed .and. test("bLaH", "?Lah", .false.)
     allpassed=allpassed .and. test("bLaH", "?LaH", .true.)
<br />
     ! Many-wildcard scenarios.
     allpassed=allpassed .and. test(&amp;
     &amp;"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;
     &amp;ampaaaaaaaaaaaaaaaaaaaaaab",&amp;
     &amp;"a*a*a*a*a*a*aa*aaa*a*a*b",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiaja&amp;
     &amp;ampkalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiaja&amp;
     &amp;ampkalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiaja&amp;
     &amp;ampkalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abababababababababababababababababababaacacacacacacacadaeafagahaiaja&amp;
     &amp;ampkalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp;
     &amp;"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("aaabbaabbaab", "*aabbaa*a*", .true.)
     allpassed=allpassed .and. test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", &amp;
     &amp;"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.)
     allpassed=allpassed .and. test("aaaaaaaaaaaaaaaaa", &amp;
     &amp;"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.)
     allpassed=allpassed .and. test("aaaaaaaaaaaaaaaa", &amp;
     &amp;"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij*&amp;
     &amp;ampabcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp;
     &amp; "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&amp;
     &amp;.false.)
     allpassed=allpassed .and. test(&amp;
     &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij*&amp;
     &amp;ampabcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp;
     &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("abc*abcd*abcd*abc*abcd", "abc*abc*abc*abc*abc", .false.)
     allpassed=allpassed .and. test( "abc*abcd*abcd*abc*abcd*abcd*abc*abcd*abc*abc*abcd", &amp;
     &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&amp;
     &amp;.true.)
     allpassed=allpassed .and. test("abc", "********a********b********c********", .true.)
     allpassed=allpassed .and. test("********a********b********c********", "abc", .false.)
     allpassed=allpassed .and. test("abc", "********a********b********b********", .false.)
     allpassed=allpassed .and. test("*abc*", "***a*b*c***", .true.)
<br />
     ! A case-insensitive algorithm test.
     ! allpassed=allpassed .and. test("mississippi", "*issip*PI", .true.)
    enddo
<br />
    if (allpassed)then
       write(*,'(a)')"Passed",nReps
    else
       write(*,'(a)')"Failed"
    endif
   contains
   ! This is a test program for wildcard matching routines.  It can be used
   ! either to test a single routine for correctness, or to compare the timings
   ! of two (or more) different wildcard matching routines.
   !
   function test(tame, wild, bExpectedResult) result(bpassed)
   use M_strings, only : matchw
      character(len=*) :: tame
      character(len=*) :: wild
      logical          :: bExpectedResult
      logical          :: bResult
      logical          :: bPassed
      bResult = .true.    ! We'll do "&amp;=" cumulative checking.
      bPassed = .false.   ! Assume the worst.
      write(*,*)repeat('=',79)
      bResult = matchw(tame, wild) ! Call a wildcard matching routine.
<br />
      ! To assist correctness checking, output the two strings in any failing scenarios.
      if (bExpectedResult .eqv. bResult) then
         bPassed = .true.
         if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
      else
         if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
      endif
<br />
   end function test
   end program demo_matchw
<br />
</pre>Expected output
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c97"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>merge_str(3f)</b> - [M_strings:LENGTH] pads strings to same length and then calls <b>MERGE</b>(3f) <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>merge_str</b>(str1,str2,expr) <b>result</b>(<i>strout</i>)
<br />
    character(len=*),intent(in)     :: str1
    character(len=*),intent(in)     :: str2
    logical,intent(in)              :: expr
    character(len=:),allocatable    :: strout
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>merge_str</b>(3f) pads the shorter of str1 and str2 to the longest length of str1 and str2 and then calls
          <b>MERGE</b>(padded_str1,padded_str2,expr). It trims trailing spaces off the result and returns the trimmed string. This makes it easier to call
          <b>MERGE</b>(3f) with strings, as <b>MERGE</b>(3f) requires the strings to be the same length.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_merge_str
    use M_strings, only : merge_str
    implicit none
    character(len=:), allocatable :: answer
       answer=merge_str('first string', 'second string is longer',10.eq.10)
       write(*,'("[",a,"]")') answer
       answer=merge_str('first string', 'second string is longer',10.ne.10)
       write(*,'("[",a,"]")') answer
    end program demo_merge_str
<br />
</pre>
          <blockquote>
            Expected output
            <pre>
    [first string]
    [second string is longer]
</pre>
          </blockquote>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c100"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>modif(3f)</b> - [M_strings:EDITING] emulate the MODIFY command from the line editor XEDIT <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>modif</b>(cline,cmod)
<br />
    character(len=*) :: cline ! input string to change
    character(len=*) :: cmod  ! directive provides directions on changing string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>MODIF</b>(3f) Modifies the line currently pointed at using a directive that acts much like a line editor directive. Primarily used to create
          interactive utilities such as input history editors for interactive line-mode programs.</p>
          <p>the modify directives are as follows-</p>
        </blockquote><a name=""></a>
        <h4><a name="">DIRECTIVE EXPLANATION</a></h4>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c101" colspan="1">^STRING#</td>
              <td>
                Causes the string of characters between the ^ and the next # to be inserted before the characters pointed to by the ^. an ^ or &amp; within
                the string is treated as a regular character. If the closing # is not specified, <b>MODIF</b>(3f) inserts the remainder of the line as if a
                # was specified after the last nonblank character.
                <p>There are two exceptions. the combination ^# causes a # to be inserted before the character pointed to by the ^, and an ^ as the last
                character of the directives causes a blank to be inserted.</p>
              </td>
            </tr>
            <tr valign="top">
              <td class="c101" width="6%" nowrap="nowrap">#</td>
              <td valign="bottom">(When not the first # after an ^) causes the character above it to be deleted.</td>
            </tr>
            <tr valign="top">
              <td class="c101" width="6%" nowrap="nowrap">&amp;</td>
              <td valign="bottom">Replaces the character above it with a space.</td>
            </tr>
            <tr valign="top">
              <td class="c101" width="6%" nowrap="nowrap">(SPACE)</td>
              <td valign="bottom">A space below a character leaves it unchanged.</td>
            </tr>
          </table>Any other character replaces the character above it.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Example input/output:
          <pre>
   THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
   THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
   ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
<br />
</pre>Sample program:
          <pre>
   program demo_modif
   use M_strings, only : modif
   implicit none
   character(len=256)           :: line
   integer                      :: ios
   integer                      :: count
   integer                      :: COMMAND_LINE_LENGTH
   character(len=:),allocatable :: COMMAND_LINE
      ! get command name length
      call get_command_argument(0,length=count)
      ! get command line length
      call get_command(length=COMMAND_LINE_LENGTH)
      ! allocate string big enough to hold command line
      allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
      ! get command line as a string
      call get_command(command=COMMAND_LINE)
      ! trim leading spaces just in case
      COMMAND_LINE=adjustl(COMMAND_LINE)
      ! remove command name
      COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
      INFINITE: do
         read(*,'(a)',iostat=ios)line
         if(ios.ne.0)exit
         call modif(line,COMMAND_LINE)
         write(*,'(a)')trim(line)
      enddo INFINITE
   end program demo_modif
<br />
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c104"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>msg(3f)</b> - [M_strings] converts any standard scalar type to a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>msg</b>(g1,g2g3,g4,g5,g6,g7,g8,g9,nospace)
<br />
    class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
    logical,intent(in),optional   :: nospace
    character,len=(:),allocatable :: msg
<br />
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>msg</b>(3f) builds a space-separated string from up to nine scalar values.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c105" width="6%" nowrap="nowrap">g[1-9]</td>
              <td valign="bottom">optional value to print the value of after the message. May be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
              or CHARACTER.</td>
            </tr>
            <tr valign="top">
              <td class="c105" colspan="1">nospace</td>
              <td>if nospace=.true., then no spaces are added between values</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c105" width="6%" nowrap="nowrap">msg</td>
              <td valign="bottom">description to print</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_msg
   use M_strings, only : msg
   implicit none
   character(len=:),allocatable :: pr
   character(len=:),allocatable :: frmt
   integer                      :: biggest
<br />
   pr=msg('HUGE(3f) integers',huge(0),'and real',huge(0.0),'and double',huge(0.0d0))
   write(*,'(a)')pr
   pr=msg('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
   write(*,'(a)')pr
   pr=msg('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
   write(*,'(a)')pr
   pr=msg('complex         :',cmplx(huge(0.0),tiny(0.0)) )
   write(*,'(a)')pr
<br />
   ! create a format on the fly
   biggest=huge(0)
   frmt=msg('(*(i',int(log10(real(biggest))),':,1x))',nospace=.true.)
   write(*,*)'format=',frmt
<br />
   ! although it will often work, using msg(3f) in an I/O statement is not recommended
   write(*,*)msg('program will now stop')
<br />
   end program demo_msg
<br />
</pre>
        </blockquote>Output
        <pre>
   HUGE(3f) integers 2147483647 and real 3.40282347E+38 and double 1.7976931348623157E+308
   real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
   doubleprecision : 1.7976931348623157E+308 0.0000000000000000 12345.678900000001 2.2250738585072014E-308
   complex         : (3.40282347E+38,1.17549435E-38)
    format=(*(i9:,1x))
    program will now stop
<br />
</pre><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c108"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>noesc(3f)</b> - [M_strings:NONALPHA] convert non-printable characters to a space. <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
elemental function <b>noesc</b>(<i>INSTR</i>)
<br />
    character(len=*),intent(in) :: INSTR
    character(len=len(instr))   :: noesc
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Convert non-printable characters to a space.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_noesc
<br />
    use M_strings, only : noesc
    character(len=128) :: ascii
    character(len=128) :: cleared
    ! fill variable with base ASCII character set
    do i=1,128
       ascii(i:i)=char(i-1)
    enddo
    cleared=noesc(ascii)
    write(*,*)'characters and their ADE (ASCII Decimal Equivalent)'
    call ade(ascii)
    write(*,*)'Cleared of non-printable characters'
    call ade(cleared)
    write(*,*)'Cleared string:'
    write(*,*)cleared
    contains
      subroutine ade(string)
      implicit none
      ! the string to print
      character(len=*),intent(in) :: string
      ! number of characters in string to print
      integer :: ilen
      ! counter used to step thru string
      integer :: i
         ! get trimmed length of input string
         ilen=len_trim(string(:len(string)))
<br />
         ! replace lower unprintable characters with spaces
         write(*,101)(merge(string(i:i),' ',&amp;
         &amp; ichar(string(i:i)).ge.32         &amp;
         &amp; .and.                            &amp;
         &amp; ichar(string(i:i)).le.126)       &amp;
         &amp; ,i=1,ilen)
<br />
         ! print ADE value of character underneath it
         write(*,202)     (ichar(string(i:i))/100,    i=1,ilen)
         write(*,202)(mod( ichar(string(i:i)),100)/10,i=1,ilen)
         write(*,202)(mod((ichar(string(i:i))),10),   i=1,ilen)
      ! format for printing string characters
      101   format(*(a1:))
      ! format for printing ADE values
      202   format(*(i1:))
      end subroutine ade
    end program demo_noesc
<br />
</pre>
          <blockquote>
            Expected output
            <p>The string is printed with the ADE value vertically beneath. The original string has all the ADEs from 000 to 127. After <b>NOESC</b>(3f) is
            called on the string all the "non-printable" characters are replaced with a space (ADE of 032).</p>
          </blockquote>
          <p>characters and their ADE (ASCII Decimal Equivalent)</p>
          <pre>
   &gt;                                 !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;
   ;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~
   &gt;0000000000000000000000000000000000000000000000000000000000000000000000000
   0000000000000000000000000001111111111111111111111111111
   &gt;0000000000111111111122222222223333333333444444444455555555556666666666777
   7777777888888888899999999990000000000111111111122222222
   &gt;0123456789012345678901234567890123456789012345678901234567890123456789012
   3456789012345678901234567890123456789012345678901234567
<br />
</pre>Cleared of non-printable characters
          <pre>
   &gt;                                 !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
   [\]^_'abcdefghijklmnopqrstuvwxyz{|}~
   &gt;0000000000000000000000000000000000000000000000000000000000000000000000000
   000000000000000000000000000111111111111111111111111111
   &gt;3333333333333333333333333333333333333333444444444455555555556666666666777
   777777788888888889999999999000000000011111111112222222
   &gt;2222222222222222222222222222222223456789012345678901234567890123456789012
   345678901234567890123456789012345678901234567890123456
<br />
</pre>Cleared string:
          <blockquote>
            <table cellpadding="3">
              <tr valign="top">
                <td class="c109" width="6%" nowrap="nowrap">&gt;</td>
                <td valign="bottom">!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [\]^_'abcdefghijklmnopqrstuvwxyz{|}~</td>
              </tr>
            </table>
          </blockquote>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c112"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>nospace(3f)</b> - [M_strings:WHITESPACE] remove all whitespace from input string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>nospace</b>(<i>str</i>) - remove all whitespace from input string
<br />
    character(len=*),intent(in)          :: str
    character(len=:),allocatable         :: nospace
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>nospace</b>(3f) removes space, tab, carriage return, new line, vertical tab, formfeed and null characters (called "whitespace"). The output
          is returned trimmed.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
    program demo_nospace
    use M_strings, only: nospace
    implicit none
    character(len=:),allocatable  :: s
       s='  This     is      a     test  '
       write(*,*) 'original input string is ....',s
       write(*,*) 'processed output string is ...',nospace(s)
       if(nospace(s).eq.'Thisisatest')then
          write(*,*)'nospace test passed'
       else
          write(*,*)'nospace test error'
       endif
    end program demo_nospace
<br />
</pre>Expected output
          <pre>
    original input string is ....  This     is      a     test
    processed output string is ...Thisisatest
    nospace test passed
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c115"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>notabs(3f)</b> - [M_strings:NONALPHA] expand tab characters <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>notabs</b>(INSTR,OUTSTR,ILEN)
<br />
    character(len=*),intent=(in)  :: INSTR
    character(len=*),intent=(out) :: OUTSTR
    integer,intent=(out)          :: ILEN
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>NOTABS</b>() converts tabs in INSTR to spaces in OUTSTR while maintaining columns. It assumes a tab is set every 8 characters. Trailing spaces
          are removed.
          <p>In addition, trailing carriage returns and line feeds are removed (they are usually a problem created by going to and from MSWindows).</p>
          <p>What are some reasons for removing tab characters from an input line? Some Fortran compilers have problems with tabs, as tabs are not</p>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c116" colspan="1">part of the Fortran character set.</td>
              <td>Some editors and printers will</td>
            </tr>
            <tr valign="top">
              <td class="c116" colspan="1">have problems with tabs.</td>
              <td>It is often useful to expand tabs in input files to simplify further processing such as tokenizing an input line.</td>
            </tr>
          </table>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c116" width="6%" nowrap="nowrap">instr</td>
              <td valign="bottom">Input line to remove tabs from</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c116" width="6%" nowrap="nowrap">outstr</td>
              <td valign="bottom">Output string with tabs expanded.</td>
            </tr>
            <tr valign="top">
              <td class="c116" width="6%" nowrap="nowrap">ilen</td>
              <td valign="bottom">Significant length of returned string</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_notabs
<br />
   !  test filter to remove tabs and trailing white space from input
   !  on files up to 1024 characters wide
   use M_strings, only : notabs
   character(len=1024) :: in,out
   integer             :: ios,iout
      READFILE: block
         do
            read(*,'(A)',iostat=ios)in
            if(ios /= 0) exit READFILE
            call notabs(in,out,iout)
            write(*,'(a)')out(:iout)
         enddo
      endblock READFILE
<br />
   end program demo_notabs
</pre>SEE ALSO: GNU/Unix commands <b>expand</b>(1) and <b>unexpand</b>(1)
        </blockquote>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c119"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>quote(3f)</b> - [M_strings:QUOTES] add quotes to string as if written with list-directed input <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>quote</b>(str,mode,clip) result (<i>quoted_str</i>)
<br />
   character(len=*),intent(in)          :: str
   character(len=*),optional,intent(in) :: mode
   logical,optional,intent(in)          :: clip
   character(len=:),allocatable         :: quoted_str
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Add quotes to a CHARACTER variable as if it was written using list-directed input. This is particularly useful for processing strings to add to
          CSV files.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c120" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom">input string to add quotes to, using the rules of list-directed input (single quotes are replaced by two adjacent
              quotes)</td>
            </tr>
            <tr valign="top">
              <td class="c120" width="6%" nowrap="nowrap">mode</td>
              <td valign="bottom">
                alternate quoting methods are supported:
                <pre>
                  DOUBLE   default. replace quote with double quotes
                  ESCAPE   replace quotes with backslash-quote instead of double quotes
            </pre>/td&gt;
              </td>
            </tr>
            <tr valign="top">
              <td class="c120" width="6%" nowrap="nowrap">clip</td>
              <td valign="bottom">default is to trim leading and trailing spaces from the string. If CLIP is .FALSE. spaces are not trimmed</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULT</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c121" colspan="1">quoted_str</td>
              <td>The output string, which is based on adding quotes to STR.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_quote
   use M_strings, only : quote
   implicit none
   character(len=:),allocatable :: str
   character(len=1024)          :: msg
   integer                      :: ios
   character(len=80)            :: inline
      do
         write(*,'(a)',advance='no')'Enter test string:'
         read(*,'(a)',iostat=ios,iomsg=msg)inline
         if(ios.ne.0)then
            write(*,*)trim(inline)
            exit
         endif
<br />
         ! the original string
         write(*,'(a)')'ORIGINAL     ['//trim(inline)//']'
<br />
         ! the string processed by quote(3f)
         str=quote(inline)
         write(*,'(a)')'QUOTED     ['//str//']'
<br />
         ! write the string list-directed to compare the results
         write(*,'(a)',iostat=ios,iomsg=msg) 'LIST DIRECTED:'
         write(*,*,iostat=ios,iomsg=msg,delim='none') inline
         write(*,*,iostat=ios,iomsg=msg,delim='quote') inline
         write(*,*,iostat=ios,iomsg=msg,delim='apostrophe') inline
      enddo
   end program demo_quote
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c123"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>replace(3f)</b> - [M_strings:EDITING] function globally replaces one substring for another in string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>replace</b>(targetline[,old,new|cmd],range,ierr) result (<i>newline</i>)
<br />
    character(len=*)                       :: targetline
    character(len=*),intent(in),optional   :: old
    character(len=*),intent(in),optional   :: new
    character(len=*),intent(in),optional   :: cmd
    integer,intent(in),optional            :: range(2)
    integer,intent(out),optional           :: ierr
    logical,intent(in),optional            :: clip
    character(len=:),allocatable           :: newline
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Globally replace one substring for another in string. Either CMD or OLD and NEW must be specified.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c124" colspan="1">targetline</td>
              <td>input line to be changed</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">old</td>
              <td valign="bottom">old substring to replace</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">new</td>
              <td valign="bottom">new substring</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">cmd</td>
              <td valign="bottom">alternate way to specify old and new string, in the form c/old/new/; where "/" can be any character not in "old" or
              "new"</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">range</td>
              <td valign="bottom">if present, only change <b>range</b>(1) to <b>range</b>(2) of occurrences of old string</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">ierr</td>
              <td valign="bottom">error code. iF ier = <b>-1</b> bad directive, &gt;= 0 then count of changes made</td>
            </tr>
            <tr valign="top">
              <td class="c124" width="6%" nowrap="nowrap">clip</td>
              <td valign="bottom">whether to return trailing spaces or not. Defaults to .false.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c125" colspan="1">newline</td>
              <td>allocatable string returned</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_replace
   use M_strings, only : replace
   implicit none
   character(len=:),allocatable :: targetline
<br />
   targetline='this is the input string'
<br />
   call testit('th','TH','THis is THe input string')
<br />
   ! a null old substring means "at beginning of line"
   call testit('','BEFORE:', 'BEFORE:THis is THe input string')
<br />
   ! a null new string deletes occurrences of the old substring
   call testit('i','', 'BEFORE:THs s THe nput strng')
<br />
   write(*,*)'Examples of the use of RANGE='
<br />
   targetline=replace('a b ab baaa aaaa','a','A')
   write(*,*)'replace a with A ['//targetline//']'
<br />
   targetline=replace('a b ab baaa aaaa','a','A',range=[3,5])
   write(*,*)'replace a with A instances 3 to 5 ['//targetline//']'
<br />
   targetline=replace('a b ab baaa aaaa','a','',range=[3,5])
   write(*,*)'replace a with null instances 3 to 5 ['//targetline//']'
<br />
   targetline=replace('a b ab baaa aaaa aa aa a a a aa aaaaaa','aa','CCCC',range=[3,5])
   write(*,*)'replace aa with CCCC instances 3 to 5 ['//targetline//']'
<br />
   contains
   subroutine testit(old,new,expected)
   character(len=*),intent(in) :: old,new,expected
   write(*,*)repeat('=',79)
   write(*,*)'STARTED ['//targetline//']'
   write(*,*)'OLD['//old//']', ' NEW['//new//']'
   targetline=replace(targetline,old,new)
   write(*,*)'GOT     ['//targetline//']'
   write(*,*)'EXPECTED['//expected//']'
   write(*,*)'TEST    [',targetline.eq.expected,']'
   end subroutine testit
<br />
   end program demo_replace
<br />
</pre>Expected output
          <pre>
    ===============================================================================
    STARTED [this is the input string]
    OLD[th] NEW[TH]
    GOT     [THis is THe input string]
    EXPECTED[THis is THe input string]
    TEST    [ T ]
    ===============================================================================
    STARTED [THis is THe input string]
    OLD[] NEW[BEFORE:]
    GOT     [BEFORE:THis is THe input string]
    EXPECTED[BEFORE:THis is THe input string]
    TEST    [ T ]
    ===============================================================================
    STARTED [BEFORE:THis is THe input string]
    OLD[i] NEW[]
    GOT     [BEFORE:THs s THe nput strng]
    EXPECTED[BEFORE:THs s THe nput strng]
    TEST    [ T ]
    Examples of the use of RANGE=
    replace a with A [A b Ab bAAA AAAA]
    replace a with A instances 3 to 5 [a b ab bAAA aaaa]
    replace a with null instances 3 to 5 [a b ab b aaaa]
    replace aa with CCCC instances 3 to 5 [a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa]
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c127"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>reverse(3f)</b> - [M_strings:EDITING] Return a string reversed <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
elemental pure function <b>reverse</b>(<i>str</i>) result (<i>string</i>)
<br />
    character(*), intent(in) :: str
    character(len(str))      :: string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>reverse</b>(<i>string</i>) returns a copy of the input <i>string</i> with all characters reversed from right to left.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
      program demo_reverse
      use M_strings, only: reverse
      implicit none
      character(len=:),allocatable  :: s
         write(*,*)'REVERSE STRINGS:',reverse('Madam, I''m Adam')
         s='abcdefghijklmnopqrstuvwxyz'
         write(*,*) 'original input string is ....',s
         write(*,*) 'reversed output string is ...',reverse(s)
      end program demo_reverse
<br />
</pre>Expected output
          <pre>
     original input string is ....abcdefghijklmnopqrstuvwxyz
     reversed output string is ...zyxwvutsrqponmlkjihgfedcba
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c130"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>rotate13(3f)</b> - [M_strings] apply trivial ROT13 encryption to a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
<b>rotate13</b>(<i>input</i>) <b>result</b>(<i>output</i>)
<br />
    character(len=*),intent(in) :: input
    character(len=len(input))   :: output
<br />
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter
          after it in the alphabet; wrapping around if necessary.
          <p>The transformation can be done using a lookup table, such as the following:</p>
          <pre>
      Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
      Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
<br />
</pre>ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. ROT13 has
inspired a variety of letter and word games on-line, and is frequently mentioned in newsgroup conversations.
          <p>The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.</p>
          <p>ROT13 is a special case of the Caesar cipher which was developed in ancient Rome.</p>
        </blockquote><a name=""></a>
        <h4><a name="">ALGORITHM</a></h4>
        <blockquote>
          <p>Applying ROT13 to a piece of text merely requires examining its alphabetic characters and replacing each one by the letter 13 places further
          along in the alphabet, wrapping back to the beginning if necessary. A becomes N, B becomes O, and so on up to M, which becomes Z, then the
          sequence continues at the beginning of the alphabet: N becomes A, O becomes B, and so on to Z, which becomes M. Only those letters which occur in
          the English alphabet are affected; numbers, symbols, whitespace, and all other characters are left unchanged.</p>
        </blockquote><a name=""></a>
        <h4><a name="">SAME ALGORITHM FOR ENCODING AND DECODING</a></h4>
        <blockquote>
          <p>Because there are 26 letters in the English alphabet and 26 = 2 x 13, the ROT13 function is its own inverse: so the same action can be used for
          encoding and decoding. In other words, two successive applications of ROT13 restore the original text (in mathematics, this is sometimes called an
          involution; in cryptography, a reciprocal cipher).</p>
        </blockquote><a name=""></a>
        <h4><a name="">TRIVIAL SECURITY</a></h4>
        <blockquote>
          <p>the use of a constant shift means that the encryption effectively has no key, and decryption requires no more knowledge than the fact that
          ROT13 is in use. Even without this knowledge, the algorithm is easily broken through frequency analysis.</p>
          <p>In encrypted normal English-language text of any significant size, ROT13 is recognizable from some letter/word patterns. The words "n", "V"
          (capitalized only), and "gur" (ROT13 for "a", "I", and "the"), and words ending in "yl" ("ly") are examples.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">REFERENCES</a></h3>
        <blockquote>
          Wikipedia, the free encyclopedia
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLE</a></h3>
        <blockquote>
          Sample program
          <pre>
   program demo_rotate13
   use M_strings, only : rotate13
   implicit none
   character(len=256) :: line
   integer            :: ios
   do
      read(*,'(a)',iostat=ios)line
      if(ios.ne.0)exit
      write(*,'(a)')rotate13(line)
   enddo
   end program demo_rotate13
<br />
</pre>
        </blockquote>Sample usage: demo_rotate13 United we stand, divided we fall. Havgrq jr fgnaq, qvivqrq jr snyy. <a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c133"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>s2c(3f)</b> - [M_strings:ARRAY] convert character variable to array of characters with last element set to null <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>s2c</b>(<i>string</i>)
<br />
    character(len=*),intent=(in)  :: string
    character(len=1),allocatable  :: s2c(:)
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Given a character variable convert it to an array of single-character character variables with the last element set to a null character. This is
          generally used to pass character variables to C procedures.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_s2c
    use M_strings, only : s2c
    implicit none
    character(len=*),parameter   :: string="single string"
    character(len=3),allocatable :: array(:)
       write(*,*)'INPUT STRING ',trim(string)
       ! put one character into each 3-character element of array
       array=s2c(string)
       ! write array with ASCII Decimal Equivalent below it except show
       ! unprintable characters like NULL as "XXX"
       write(*,'(1x,*("[",a3,"]":))')&amp;
            &amp; merge('XXX',array,ichar(array(:)(1:1)).lt.32)
       write(*,'(1x,*("[",i3,"]":))')&amp;
            &amp; ichar(array(:)(1:1))
    end program demo_s2c
<br />
</pre>
        </blockquote>Expected output:
        <pre>
   INPUT STRING single string
   [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
   [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
<br />
</pre><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c136"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>s2v(3f)</b> - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>s2v</b>(string[,ierr][,onerr])
<br />
    character(len=*)             :: string
    doubleprecision              :: s2v
    integer,intent(out),optional :: ierr
    class(*),intent(in),optional :: onerr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          This function converts a string to a DOUBLEPRECISION numeric value.
          <p>The intrinsics <b>INT</b>(3f), <b>REAL</b>(3f), and <b>DBLE</b>(3f) are also extended to take CHARACTER variables. The KIND= keyword is not
          supported on the extensions.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c137" width="6%" nowrap="nowrap">string</td>
              <td valign="bottom">holds string assumed to represent a numeric value</td>
            </tr>
            <tr valign="top">
              <td class="c137" width="6%" nowrap="nowrap">ierr</td>
              <td valign="bottom">If an error occurs the program is stopped if the optional parameter IERR is not present. If IERR returns a non-zero value
              an error occurred.</td>
            </tr>
            <tr valign="top">
              <td class="c137" width="6%" nowrap="nowrap">onerr</td>
              <td valign="bottom">The value to return on error. A value of zero (NaN) is returned on error by default.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          s2v
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_s2v
<br />
    use M_strings, only: s2v, int, real, dble
    implicit none
    character(len=8)              :: s=' 10.345 '
    integer                       :: i
    character(len=14),allocatable :: strings(:)
    doubleprecision               :: dv
    integer                       :: errnum
<br />
    ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
    strings=[&amp;
    &amp;' 10.345       ',&amp;
    &amp;'+10           ',&amp;
    &amp;'    -3        ',&amp;
    &amp;'    -4.94e-2  ',&amp;
    &amp;'0.1           ',&amp;
    &amp;'12345.678910d0',&amp;
    &amp;'              ',&amp; ! Note: will return zero without an error message
    &amp;'1 2 1 2 1 . 0 ',&amp; ! Note: spaces will be ignored
    &amp;'WHAT?         ']  ! Note: error messages will appear, zero returned
<br />
    ! a numeric value is returned, so it can be used in numeric expression
    write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
    write(*,*)
    write(*,*)' STRING            VALUE                    ERROR_NUMBER'
    do i=1,size(strings)
       ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
       ! as it does I/O when errors occur, so called on a separate line
       dv=s2v(strings(i),errnum)
       write(*,*) strings(i)//'=',dv,errnum
    enddo
    write(*,*)"Extended intrinsics"
    write(*,*)'given inputs:',s,strings(:8)
    write(*,*)'INT(3f):',int(s),int(strings(:8))
    write(*,*)'REAL(3f):',real(s),real(strings(:8))
    write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
    write(*,*)"That's all folks!"
<br />
    end program demo_s2v
<br />
</pre>
          <blockquote>
            Expected output
            <pre>
    &gt;1/2 value of string is    5.1725000000000003
    &gt;
    &gt; STRING            VALUE                    ERROR_NUMBER
    &gt; 10.345       =   10.345000000000001                0
    &gt;+10           =   10.000000000000000                0
    &gt;    -3        =  -3.0000000000000000                0
    &gt;    -4.94e-2  =  -4.9399999999999999E-002           0
    &gt;0.1           =  0.10000000000000001                0
    &gt;12345.678910d0=   12345.678910000001                0
    &gt;              =   0.0000000000000000                0
    &gt;1 2 1 2 1 . 0 =   12121.000000000000                0
    &gt;*a2d* - cannot produce number from string [WHAT?]
    &gt;*a2d* - [Bad value during floating point read]
    &gt;WHAT?         =   0.0000000000000000             5010
    &gt;Extended intrinsics
    &gt;given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1 12345.678910d0 1 2 1 2 1 . 0
    &gt;INT(3f): 10 10 10 -3 0 0 12345 0 12121
    &gt;REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000 -4.94000018E-02
    &gt;          0.100000001 12345.6787 0.00000000 12121.0000
    &gt;DBLE(3f): 10.345000000000001 10.345000000000001 10.000000000000000
    &gt;          -3.0000000000000000 -4.9399999999999999E-002 0.10000000000000001
    &gt;          12345.678910000001 0.0000000000000000 12121.000000000000
    &gt;That's all folks!
</pre>
          </blockquote>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c140"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>s2vs(3f)</b> - [M_strings:NUMERIC] given a string representing numbers return a numeric array <b>(LICENSE:PD)</b>
          <h3><a name="8" id="8">SYNOPSIS</a></h3>
          <blockquote>
            <pre>
function <b>s2vs</b>(line[,delim])
<br />
       character(len=*) :: line
       doubleprecision,allocatable :: s2vs(:)
</pre>
          </blockquote><a name="2" id="2"></a>
          <h3><a name="2" id="2">DESCRIPTION</a></h3>
          <blockquote>
            <p>The function <b>S2VS</b>(3f) takes a string representing a series of numbers and converts it to a numeric doubleprecision array. The string
            values may be delimited by spaces, semi-colons, and commas by default.</p>
          </blockquote><a name="3" id="3"></a>
          <h3><a name="3" id="3">OPTIONS</a></h3>
          <blockquote>
            <table cellpadding="3">
              <tr valign="top">
                <td class="c141" width="6%" nowrap="nowrap">LINE</td>
                <td valign="bottom">Input string containing numbers</td>
              </tr>
              <tr valign="top">
                <td class="c141" width="6%" nowrap="nowrap">DELIM</td>
                <td valign="bottom">optional list of delimiter characters. If a space is included, it should appear as the left-most character in the list.
                The default is " ;," (spaces, semi-colons, and commas).</td>
              </tr>
            </table>
          </blockquote><a name="4" id="4"></a>
          <h3><a name="4" id="4">RESULTS</a></h3>
          <blockquote>
            <table cellpadding="3">
              <tr valign="top">
                <td class="c141" width="6%" nowrap="nowrap">S2VS</td>
                <td valign="bottom">doubleprecision array</td>
              </tr>
            </table>
          </blockquote><a name="5" id="5"></a>
          <h3><a name="5" id="5">EXAMPLE</a></h3>
          <blockquote>
            Sample Program:
            <pre>
     program demo_s2vs
     use M_strings, only : s2vs
     character(len=80)           :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
     doubleprecision,allocatable :: values(:)
     integer,allocatable         :: ivalues(:)
<br />
     values=s2vs(s)
     ivalues=int(s2vs(s))
     call reportit()
<br />
     contains
       subroutine reportit()
         write(*,*)'S2VS:'
         write(*,*)'input string.............',trim(s)
         write(*,*)'number of values found...',size(values)
         write(*,*)'values...................',(values(ii),ii=1,size(values))
         write(*,*)'ivalues..................',(ivalues(ii),ii=1,size(values))
       end subroutine reportit
     end program demo_s2vs
<br />
</pre>
            <blockquote>
              Expected output
              <pre>
    S2VS:
    input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found... 6
    values................... 10.000000000000000  20000.000000000000 3.4500000000000002
    -4.0030000000000001       1234.0000000000000  5678.0000000000000
    ivalues.................. 10  20000  3  -4 1234 5678
</pre>
            </blockquote>
          </blockquote><a name="6" id="6"></a>
        </blockquote>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c144"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>split(3f)</b> - [M_strings:TOKENS] parse string into an array using specified delimiters <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>split</b>(input_line,array,delimiters,order,nulls)
<br />
    character(len=*),intent(in)              :: input_line
    character(len=:),allocatable,intent(out) :: array(:)
    character(len=*),optional,intent(in)     :: delimiters
    character(len=*),optional,intent(in)     :: order
    character(len=*),optional,intent(in)     :: nulls
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>SPLIT</b>(3f) parses a string using specified delimiter characters and store tokens into an allocatable array
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c145" colspan="1">INPUT_LINE</td>
              <td>Input string to tokenize</td>
            </tr>
            <tr valign="top">
              <td class="c145" width="6%" nowrap="nowrap">ARRAY</td>
              <td valign="bottom">Output array of tokens</td>
            </tr>
            <tr valign="top">
              <td class="c145" colspan="1">DELIMITERS</td>
              <td>
                List of delimiter characters. The default delimiters are the "whitespace" characters (space, tab,new line, vertical tab, formfeed, carriage
                return, and null). You may specify an alternate set of delimiter characters.
                <p>Multi-character delimiters are not supported (Each character in the DELIMITERS list is considered to be a delimiter).</p>
                <p>Quoting of delimiter characters is not supported.</p>
              </td>
            </tr>
            <tr valign="top">
              <td class="c145" colspan="1">ORDER SEQUENTIAL|REVERSE|RIGHT</td>
              <td>Order of output array. By default ARRAY contains the tokens having parsed the INPUT_LINE from left to right. If ORDER='RIGHT' or
              ORDER='REVERSE' the parsing goes from right to left.</td>
            </tr>
            <tr valign="top">
              <td class="c145" colspan="1">NULLS IGNORE|RETURN|IGNOREEND</td>
              <td>Treatment of null fields. By default adjacent delimiters in the input string do not create an empty string in the output array. if
              NULLS='return' adjacent delimiters create an empty element in the output ARRAY. If NULLS='ignoreend' then only trailing delimiters at the
              right of the string are ignored.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_split
   use M_strings, only: split
   character(len=*),parameter     :: &amp;
   &amp; line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
   character(len=:),allocatable :: array(:) ! output array of tokens
      write(*,*)'INPUT LINE:['//LINE//']'
      write(*,'(80("="))')
      write(*,*)'typical call:'
      CALL split(line,array)
      write(*,'(i0," ==&gt; ",a)')(i,trim(array(i)),i=1,size(array))
      write(*,*)'SIZE:',SIZE(array)
      write(*,'(80("-"))')
      write(*,*)'custom list of delimiters (colon and vertical line):'
      CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')
      write(*,'(i0," ==&gt; ",a)')(i,trim(array(i)),i=1,size(array))
      write(*,*)'SIZE:',SIZE(array)
      write(*,'(80("-"))')
      write(*,*)&amp;
    &amp;'custom list of delimiters, reverse array order and count null fields:'
      CALL split(line,array,delimiters=':|',order='reverse',nulls='return')
      write(*,'(i0," ==&gt; ",a)')(i,trim(array(i)),i=1,size(array))
      write(*,*)'SIZE:',SIZE(array)
      write(*,'(80("-"))')
      write(*,*)'INPUT LINE:['//LINE//']'
      write(*,*)&amp;
      &amp;'default delimiters and reverse array order and return null fields:'
      CALL split(line,array,delimiters='',order='reverse',nulls='return')
      write(*,'(i0," ==&gt; ",a)')(i,trim(array(i)),i=1,size(array))
      write(*,*)'SIZE:',SIZE(array)
   end program demo_split
<br />
</pre>
          <blockquote>
            Output
            <pre>
   &gt; INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
   &gt; ===========================================================================
   &gt;  typical call:
   &gt; 1 ==&gt; aBcdef
   &gt; 2 ==&gt; ghijklmnop
   &gt; 3 ==&gt; qrstuvwxyz
   &gt; 4 ==&gt; 1:|:2
   &gt; 5 ==&gt; 333|333
   &gt; 6 ==&gt; a
   &gt; 7 ==&gt; B
   &gt; 8 ==&gt; cc
   &gt;  SIZE:           8
   &gt; --------------------------------------------------------------------------
   &gt;  custom list of delimiters (colon and vertical line):
   &gt; 1 ==&gt;   aBcdef   ghijklmnop qrstuvwxyz  1
   &gt; 2 ==&gt; 2     333
   &gt; 3 ==&gt; 333 a B cc
   &gt;  SIZE:           3
   &gt; --------------------------------------------------------------------------
   &gt;  custom list of delimiters, reverse array order and return null fields:
   &gt; 1 ==&gt; 333 a B cc
   &gt; 2 ==&gt; 2     333
   &gt; 3 ==&gt;
   &gt; 4 ==&gt;
   &gt; 5 ==&gt;   aBcdef   ghijklmnop qrstuvwxyz  1
   &gt;  SIZE:           5
   &gt; --------------------------------------------------------------------------
   &gt;  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
   &gt;  default delimiters and reverse array order and count null fields:
   &gt; 1 ==&gt;
   &gt; 2 ==&gt;
   &gt; 3 ==&gt;
   &gt; 4 ==&gt; cc
   &gt; 5 ==&gt; B
   &gt; 6 ==&gt; a
   &gt; 7 ==&gt; 333|333
   &gt; 8 ==&gt;
   &gt; 9 ==&gt;
   &gt; 10 ==&gt;
   &gt; 11 ==&gt;
   &gt; 12 ==&gt; 1:|:2
   &gt; 13 ==&gt;
   &gt; 14 ==&gt; qrstuvwxyz
   &gt; 15 ==&gt; ghijklmnop
   &gt; 16 ==&gt;
   &gt; 17 ==&gt;
   &gt; 18 ==&gt; aBcdef
   &gt; 19 ==&gt;
   &gt; 20 ==&gt;
   &gt;  SIZE:          20
</pre>
          </blockquote>
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c148"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>stretch(3f)</b> - [M_strings:LENGTH] return string padded to at least specified length <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>stretch</b>(str,length,pattern,suffix) <b>result</b>(<i>strout</i>)
<br />
    character(len=*),intent(in)         :: str
    integer,intent(in)                  :: length
    character(len=*)intent(in),optional :: pattern
    character(len=*)intent(in),optional :: suffix
    character(len=:),allocatable        :: strout
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>stretch</b>(3f) pads a string with spaces to at least the specified length. If the trimmed input string is longer than the requested length the
          original string is returned trimmed of trailing spaces.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c149" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom">the input string to return trimmed, but then padded to the specified length if shorter than length</td>
            </tr>
            <tr valign="top">
              <td class="c149" width="6%" nowrap="nowrap">length</td>
              <td valign="bottom">The minimum string length to return</td>
            </tr>
            <tr valign="top">
              <td class="c149" colspan="1">pattern</td>
              <td>optional string to use as padding. Defaults to a space.</td>
            </tr>
            <tr valign="top">
              <td class="c149" width="6%" nowrap="nowrap">suffix</td>
              <td valign="bottom">optional string to append to output string</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c150" width="6%" nowrap="nowrap">strout</td>
              <td valign="bottom">The input string padded to the requested length or the trimmed input string if the input string is longer than the
              requested length.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_stretch
     use M_strings, only : stretch
     implicit none
     character(len=10)            :: string='abcdefghij'
     character(len=:),allocatable :: answer
     integer                      :: i
        answer=stretch(string,5)
        write(*,'("[",a,"]")') answer
        answer=stretch(string,20)
        write(*,'("[",a,"]")') answer
        i=30
        write(*,*)
        write(*,'(1x,a,i0)') stretch('CHAPTER 1 : The beginning ',i,'.'), 1
        write(*,'(1x,a,i0)') stretch('CHAPTER 2 : The end ',i,'.'),       1234
        write(*,'(1x,a,i0)') stretch('APPENDIX ',i,'.'),                  1235
        write(*,*)
        write(*,'(1x,a,i7)') stretch('CHAPTER 1 : The beginning ',i,'.'), 1
        write(*,'(1x,a,i7)') stretch('CHAPTER 2 : The end ',i,'.'),       1234
        write(*,'(1x,a,i7)') stretch('APPENDIX ',i,'.'),                  1235
        write(*,*)
        write(*,*) stretch('CHAPTER 1 : The beginning ',i,suffix=': '), 1
        write(*,*) stretch('CHAPTER 2 : The end ',i,suffix=': '),       1234
        write(*,*) stretch('APPENDIX ',i,suffix=': '),                  1235
    end program demo_stretch
<br />
</pre>
        </blockquote>Results:
        <pre>
   [abcdefghij]
   [abcdefghij          ]
<br />
    CHAPTER 1 : The beginning ....1
    CHAPTER 2 : The end ..........1234
    APPENDIX .....................1235
<br />
    CHAPTER 1 : The beginning ....      1
    CHAPTER 2 : The end ..........   1234
    APPENDIX .....................   1235
<br />
    CHAPTER 1 : The beginning     :            1
    CHAPTER 2 : The end           :         1234
    APPENDIX                      :         1235
<br />
</pre><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c152"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>string_to_value(3f)</b> - [M_strings:NUMERIC] subroutine returns numeric value from string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>string_to_value</b>(chars,valu,ierr)
<br />
    character(len=*),intent(in)              :: chars   ! input string
    integer|real|doubleprecision,intent(out) :: valu
    integer,intent(out)                      :: ierr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          returns a numeric value from a numeric character string.
          <p>works with any g-format input, including integer, real, and exponential. If the input string begins with "B", "Z", or "O" and otherwise
          represents a positive whole number it is assumed to be a binary, hexadecimal, or octal value. If the string contains commas they are removed. If
          the string is of the form NN:MMM... or NN#MMM then NN is assumed to be the base of the whole number.</p>
          <p>if an error occurs in the READ, IOSTAT is returned in IERR and value is set to zero. if no error occurs, IERR=0.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c153" width="6%" nowrap="nowrap">CHARS</td>
              <td valign="bottom">input string to read numeric value from</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c153" width="6%" nowrap="nowrap">VALU</td>
              <td valign="bottom">numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.</td>
            </tr>
            <tr valign="top">
              <td class="c153" width="6%" nowrap="nowrap">IERR</td>
              <td valign="bottom">error flag (0 == no error)</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_string_to_value
    use M_strings, only: string_to_value
    character(len=80) :: string
       string=' -40.5e-2 '
       call string_to_value(string,value,ierr)
       write(*,*) 'value of string ['//trim(string)//'] is ',value
   end program demo_string_to_value
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c156"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>string_to_values(3f)</b> - [M_strings:NUMERIC] read a string representing numbers into a numeric array <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>string_to_values</b>(line,iread,values,inums,delims,ierr)
<br />
       character(len=*) :: line
       integer          :: iread
       real             :: values(*)
       integer          :: inums
       character(len=*) :: delims
       integer          :: ierr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          This routine can take a string representing a series of numbers and convert it to a numeric array and return how many numbers were found.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">LINE</td>
              <td valign="bottom">Input string containing numbers</td>
            </tr>
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">IREAD</td>
              <td valign="bottom">maximum number of values to try to read from input string</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">VALUES</td>
              <td valign="bottom">real array to be filled with numbers</td>
            </tr>
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">INUMS</td>
              <td valign="bottom">number of values successfully read (before error occurs if one does)</td>
            </tr>
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">DELIMS</td>
              <td valign="bottom">delimiter <b>character</b>(s), usually a space. must not be a null string. If more than one character, a space must not be
              the last character or it will be ignored.</td>
            </tr>
            <tr valign="top">
              <td class="c157" width="6%" nowrap="nowrap">IERR</td>
              <td valign="bottom">error flag (0=no error, else column number string starts at that error occurred on).</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
     program demo_string_to_values
      use M_strings, only : string_to_values
      character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
      integer,parameter  :: isz=10
      real               :: array(isz)
<br />
      call string_to_values(s,10,array,inums,' ;',ierr)
      call reportit()
<br />
      call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
      call reportit()
<br />
      contains
         subroutine reportit()
            write(*,*)'string_to_values:'
            write(*,*)'input string.............',trim(s)
            write(*,*)'number of values found...',inums
            write(*,*)'values...................',(array(ii),ii=1,inums)
         end subroutine reportit
     end program demo_string_to_values
<br />
</pre>Expected output
          <pre>
    string_to_values:
    input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found...           6
    values...................   10.0000000  20000.0000  3.45000005  -4.00299978  1234.00000  5678.00000
    string_to_values:
    input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
    number of values found...           3
    values...................   10.0000000  2.29999995  3.14159989
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c160"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>strtok(3f)</b> - [M_strings:TOKENS] Tokenize a string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>strtok</b>(source_string,itoken,token_start,token_end,delimiters)
<b>result</b>(<i>strtok_status</i>)
</pre>
          <blockquote>
            <table cellpadding="3">
              <tr valign="top">
                <td class="c161" colspan="1">logical</td>
                <td>:: <i>strtok_status</i> ! returned value</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>character</b>(len=*),intent(<i>in</i>)</td>
                <td>:: source_string ! string to tokenize</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>integer,intent</b>(<i>inout</i>)</td>
                <td>:: itoken ! token count since started</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>integer,intent</b>(<i>out</i>)</td>
                <td>:: token_start ! beginning of token</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>integer,intent</b>(<i>inout</i>)</td>
                <td>:: token_end ! end of token</td>
              </tr>
              <tr valign="top">
                <td colspan="1"><b>character</b>(len=*),intent(<i>in</i>)</td>
                <td>:: delimiters ! list of separator characters</td>
              </tr>
            </table>
          </blockquote>
          <pre>
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          The <b>STRTOK</b>(3f) function is used to isolate sequential tokens <i>in</i> a string, SOURCE_STRING. These tokens are delimited <i>in</i> the
          string by at least one of the characters <i>in</i> DELIMITERS. The first time that <b>STRTOK</b>(3f) is called, ITOKEN should be specified as
          zero. Subsequent calls, wishing to obtain further tokens from the same string, should pass back <i>in</i> TOKEN_END and ITOKEN until the function
          result returns .false. This routine assumes no other calls are made to it using any other input string while it is processing an input line.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c161" colspan="1">source_string</td>
              <td>input string to parse</td>
            </tr>
            <tr valign="top">
              <td class="c161" width="6%" nowrap="nowrap">itoken</td>
              <td valign="bottom">token count should be set to zero for a new string</td>
            </tr>
            <tr valign="top">
              <td class="c161" colspan="1">delimiters</td>
              <td>characters used to determine the end of tokens</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURN</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c161" colspan="1">token_start</td>
              <td>beginning position <i>in</i> SOURCE_STRING where token was found</td>
            </tr>
            <tr valign="top">
              <td class="c161" colspan="1">token_end</td>
              <td>ending position <i>in</i> SOURCE_STRING where token was found <i>strtok_status</i></td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample program:
          <pre>
    !===============================================================================
    program demo_strtok
    use M_strings, only : strtok
    character(len=264)          :: inline
    character(len=*),parameter  :: delimiters=' ;,'
    integer                     :: ios
    !-------------------------------------------------------------------------------
       do                        ! read lines from stdin until end-of-file or error
          read (unit=*,fmt="(a)",iostat=ios) inline
          if(ios.ne.0)stop
          itoken=0 ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
          do while ( strtok(inline,itoken,istart,iend,delimiters) )
             print *, itoken,'TOKEN=['//(inline(istart:iend))//']',istart,iend
          enddo
       enddo
    end program demo_strtok
    !===============================================================================
<br />
    sample input file
<br />
     this is a test of strtok; A:B :;,C;;
<br />
</pre>
          <blockquote>
            sample output file
            <table cellpadding="3">
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">1</td>
                <td valign="bottom">TOKEN=[this] 2 5</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">2</td>
                <td valign="bottom">TOKEN=[is] 7 8</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">3</td>
                <td valign="bottom">TOKEN=[a] 10 10</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">4</td>
                <td valign="bottom">TOKEN=[test] 12 15</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">5</td>
                <td valign="bottom">TOKEN=[of] 17 18</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">6</td>
                <td valign="bottom">TOKEN=[strtok] 20 25</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">7</td>
                <td valign="bottom">TOKEN=[A:B] 28 30</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">8</td>
                <td valign="bottom">TOKEN=[:] 32 32</td>
              </tr>
              <tr valign="top">
                <td class="c161" width="6%" nowrap="nowrap">9</td>
                <td valign="bottom">TOKEN=[C] 35 35</td>
              </tr>
            </table>
          </blockquote>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c164"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>substitute(3f)</b> - [M_strings:EDITING] subroutine globally substitutes one substring for another in string <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>substitute</b>(targetline,old,new,ierr,start,end)
<br />
    character(len=*)              :: targetline
    character(len=*),intent(in)   :: old
    character(len=*),intent(in)   :: new
    integer,intent(out),optional  :: ierr
    integer,intent(in),optional   :: start
    integer,intent(in),optional   :: end
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Globally substitute one substring for another in string.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c165" colspan="1">TARGETLINE</td>
              <td>input line to be changed. Must be long enough to hold altered output.</td>
            </tr>
            <tr valign="top">
              <td class="c165" width="6%" nowrap="nowrap">OLD</td>
              <td valign="bottom">substring to find and replace</td>
            </tr>
            <tr valign="top">
              <td class="c165" width="6%" nowrap="nowrap">NEW</td>
              <td valign="bottom">replacement for OLD substring</td>
            </tr>
            <tr valign="top">
              <td class="c165" width="6%" nowrap="nowrap">IERR</td>
              <td valign="bottom">error code. If IER = <b>-1</b> bad directive, &gt;= 0 then count of changes made.</td>
            </tr>
            <tr valign="top">
              <td class="c165" width="6%" nowrap="nowrap">START</td>
              <td valign="bottom">sets the left margin to be scanned for OLD in TARGETLINE.</td>
            </tr>
            <tr valign="top">
              <td class="c165" width="6%" nowrap="nowrap">END</td>
              <td valign="bottom">sets the right margin to be scanned for OLD in TARGETLINE.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_substitute
   use M_strings, only : substitute
   implicit none
   ! must be long enough to hold changed line
   character(len=80) :: targetline
<br />
   targetline='this is the input string'
   write(*,*)'ORIGINAL    : '//trim(targetline)
<br />
   ! changes the input to 'THis is THe input string'
   call substitute(targetline,'th','TH')
   write(*,*)'th =&gt; TH    : '//trim(targetline)
<br />
   ! a null old substring means "at beginning of line"
   ! changes the input to 'BEFORE:this is the input string'
   call substitute(targetline,'','BEFORE:')
   write(*,*)'"" =&gt; BEFORE: '//trim(targetline)
<br />
   ! a null new string deletes occurrences of the old substring
   ! changes the input to 'ths s the nput strng'
   call substitute(targetline,'i','')
   write(*,*)'i =&gt; ""     : '//trim(targetline)
<br />
   end program demo_substitute
<br />
</pre>Expected output
          <pre>
    ORIGINAL    : this is the input string
    th =&gt; TH    : THis is THe input string
    "" =&gt; BEFORE: BEFORE:THis is THe input string
    i =&gt; ""     : BEFORE:THs s THe nput strng
</pre>
        </blockquote><a name="5" id="5"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c168"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>switch(3f)</b> - [M_strings:ARRAY] converts between CHARACTER scalar and array of single characters <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="6" id="6">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
<br />
<b>pure</b> <i>function</i> <b>switch</b>(array) <i>result</i> (<i>(string)</i>)
<br />
    character(len=1),intent(in) :: array(:)
    character(len=SIZE(array))  :: string
<br />
     or
<br />
</pre><b>pure</b> <i>function</i> <b>switch</b>(<i>(string)</i>) <i>result</i> (<i>(array)</i>)
          <pre>
    character(len=1),intent(in) :: array(:)
    character(len=SIZE(array))  :: string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>SWITCH</b>(3f): generic <i>function</i> that switches CHARACTER <i>(string)</i> to an <i>(array)</i> of single characters or an
          <i>(array)</i> of single characters to a CHARACTER <i>(string)</i>. Useful in passing strings to C. New Fortran features may supersede these
          routines.</p>
        </blockquote>
        <p><a name="3" id="3"></a></p>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          <p>Sample program:</p>
          <pre>
   program demo_switch
   use M_strings, only : switch, isalpha, islower, nospace
   character(len=*),parameter :: dashes='-----------------------------------'
   character(len=*),parameter :: string='This is a string of letters'
   character(len=1024)        :: line
<br />
   ! First, examples of standard Fortran features
   write(*,*)['A','=','=','=','=','='].eq.'='      ! returns array [F,T,T,T,T,T]
   write(*,*)all(['=','=','=','=','=','='].eq.'=') ! this would return T
   write(*,*)all(['A','=','=','=','=','='].eq.'=') ! this would return F
<br />
   ! so to test if the string DASHES is all dashes using SWITCH(3f) is
   if(all(switch(dashes).eq.'-'))then
      write(*,*)'DASHES is all dashes'
   endif
<br />
   ! so to test is a string is all letters
   ! isalpha(3f) returns .true. only if character is a letter
   write(*,*) all(isalpha(switch(dashes)))  ! false because dashes are not a letter
   write(*,*) all(isalpha(switch(string)))  ! false because of spaces
   write(*,*) all(isalpha(switch(nospace(string))))  ! true because removed whitespace
<br />
   ! to see if a string is all uppercase
   write(*,*) string                           ! show the string
   write(*,'(1x,*("[",a,"]":))') switch(string)   ! converted to character array
   write(*,'(*(l3))') islower(switch(string))
<br />
   line=nospace(string)                        ! we need a string that is all letters
   write(*,*)'LINE=',trim(line)
   write(*,*) islower(switch(nospace(string))) ! all true except first character
   write(*,*) all(islower(switch(nospace(string))))      ! should be false
   write(*,*) all(islower(switch(nospace(string(2:)))))  ! should be true
<br />
   end program demo_switch
<br />
</pre>Expected output
          <pre>
   &gt;  F T T T T T
   &gt;  T
   &gt;  F
   &gt;  DASHES is all dashes
   &gt;  F
   &gt;  F
   &gt;  T
   &gt;  This is a string of letters
   &gt;  [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g][ ][o][f][ ][l][e][t][t][e][r][s]
   &gt;   F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T  F  T  T  F  T  T  T  T  T  T  T
   &gt;  LINE=Thisisastringofletters
   &gt;  F T T T T T T T T T T T T T T T T T T T T T
   &gt;  F
   &gt;  T
</pre>
        </blockquote><a name="4" id="4"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c171"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>transliterate(3f)</b> - [M_strings:EDITING] replace characters from old set with new set <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
pure function <b>transliterate</b>(instr,old_set,new_set) <b>result</b>(<i>outstr</i>)
<br />
    character(len=*),intent(in)  :: instr
    character(len=*),intent(in)  :: old_set
    character(len=*),intent(in)  :: new_set
    character(len=len(instr))    :: outstr
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Translate, squeeze, and/or delete characters from the input string.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c172" width="6%" nowrap="nowrap">instr</td>
              <td valign="bottom">input string to change</td>
            </tr>
            <tr valign="top">
              <td class="c172" colspan="1">old_set</td>
              <td>
                list of letters to change in INSTR if found
                <p>Each character in the input string that matches a character in the old set is replaced.</p>
              </td>
            </tr>
            <tr valign="top">
              <td class="c172" colspan="1">new_set</td>
              <td>list of letters to replace letters in OLD_SET with. If the new_set is the empty set the matched characters are deleted.<br />
              If the new_set is shorter than the old set the last character in the new set is used to replace the remaining characters in the new set.</td>
            </tr>
          </table><!-- .nf -->
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c173" width="6%" nowrap="nowrap">outstr</td>
              <td valign="bottom">instr with substitutions applied</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_transliterate

    use M_strings, only : transliterate
    implicit none
    character(len=80)   :: STRING

    STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
    write(*,'(a)') STRING

    ! convert a string to uppercase:
    write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')

    ! change all miniscule letters to a colon (":"):
    write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz',':')

    ! delete all miniscule letters
    write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','')

    end program demo_transliterate
</pre>
          <blockquote>
            <p>Expected output</p>
            <pre>
    &gt; aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
    &gt; AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
    &gt; :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
    &gt; ABCDEFGHIJKLMNOPQRSTUVWXYZ
<br />
</pre>
          </blockquote>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c175"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>unquote(3f)</b> - [M_strings:QUOTES] remove quotes from string as if read with list-directed input <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>unquote</b>(quoted_str,esc) result (<i>unquoted_str</i>)
<br />
   character(len=*),intent(in)          :: quoted_str
   character(len=1),optional,intent(in) :: esc
   character(len=:),allocatable         :: unquoted_str
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          Remove quotes from a CHARACTER variable as if it was read using list-directed input. This is particularly useful for processing tokens read from
          input such as CSV files.
          <p>Fortran can now read using list-directed input from an internal file, which should handle quoted strings, but list-directed input does not
          support escape characters, which <b>UNQUOTE</b>(3f) does.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c176" colspan="1">quoted_str</td>
              <td>input string to remove quotes from, using the rules of list-directed input (two adjacent quotes inside a quoted region are replaced by a
              single quote, a single quote or double quote is selected as the delimiter based on which is encountered first going from left to right,
              ...)</td>
            </tr>
            <tr valign="top">
              <td class="c176" width="6%" nowrap="nowrap">esc</td>
              <td valign="bottom">optional character used to protect the next quote character from being processed as a quote, but simply as a plain
              character.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULT</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c177" colspan="1">unquoted_str</td>
              <td>The output string, which is based on removing quotes from quoted_str.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
   program demo_unquote
      use M_strings, only : unquote
      implicit none
      character(len=128)           :: quoted_str
      character(len=:),allocatable :: unquoted_str
      character(len=1),parameter   :: esc='#146;
      character(len=1024)          :: msg
      integer                      :: ios
      character(len=1024)          :: dummy
      do
         write(*,'(a)',advance='no')'Enter test string:'
         read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
         if(ios.ne.0)then
            write(*,*)trim(msg)
            exit
         endif
<br />
         ! the original string
         write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
<br />
         ! the string processed by unquote(3f)
         unquoted_str=unquote(trim(quoted_str),esc)
         write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
<br />
         ! read the string list-directed to compare the results
         read(quoted_str,*,iostat=ios,iomsg=msg)dummy
         if(ios.ne.0)then
            write(*,*)trim(msg)
         else
            write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
         endif
      enddo
   end program demo_unquote
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c179"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>upper(3f)</b> - [M_strings:CASE] changes a string to uppercase <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="9" id="9">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
elemental pure function <b>upper</b>(str,begin,end) result (<i>string</i>)
<br />
    character(*), intent(in)    :: str
    integer,optional,intent(in) :: begin,end
    character(len(str))         :: string  ! output string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>upper</b>(<i>string</i>) returns a copy of the input <i>string</i> with all characters converted in the optionally specified range to
          uppercase, assuming ASCII character sets are being used. If no range is specified the entire <i>string</i> is converted to uppercase.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c180" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom"><i>string</i> to convert to uppercase</td>
            </tr>
            <tr valign="top">
              <td class="c180" width="6%" nowrap="nowrap">begin</td>
              <td valign="bottom">optional starting position in "str" to begin converting to uppercase</td>
            </tr>
            <tr valign="top">
              <td class="c180" width="6%" nowrap="nowrap">end</td>
              <td valign="bottom">optional ending position in "str" to stop converting to uppercase</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c180" width="6%" nowrap="nowrap">upper</td>
              <td valign="bottom">copy of the input <i>string</i> with all characters converted to uppercase over optionally specified range.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">TRIVIA</a></h3>
        <blockquote>
          The terms "uppercase" and "lowercase" date back to the early days of the mechanical printing press. Individual metal alloy casts of each needed
          letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were
          stored and organized in wooden cases. The more often needed miniscule letters were placed closer to hand, in the lower cases of the work bench.
          The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.
        </blockquote><a name="6" id="6"></a>
        <h3><a name="6" id="6">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
    program demo_upper
    use M_strings, only: upper
    implicit none
    character(len=:),allocatable  :: s
       s=' ABCDEFG abcdefg '
       write(*,*) 'mixed-case input string is ....',s
       write(*,*) 'upper-case output string is ...',upper(s)
       write(*,*) 'make first character uppercase  ... ',upper('this is a sentence.',1,1)
       write(*,'(1x,a,*(a:,"+"))') 'UPPER(3f) is elemental ==&gt;',upper(["abc","def","ghi"])
    end program demo_upper
<br />
</pre>Expected output
          <pre>
    mixed-case input string is .... ABCDEFG abcdefg
    upper-case output string is ... ABCDEFG ABCDEFG
    make first character uppercase  ... This is a sentence.
    UPPER(3f) is elemental ==&gt;ABC+DEF+GHI
</pre>
        </blockquote><a name="7" id="7"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c183"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>upper_quoted(3f)</b> - [M_strings:CASE] elemental function converts string to miniscule skipping strings quoted per Fortran syntax rules
          <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
elemental pure function <b>upper_quoted</b>(<i>str</i>) result (<i>string</i>)
<br />
    character(*), intent(in)    :: str
    character(len(str))         :: string  ! output string
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <b>upper_quoted</b>(<i>string</i>) returns a copy of the input <i>string</i> with all not-quoted characters converted to uppercase, assuming ASCII
          character sets are being used. The quoting rules are the same as for Fortran source. Either a single or double quote starts a quoted
          <i>string</i>, and a quote character of the same type is doubled when it appears internally in the quoted <i>string</i>. If a double quote quotes
          the <i>string</i> single quotes may appear in the quoted <i>string</i> as single characters, and vice-versa for single quotes.
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c184" width="6%" nowrap="nowrap">str</td>
              <td valign="bottom"><i>string</i> to convert to uppercase</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RESULTS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c185" width="6%" nowrap="nowrap">upper</td>
              <td valign="bottom">copy of the input <i>string</i> with all unquoted characters converted to uppercase</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
    program demo_upper_quoted
    use M_strings, only: upper_quoted
    implicit none
    character(len=:),allocatable  :: s
    s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with "" Quote" everything else'
       write(*,*) 'mixed-case input string is ....',s
       write(*,*) 'upper-case output string is ...',upper_quoted(s)
       write(*,*) 'make first character uppercase  ... ',upper_quoted('this is a sentence.')
       write(*,'(1x,a,*(a:,"+"))') 'upper_quoted(3f) is elemental ==&gt;',upper_quoted(["abc","def","ghi"])
    end program demo_upper_quoted
<br />
</pre>Expected output:
          <pre>
    mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted" 'Single-Quoted' "with "" Quote" everything else
    upper-case output string is ... ABCDEFG ABCDEFG "Double-Quoted" 'Single-Quoted' "with "" Quote" EVERYTHING ELSE
    make first character uppercase  ... THIS IS A SENTENCE.
    upper_quoted(3f) is elemental ==&gt;ABC+DEF+GHI
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c187"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>v2s(3f)</b> - [M_strings:NUMERIC] return numeric string from a numeric value <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>v2s</b>(<i>value</i>) <b>result</b>(<i>outstr</i>)
<br />
       integer|real|doubleprecision|logical,intent(in ) :: value
       character(len=:),allocatable :: outstr
       character(len=*),optional,intent(in) :: fmt
<br />
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>v2s</b>(3f) returns a representation of a numeric <i>value</i> as a string when given a numeric <i>value</i> of type REAL, DOUBLEPRECISION,
          INTEGER or LOGICAL. It creates the strings using internal <b>WRITE</b>() statements. Trailing zeros are removed from non-zero values, and the
          string is left-justified.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c188" width="6%" nowrap="nowrap">VALUE</td>
              <td valign="bottom">input <i>value</i> to be converted to a string</td>
            </tr>
            <tr valign="top">
              <td class="c188" width="6%" nowrap="nowrap">FMT</td>
              <td valign="bottom">format can be explicitly given, but is limited to generating a string of eighty or less characters.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c188" width="6%" nowrap="nowrap">OUTSTR</td>
              <td valign="bottom">returned string representing input <i>value</i>,</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample Program:
          <pre>
   program demo_v2s
   use M_strings, only: v2s
   write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
   write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
   write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
   write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
   write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
   end program demo_v2s
<br />
</pre>Expected output
          <pre>
    The value of 3.0/4.0 is [0.75]
    The value of 1234    is [1234]
    The value of 0d0     is [0]
    The value of .false. is [F]
    The value of .true. is  [T]
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c191"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>value_to_string(3f)</b> - [M_strings:NUMERIC] return numeric string from a numeric value <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="8" id="8">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
subroutine <b>value_to_string</b>(value,chars[,ilen,ierr,fmt,trimz])
<br />
    character(len=*) :: chars  ! minimum of 23 characters required
    !--------
    ! VALUE may be any &lt;em&gt;one&lt;/em&gt; of the following types:
    doubleprecision,intent(in)               :: value
    real,intent(in)                          :: value
    integer,intent(in)                       :: value
    logical,intent(in)                       :: value
    !--------
    character(len=*),intent(out)             :: chars
    integer,intent(out),optional             :: ilen
    integer,optional                         :: ierr
    character(len=*),intent(in),optional     :: fmt
    logical,intent(in)                       :: trimz
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>value_to_string</b>(3f) returns a numeric representation of a numeric value in a string given a numeric value of type REAL, DOUBLEPRECISION,
          INTEGER or LOGICAL. It creates the string using internal writes. It then removes trailing zeros from non-zero values, and left-justifies the
          string.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">OPTIONS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">VALUE</td>
              <td valign="bottom">input value to be converted to a string</td>
            </tr>
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">FMT</td>
              <td valign="bottom">You may specify a specific format that produces a string up to the length of CHARS; optional.</td>
            </tr>
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">TRIMZ</td>
              <td valign="bottom">If a format is supplied the default is not to try to trim trailing zeros. Set TRIMZ to .true. to trim zeros from a string
              assumed to represent a simple numeric value.</td>
            </tr>
          </table>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">RETURNS</a></h3>
        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">CHARS</td>
              <td valign="bottom">returned string representing input value, must be at least 23 characters long; or what is required by optional FMT if
              longer.</td>
            </tr>
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">ILEN</td>
              <td valign="bottom">position of last non-blank character in returned string; optional.</td>
            </tr>
            <tr valign="top">
              <td class="c192" width="6%" nowrap="nowrap">IERR</td>
              <td valign="bottom">If not zero, error occurred; optional.</td>
            </tr>
          </table>
        </blockquote><a name="5" id="5"></a>
        <h3><a name="5" id="5">EXAMPLE</a></h3>
        <blockquote>
          Sample program:
          <pre>
     program demo_value_to_string
     use M_strings, only: value_to_string
     implicit none
     character(len=80) :: string
     integer           :: ilen
        call value_to_string(3.0/4.0,string,ilen)
        write(*,*) 'The value is [',string(:ilen),']'
<br />
        call value_to_string(3.0/4.0,string,ilen,fmt='')
        write(*,*) 'The value is [',string(:ilen),']'
<br />
        call value_to_string(3.0/4.0,string,ilen,fmt='("THE VALUE IS ",g0)')
        write(*,*) 'The value is [',string(:ilen),']'
<br />
        call value_to_string(1234,string,ilen)
        write(*,*) 'The value is [',string(:ilen),']'
<br />
        call value_to_string(1.0d0/3.0d0,string,ilen)
        write(*,*) 'The value is [',string(:ilen),']'
<br />
     end program demo_value_to_string
<br />
</pre>Expected output
          <pre>
    The value is [0.75]
    The value is [      0.7500000000]
    The value is [THE VALUE IS .750000000]
    The value is [1234]
    The value is [0.33333333333333331]
<br />
</pre>
        </blockquote><a name="6" id="6"></a>
      </div>
    </div><?
                    <div?>
    <p class="c1"><a name="top" id="top"></a></p>
    <div id="Container">
      <div id="Content">
        <div class="c195"></div><a name="0" id="0"></a>
        <h3><a name="0" id="0">NAME</a></h3>
        <blockquote>
          <b>visible(3f)</b> - [M_strings:NONALPHA] expand a string to control and meta-control representations <b>(LICENSE:PD)</b>
        </blockquote><a name="contents" id="contents"></a>
        <h3><a name="7" id="7">SYNOPSIS</a></h3>
        <blockquote>
          <pre>
function <b>visible</b>(<i>input</i>) <b>result</b>(<i>output</i>)
<br />
    character(len=*),intent(in)           :: input
    character(len=:),allocatable          :: output
</pre>
        </blockquote><a name="2" id="2"></a>
        <h3><a name="2" id="2">DESCRIPTION</a></h3>
        <blockquote>
          <p><b>visible</b>(3f) expands characters to commonly used sequences used to represent the characters as control sequences or meta-control
          sequences.</p>
        </blockquote><a name="3" id="3"></a>
        <h3><a name="3" id="3">EXAMPLES</a></h3>
        <blockquote>
          Sample Program:
          <pre>
    program demo_visible
    use M_strings, only : visible
    integer :: i
       do i=0,255
          write(*,'(i0,1x,a)')i,visible(char(i))
       enddo
    end program demo_visible
</pre>
        </blockquote><a name="4" id="4"></a>
        <h3><a name="4" id="4">BUGS</a></h3>
        <blockquote>
          The expansion is not reversible, as <i>input</i> sequences such as "M-" or "^a" will look like expanded sequences.
        </blockquote><a name="5" id="5"></a>
      </div>
    </div>
  </article>
</body>
</html>
