<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M_strings: m_strings::matchw Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M_strings
   </div>
   <div id="projectbrief">M_strings module (Fortran)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacem__strings.html">m_strings</a></li><li class="navelem"><a class="el" href="interfacem__strings_1_1matchw.html">matchw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="interfacem__strings_1_1matchw-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">m_strings::matchw Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a14005bfeffb9a2b7aa87edc89953b424"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__strings_1_1matchw.html#a14005bfeffb9a2b7aa87edc89953b424">glob</a> (tame, wild)</td></tr>
<tr class="separator:a14005bfeffb9a2b7aa87edc89953b424"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function/Subroutine Documentation</h2>
<a id="a14005bfeffb9a2b7aa87edc89953b424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14005bfeffb9a2b7aa87edc89953b424">&#9670;&nbsp;</a></span>glob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">logical function m_strings::matchw::glob </td>
          <td>(</td>
          <td class="paramtype">character(len=*)&#160;</td>
          <td class="paramname"><em>tame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*)&#160;</td>
          <td class="paramname"><em>wild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md7"></a>
NAME</h2>
<p>glob(3f) - [M_strings:COMPARE] compare given string for match to a pattern which may contain globbing wildcard characters (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md8"></a>
SYNOPSIS</h2>
<pre class="fragment">logical function glob(string, pattern )

 character(len=*),intent(in) :: string
 character(len=*),intent(in) :: pattern
</pre><h2><a class="anchor" id="autotoc_md9"></a>
DESCRIPTION</h2>
<p>glob(3f) compares given STRING for match to PATTERN which may contain basic wildcard "globbing" characters.</p>
<p>In this version to get a match the entire string must be described by PATTERN. Trailing whitespace is significant, so trim the input string to have trailing whitespace ignored.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
OPTIONS</h2>
<p>string the input string to test to see if it contains the pattern. pattern the following simple globbing options are available </p><pre class="fragment">     o "?" matching any one character
     o "*" matching zero or more characters.
       Do NOT use adjacent asterisks.
     o Both strings may have trailing spaces which
       are ignored.
     o There is no escape character, so matching strings with
       literal question mark and asterisk is problematic.
</pre><h2><a class="anchor" id="autotoc_md11"></a>
EXAMPLES</h2>
<p>Example program</p>
<p>program demo_glob implicit none ! This main() routine passes a bunch of test strings ! into the above code. In performance comparison mode, ! it does that over and over. Otherwise, it does it just ! once. Either way, it outputs a passed/failed result. ! integer :: nReps logical :: allpassed integer :: i allpassed = .true.</p>
<p>nReps = 10000 ! Can choose as many repetitions as you're expecting ! in the real world. nReps = 1</p>
<p>do i=1,nReps ! Cases with repeating character sequences. allpassed=allpassed .and. test("a*abab", "a*b", .true.) allpassed=allpassed .and. test("ab", "*?", .true.) allpassed=allpassed .and. test("abc", "*?", .true.) allpassed=allpassed .and. test("abcccd", "*ccd", .true.) allpassed=allpassed .and. test("bLah", "bLaH", .false.) allpassed=allpassed .and. test("mississippi", "*sip*", .true.) allpassed=allpassed .and. &amp; &amp; test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) allpassed=allpassed .and. &amp; &amp; test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) allpassed=allpassed .and. &amp; &amp; test("mississipissippi", "*issip*ss*", .true.) allpassed=allpassed .and. &amp; &amp; test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) allpassed=allpassed .and. &amp; &amp; test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) allpassed=allpassed .and. test("xyxyxyzyxyz", "xy*z*xyz", .true.) allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.) allpassed=allpassed .and. test("mississippi", "mi*sip*", .true.) allpassed=allpassed .and. test("ababac", "*abac*", .true.) allpassed=allpassed .and. test("aaazz", "a*zz*", .true.) allpassed=allpassed .and. test("a12b12", "*12*23", .false.) allpassed=allpassed .and. test("a12b12", "a12b", .false.) allpassed=allpassed .and. test("a12b12", "*12*12*", .true.)</p>
<p>! Additional cases where the '*' char appears in the tame string. allpassed=allpassed .and. test("*", "*", .true.) allpassed=allpassed .and. test("a*r", "a*", .true.) allpassed=allpassed .and. test("a*ar", "a*aar", .false.)</p>
<p>! More double wildcard scenarios. allpassed=allpassed .and. test("XYXYXYZYXYz", "XY*Z*XYz", .true.) allpassed=allpassed .and. test("missisSIPpi", "*SIP*", .true.) allpassed=allpassed .and. test("mississipPI", "*issip*PI", .true.) allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.) allpassed=allpassed .and. test("miSsissippi", "mi*sip*", .true.) allpassed=allpassed .and. test("miSsissippi", "mi*Sip*", .false.) allpassed=allpassed .and. test("abAbac", "*Abac*", .true.) allpassed=allpassed .and. test("aAazz", "a*zz*", .true.) allpassed=allpassed .and. test("A12b12", "*12*23", .false.) allpassed=allpassed .and. test("a12B12", "*12*12*", .true.) allpassed=allpassed .and. test("oWn", "*oWn*", .true.)</p>
<p>! Completely tame (no wildcards) cases. allpassed=allpassed .and. test("bLah", "bLah", .true.)</p>
<p>! Simple mixed wildcard tests suggested by IBMer Marlin Deckert. allpassed=allpassed .and. test("a", "*?", .true.)</p>
<p>! More mixed wildcard tests including coverage for false positives. allpassed=allpassed .and. test("a", "??", .false.) allpassed=allpassed .and. test("ab", "?*?", .true.) allpassed=allpassed .and. test("ab", "*?*?*", .true.) allpassed=allpassed .and. test("abc", "?**?*?", .true.) allpassed=allpassed .and. test("abc", "?**?*&amp;?", .false.) allpassed=allpassed .and. test("abcd", "?b*??", .true.) allpassed=allpassed .and. test("abcd", "?a*??", .false.) allpassed=allpassed .and. test("abcd", "?**?c?", .true.) allpassed=allpassed .and. test("abcd", "?**?d?", .false.) allpassed=allpassed .and. test("abcde", "?*b*?*d*?", .true.)</p>
<p>! Single-character-match cases. allpassed=allpassed .and. test("bLah", "bL?h", .true.) allpassed=allpassed .and. test("bLaaa", "bLa?", .false.) allpassed=allpassed .and. test("bLah", "bLa?", .true.) allpassed=allpassed .and. test("bLaH", "?Lah", .false.) allpassed=allpassed .and. test("bLaH", "?LaH", .true.)</p>
<p>! Many-wildcard scenarios. allpassed=allpassed .and. test(&amp; &amp;"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;
      &amp;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&amp; &amp;"a*a*a*a*a*a*aa*aaa*a*a*b",&amp; &amp;.true.) allpassed=allpassed .and. test(&amp; &amp;"abababababababababababababababababababaacacacacacacac&amp;
      &amp;adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp; &amp;"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&amp; &amp;.true.) allpassed=allpassed .and. test(&amp; &amp;"abababababababababababababababababababaacacacacacaca&amp;
      &amp;cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp; &amp;"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&amp; &amp;.false.) allpassed=allpassed .and. test(&amp; &amp;"abababababababababababababababababababaacacacacacacacad&amp;
      &amp;aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp; &amp;"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&amp; &amp;.false.) allpassed=allpassed .and. test(&amp; &amp;"abababababababababababababababababababaacacacacacacacad&amp;
      &amp;aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&amp; &amp;"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&amp; &amp;.true.) allpassed=allpassed .and. test("aaabbaabbaab", "*aabbaa*a*", .true.) allpassed=allpassed .and. &amp; test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",&amp; &amp;"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) allpassed=allpassed .and. test("aaaaaaaaaaaaaaaaa",&amp; &amp;"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) allpassed=allpassed .and. test("aaaaaaaaaaaaaaaa",&amp; &amp;"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) allpassed=allpassed .and. test(&amp; &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&amp;
      &amp;*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp; &amp; "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&amp;
      &amp;*abc*abc*abc*",&amp; &amp;.false.) allpassed=allpassed .and. test(&amp; &amp;"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&amp;
      &amp;*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&amp; &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&amp; &amp;.true.) allpassed=allpassed .and. test("abc*abcd*abcd*abc*abcd",&amp; &amp;"abc*abc*abc*abc*abc", .false.) allpassed=allpassed .and. test( "abc*abcd*abcd*abc*abcd*abcd&amp;
      &amp;*abc*abcd*abc*abc*abcd", &amp; &amp;"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&amp; &amp;.true.) allpassed=allpassed .and. test("abc",&amp; &amp;"********a********b********c********", .true.) allpassed=allpassed .and.&amp; &amp;test("********a********b********c********", "abc", .false.) allpassed=allpassed .and. &amp; &amp;test("abc", "********a********b********b********", .false.) allpassed=allpassed .and. test("*abc*", "***a*b*c***", .true.)</p>
<p>! A case-insensitive algorithm test. ! allpassed=allpassed .and. test("mississippi", "*issip*PI", .true.) enddo</p>
<p>if (allpassed)then write(*,'(a)')"Passed",nReps else write(*,'(a)')"Failed" endif contains ! This is a test program for wildcard matching routines. ! It can be used either to test a single routine for correctness, ! or to compare the timings of two (or more) different wildcard ! matching routines. ! function test(tame, wild, bExpectedResult) result(bPassed) use M_strings, only : glob character(len=*) :: tame character(len=*) :: wild logical :: bExpectedResult logical :: bResult logical :: bPassed bResult = .true. ! We'll do "&amp;=" cumulative checking. bPassed = .false. ! Assume the worst. write(*,*)repeat('=',79) bResult = glob(tame, wild) ! Call a wildcard matching routine.</p>
<p>! To assist correctness checking, output the two strings in any ! failing scenarios. if (bExpectedResult .eqv. bResult) then bPassed = .true. if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild else if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild endif</p>
<p>end function test end program demo_glob</p>
<p>Expected output</p>
<h2><a class="anchor" id="autotoc_md12"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md13"></a>
REFERENCE</h2>
<p>The article "Matching Wildcards: An Empirical Way to Tame an Algorithm" in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014</p>
<h2><a class="anchor" id="autotoc_md14"></a>
LICENSE</h2>
<p>Public Domain </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>/home/urbanjs/venus/V600/github/M_strings/src/<a class="el" href="M__strings_8f90.html">M_strings.f90</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
