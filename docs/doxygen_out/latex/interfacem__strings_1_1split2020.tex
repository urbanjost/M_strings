\hypertarget{interfacem__strings_1_1split2020}{}\doxysection{m\+\_\+strings\+::split2020 Interface Reference}
\label{interfacem__strings_1_1split2020}\index{m\_strings::split2020@{m\_strings::split2020}}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
pure subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020_a1a6ef5e7d97a4efe5c30808ab5c9c1e0}{split\+\_\+tokens}} (string, set, tokens, separator)
\item 
pure subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020_ab8f3cd31609a4f13998611330c0e2cef}{split\+\_\+first\+\_\+last}} (string, set, first, last)
\item 
pure subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020_a0979d001afee53255807f8bf0cd7cdfc}{split\+\_\+pos}} (string, set, pos, back)
\end{DoxyCompactItemize}


\doxysubsection{Member Function/\+Subroutine Documentation}
\mbox{\Hypertarget{interfacem__strings_1_1split2020_ab8f3cd31609a4f13998611330c0e2cef}\label{interfacem__strings_1_1split2020_ab8f3cd31609a4f13998611330c0e2cef}} 
\index{m\_strings::split2020@{m\_strings::split2020}!split\_first\_last@{split\_first\_last}}
\index{split\_first\_last@{split\_first\_last}!m\_strings::split2020@{m\_strings::split2020}}
\doxysubsubsection{\texorpdfstring{split\_first\_last()}{split\_first\_last()}}
{\footnotesize\ttfamily pure subroutine m\+\_\+strings\+::split2020\+::split\+\_\+first\+\_\+last (\begin{DoxyParamCaption}\item[{character($\ast$), intent(in)}]{string,  }\item[{character($\ast$), intent(in)}]{set,  }\item[{integer, dimension(\+:), intent(out), allocatable}]{first,  }\item[{integer, dimension(\+:), intent(out), allocatable}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{interfacem__strings_1_1split2020_a0979d001afee53255807f8bf0cd7cdfc}\label{interfacem__strings_1_1split2020_a0979d001afee53255807f8bf0cd7cdfc}} 
\index{m\_strings::split2020@{m\_strings::split2020}!split\_pos@{split\_pos}}
\index{split\_pos@{split\_pos}!m\_strings::split2020@{m\_strings::split2020}}
\doxysubsubsection{\texorpdfstring{split\_pos()}{split\_pos()}}
{\footnotesize\ttfamily pure subroutine m\+\_\+strings\+::split2020\+::split\+\_\+pos (\begin{DoxyParamCaption}\item[{character($\ast$), intent(in)}]{string,  }\item[{character($\ast$), intent(in)}]{set,  }\item[{integer, intent(inout)}]{pos,  }\item[{logical, intent(in), optional}]{back }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{interfacem__strings_1_1split2020_a1a6ef5e7d97a4efe5c30808ab5c9c1e0}\label{interfacem__strings_1_1split2020_a1a6ef5e7d97a4efe5c30808ab5c9c1e0}} 
\index{m\_strings::split2020@{m\_strings::split2020}!split\_tokens@{split\_tokens}}
\index{split\_tokens@{split\_tokens}!m\_strings::split2020@{m\_strings::split2020}}
\doxysubsubsection{\texorpdfstring{split\_tokens()}{split\_tokens()}}
{\footnotesize\ttfamily pure subroutine m\+\_\+strings\+::split2020\+::split\+\_\+tokens (\begin{DoxyParamCaption}\item[{character($\ast$), intent(in)}]{string,  }\item[{character($\ast$), intent(in)}]{set,  }\item[{character(\+:), dimension(\+:), intent(out), allocatable}]{tokens,  }\item[{character, dimension(\+:), intent(out), optional, allocatable}]{separator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\hypertarget{namespacem__strings_autotoc_md537}{}\doxysubsubsection{N\+A\+ME}\label{namespacem__strings_autotoc_md537}
split2020(3f) -\/ parse a string into tokens\hypertarget{namespacem__strings_autotoc_md538}{}\doxysubsubsection{S\+Y\+N\+O\+P\+S\+IS}\label{namespacem__strings_autotoc_md538}
T\+O\+K\+EN form

subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} (string, set, tokens, separator) character(len=$\ast$),intent(in) \+:: string character(len=$\ast$),intent(in) \+:: set character(len=\+:),allocatable,intent(out) \+:: tokens(\+:) character(len=1),allocatable,intent(out),optional \+:: separator(\+:)

B\+O\+U\+N\+DS A\+R\+R\+AY form

subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} (string, set, first, last) character(len=$\ast$),intent(in) \+:: string character(len=$\ast$),intent(in) \+:: set integer,allocatable,intent(out) \+:: first(\+:) integer,allocatable,intent(out) \+:: last(\+:)

S\+T\+EP T\+H\+R\+O\+U\+GH BY P\+O\+S\+I\+T\+I\+ON form

subroutine \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} (string, set, pos \mbox{[}, back\mbox{]}) character(len=$\ast$),intent(in) \+:: string character(len=$\ast$),intent(in) \+:: set integer,intent(inout) \+:: pos logical,intent(in),optional \+:: back\hypertarget{namespacem__strings_autotoc_md539}{}\doxysubsubsection{D\+E\+S\+C\+R\+I\+P\+T\+I\+ON}\label{namespacem__strings_autotoc_md539}
Parse a string into tokens. S\+T\+R\+I\+NG, S\+ET, T\+O\+K\+E\+NS and S\+E\+P\+A\+R\+A\+T\+OR must all be of the same C\+H\+A\+R\+A\+C\+T\+ER kind type parameter.\hypertarget{namespacem__strings_autotoc_md540}{}\doxysubsubsection{O\+P\+T\+I\+O\+NS}\label{namespacem__strings_autotoc_md540}
S\+T\+R\+I\+NG string to break into tokens

S\+ET Each character in S\+ET is a token delimiter. A sequence of zero or more characters in S\+T\+R\+I\+NG delimited by any token delimiter, or the beginning or end of S\+T\+R\+I\+NG, comprise a token. Thus, two consecutive token delimiters in S\+T\+R\+I\+NG, or a token delimiter in the first or last character of S\+T\+R\+I\+NG, indicate a token with zero length.

??? how about if null defaults to all whitespace characters

T\+O\+K\+E\+NS It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in S\+T\+R\+I\+NG, and with character length equal to the length of the longest token. The tokens in S\+T\+R\+I\+NG are assigned by intrinsic assignment, in the order found, to the elements of T\+O\+K\+E\+NS, in array element order.

???If input is null it still must be of size 1?

S\+E\+P\+A\+R\+A\+T\+OR Each element in S\+E\+P\+A\+R\+A\+T\+O\+R(i) is assigned the value of the ith token delimiter in S\+T\+R\+I\+NG. It is allocated with the lower bound equal to one and the upper bound equal to one less than the number of tokens in S\+T\+R\+I\+NG, and with character length equal to one.

???one less than? \textquotesingle{}\textquotesingle{} \textquotesingle{} \textquotesingle{}

F\+I\+R\+ST It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in S\+T\+R\+I\+NG. Each element is assigned, in array element order, the starting position of each token in S\+T\+R\+I\+NG, in the order found. If a token has zero length, the starting position is equal to one if the token is at the beginning of S\+T\+R\+I\+NG, and one greater than the position of the preceding delimiter otherwise.

L\+A\+ST It is allocated with the lower bound equal to one and the upper bound equal to the number of tokens in S\+T\+R\+I\+NG. Each element is assigned, in array element order, the ending position of each token in S\+T\+R\+I\+NG, in the order found. If a token has zero length, the ending position is one less than the starting position.

P\+OS If B\+A\+CK is present with the value .T\+R\+UE., the value of P\+OS shall be in the range 0 $<$ P\+OS L\+EN (S\+T\+R\+I\+NG)+1; otherwise it shall be in the range 0 P\+OS L\+EN (S\+T\+R\+I\+NG).

If B\+A\+CK is absent or is present with the value .F\+A\+L\+SE., P\+OS is assigned the position of the leftmost token delimiter in S\+T\+R\+I\+NG whose position is greater than P\+OS, or if there is no such character, it is assigned a value one greater than the length of S\+T\+R\+I\+NG. This identifies a token with starting position one greater than the value of P\+OS on invocation, and ending position one less than the value of P\+OS on return.

If B\+A\+CK is present with the value true, P\+OS is assigned the position of the rightmost token delimiter in S\+T\+R\+I\+NG whose position is less than P\+OS, or if there is no such character, it is assigned the value zero. This identifies a token with ending position one less than the value of P\+OS on invocation, and starting position one greater than the value of P\+OS on return.

When S\+P\+L\+IT is invoked with a value for P\+OS of 1 $<$= P\+OS $<$= L\+E\+N(\+S\+T\+R\+I\+N\+G) and S\+T\+R\+I\+N\+G(\+P\+O\+S\+:\+P\+O\+S) is not a token delimiter present in S\+ET, the token identified by S\+P\+L\+IT does not comprise a complete token as described in the description of the S\+ET argument, but rather a partial token.

B\+A\+CK shall be a logical scalar. It is an I\+N\+T\+E\+NT (IN) argument. If P\+OS does not appear and B\+A\+CK is present with the value true, S\+T\+R\+I\+NG is scanned backwards for tokens starting from the end. If P\+OS does not appear and B\+A\+CK is absent or present with the value false, S\+T\+R\+I\+NG is scanned forwards for tokens starting from the beginning.\hypertarget{namespacem__strings_autotoc_md541}{}\doxysubsubsection{E\+X\+A\+M\+P\+L\+ES}\label{namespacem__strings_autotoc_md541}
Sample of uses

program demo\+\_\+sort2020 use M\+\_\+strings, only \+: \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} implicit none character(len=$\ast$),parameter \+:: gen=\textquotesingle{}($\ast$(\char`\"{}\mbox{[}\char`\"{},g0,\char`\"{}\mbox{]}\char`\"{}\+:,\char`\"{},\char`\"{}))\textquotesingle{}

! Execution of T\+O\+K\+EN form block character (len=\+:), allocatable \+:: string character (len=\+:), allocatable \+:: tokens(\+:) character (len=$\ast$),parameter \+:: set = \char`\"{} ,\char`\"{} string = \textquotesingle{}first,second,third\textquotesingle{} call split2020(string, set, tokens ) write($\ast$,gen)tokens

! assigns the value \mbox{[}\textquotesingle{}first \textquotesingle{},\textquotesingle{}second\textquotesingle{},\textquotesingle{}third \textquotesingle{} \mbox{]} ! to T\+O\+K\+E\+NS. endblock

! Execution of B\+O\+U\+N\+DS form

block character (len=\+:), allocatable \+:: string character (len=$\ast$),parameter \+:: set = \char`\"{} ,\char`\"{} integer, allocatable \+:: first(\+:), last(\+:) string = \textquotesingle{}first,second,,forth\textquotesingle{} call \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} (string, set, first, last) write($\ast$,gen)first write($\ast$,gen)last

! will assign the value \mbox{[} 1, 7, 14, 15 \mbox{]} to F\+I\+R\+ST, ! and the value \mbox{[} 5, 12, 13, 19 \mbox{]} to L\+A\+ST. endblock

! Execution of S\+T\+EP form block character (len=\+:), allocatable \+:: string character (len=$\ast$),parameter \+:: set = \char`\"{} ,\char`\"{} integer \+:: p, istart, iend string = \char`\"{} one,   last  example  \char`\"{} do while (p $<$ len(string)) istart = p + 1 call \mbox{\hyperlink{interfacem__strings_1_1split2020}{split2020}} (string, set, p) iend=p-\/1 if(iend.\+gt.\+istart)then print \textquotesingle{}(t3,a,1x,i0,1x,i0)\textquotesingle{}, string (istart\+:iend),istart,iend endif enddo endblock end program demo\+\_\+sort2020

Results\+:

\mbox{[}first \mbox{]},\mbox{[}second\mbox{]},\mbox{[}third \mbox{]} \mbox{[}1\mbox{]},\mbox{[}7\mbox{]},\mbox{[}14\mbox{]},\mbox{[}15\mbox{]} \mbox{[}5\mbox{]},\mbox{[}12\mbox{]},\mbox{[}13\mbox{]},\mbox{[}19\mbox{]} one 2 4 last 9 12 example 15 21

$>$ ??? option to skip adjacent delimiters (not return null tokens) common with whitespace $>$ ??? quoted strings, especially C\+SV both " and \textquotesingle{}, Fortran adjacent is insert versus other rules $>$ ??? escape character like \textbackslash{} $>$ ??? multi-\/character delimiters like \textbackslash{}n, \textbackslash{}t, $>$ ??? regular expression separator\hypertarget{namespacem__strings_autotoc_md542}{}\doxysubsubsection{A\+U\+T\+H\+OR}\label{namespacem__strings_autotoc_md542}
Milan Curcic, \char`\"{}milancurcic@hey.\+com\char`\"{}\hypertarget{namespacem__strings_autotoc_md543}{}\doxysubsubsection{L\+I\+C\+E\+N\+SE}\label{namespacem__strings_autotoc_md543}
M\+IT\hypertarget{namespacem__strings_autotoc_md544}{}\doxysubsubsection{V\+E\+R\+S\+I\+ON}\label{namespacem__strings_autotoc_md544}
version 0.\+1.\+0, copyright 2020, Milan Curcic 

The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/urbanjs/venus/\+V600/github/\+M\+\_\+strings/src/\mbox{\hyperlink{M__strings_8f90}{M\+\_\+strings.\+f90}}\end{DoxyCompactItemize}
