\hypertarget{interfacem__strings_1_1matchw}{}\doxysection{m\+\_\+strings\+::matchw Interface Reference}
\label{interfacem__strings_1_1matchw}\index{m\_strings::matchw@{m\_strings::matchw}}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
logical function \mbox{\hyperlink{interfacem__strings_1_1matchw_a14005bfeffb9a2b7aa87edc89953b424}{glob}} (tame, wild)
\end{DoxyCompactItemize}


\doxysubsection{Member Function/\+Subroutine Documentation}
\mbox{\Hypertarget{interfacem__strings_1_1matchw_a14005bfeffb9a2b7aa87edc89953b424}\label{interfacem__strings_1_1matchw_a14005bfeffb9a2b7aa87edc89953b424}} 
\index{m\_strings::matchw@{m\_strings::matchw}!glob@{glob}}
\index{glob@{glob}!m\_strings::matchw@{m\_strings::matchw}}
\doxysubsubsection{\texorpdfstring{glob()}{glob()}}
{\footnotesize\ttfamily logical function m\+\_\+strings\+::matchw\+::glob (\begin{DoxyParamCaption}\item[{character(len=$\ast$)}]{tame,  }\item[{character(len=$\ast$)}]{wild }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

\hypertarget{namespacem__strings_autotoc_md7}{}\doxysubsubsection{N\+A\+ME}\label{namespacem__strings_autotoc_md7}
glob(3f) -\/ \mbox{[}M\+\_\+strings\+:C\+O\+M\+P\+A\+RE\mbox{]} compare given string for match to a pattern which may contain globbing wildcard characters (L\+I\+C\+E\+N\+SE\+:PD)\hypertarget{namespacem__strings_autotoc_md8}{}\doxysubsubsection{S\+Y\+N\+O\+P\+S\+IS}\label{namespacem__strings_autotoc_md8}
\begin{DoxyVerb}logical function glob(string, pattern )

 character(len=*),intent(in) :: string
 character(len=*),intent(in) :: pattern
\end{DoxyVerb}
\hypertarget{namespacem__strings_autotoc_md9}{}\doxysubsubsection{D\+E\+S\+C\+R\+I\+P\+T\+I\+ON}\label{namespacem__strings_autotoc_md9}
glob(3f) compares given S\+T\+R\+I\+NG for match to P\+A\+T\+T\+E\+RN which may contain basic wildcard \char`\"{}globbing\char`\"{} characters.

In this version to get a match the entire string must be described by P\+A\+T\+T\+E\+RN. Trailing whitespace is significant, so trim the input string to have trailing whitespace ignored.\hypertarget{namespacem__strings_autotoc_md10}{}\doxysubsubsection{O\+P\+T\+I\+O\+NS}\label{namespacem__strings_autotoc_md10}
string the input string to test to see if it contains the pattern. pattern the following simple globbing options are available \begin{DoxyVerb}     o "?" matching any one character
     o "*" matching zero or more characters.
       Do NOT use adjacent asterisks.
     o Both strings may have trailing spaces which
       are ignored.
     o There is no escape character, so matching strings with
       literal question mark and asterisk is problematic.
\end{DoxyVerb}
\hypertarget{namespacem__strings_autotoc_md11}{}\doxysubsubsection{E\+X\+A\+M\+P\+L\+ES}\label{namespacem__strings_autotoc_md11}
Example program

program demo\+\_\+glob implicit none ! This main() routine passes a bunch of test strings ! into the above code. In performance comparison mode, ! it does that over and over. Otherwise, it does it just ! once. Either way, it outputs a passed/failed result. ! integer \+:: n\+Reps logical \+:: allpassed integer \+:: i allpassed = .true.

n\+Reps = 10000 ! Can choose as many repetitions as you\textquotesingle{}re expecting ! in the real world. n\+Reps = 1

do i=1,n\+Reps ! Cases with repeating character sequences. allpassed=allpassed .and. test(\char`\"{}a$\ast$abab\char`\"{}, \char`\"{}a$\ast$b\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}ab\char`\"{}, \char`\"{}$\ast$?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abc\char`\"{}, \char`\"{}$\ast$?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abcccd\char`\"{}, \char`\"{}$\ast$ccd\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}b\+Lah\char`\"{}, \char`\"{}b\+La\+H\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}mississippi\char`\"{}, \char`\"{}$\ast$sip$\ast$\char`\"{}, .true.) allpassed=allpassed .and. \& \& test(\char`\"{}xxxx$\ast$zzzzzzzzy$\ast$f\char`\"{}, \char`\"{}xxx$\ast$zzy$\ast$f\char`\"{}, .true.) allpassed=allpassed .and. \& \& test(\char`\"{}xxxx$\ast$zzzzzzzzy$\ast$f\char`\"{}, \char`\"{}xxxx$\ast$zzy$\ast$fffff\char`\"{}, .false.) allpassed=allpassed .and. \& \& test(\char`\"{}mississipissippi\char`\"{}, \char`\"{}$\ast$issip$\ast$ss$\ast$\char`\"{}, .true.) allpassed=allpassed .and. \& \& test(\char`\"{}xxxxzzzzzzzzyf\char`\"{}, \char`\"{}xxxx$\ast$zzy$\ast$fffff\char`\"{}, .false.) allpassed=allpassed .and. \& \& test(\char`\"{}xxxxzzzzzzzzyf\char`\"{}, \char`\"{}xxxx$\ast$zzy$\ast$f\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}xyxyxyzyxyz\char`\"{}, \char`\"{}xy$\ast$z$\ast$xyz\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}xyxyxyxyz\char`\"{}, \char`\"{}xy$\ast$xyz\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}mississippi\char`\"{}, \char`\"{}mi$\ast$sip$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}ababac\char`\"{}, \char`\"{}$\ast$abac$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}aaazz\char`\"{}, \char`\"{}a$\ast$zz$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}a12b12\char`\"{}, \char`\"{}$\ast$12$\ast$23\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}a12b12\char`\"{}, \char`\"{}a12b\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}a12b12\char`\"{}, \char`\"{}$\ast$12$\ast$12$\ast$\char`\"{}, .true.)

! Additional cases where the \textquotesingle{}$\ast$\textquotesingle{} char appears in the tame string. allpassed=allpassed .and. test(\char`\"{}$\ast$\char`\"{}, \char`\"{}$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}a$\ast$r\char`\"{}, \char`\"{}a$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}a$\ast$ar\char`\"{}, \char`\"{}a$\ast$aar\char`\"{}, .false.)

! More double wildcard scenarios. allpassed=allpassed .and. test(\char`\"{}\+X\+Y\+X\+Y\+X\+Y\+Z\+Y\+X\+Yz\char`\"{}, \char`\"{}\+X\+Y$\ast$\+Z$\ast$\+X\+Yz\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}missis\+S\+I\+Ppi\char`\"{}, \char`\"{}$\ast$\+S\+I\+P$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}mississip\+P\+I\char`\"{}, \char`\"{}$\ast$issip$\ast$\+P\+I\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}xyxyxyxyz\char`\"{}, \char`\"{}xy$\ast$xyz\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}mi\+Ssissippi\char`\"{}, \char`\"{}mi$\ast$sip$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}mi\+Ssissippi\char`\"{}, \char`\"{}mi$\ast$\+Sip$\ast$\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}ab\+Abac\char`\"{}, \char`\"{}$\ast$\+Abac$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}a\+Aazz\char`\"{}, \char`\"{}a$\ast$zz$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}\+A12b12\char`\"{}, \char`\"{}$\ast$12$\ast$23\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}a12\+B12\char`\"{}, \char`\"{}$\ast$12$\ast$12$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}o\+Wn\char`\"{}, \char`\"{}$\ast$o\+Wn$\ast$\char`\"{}, .true.)

! Completely tame (no wildcards) cases. allpassed=allpassed .and. test(\char`\"{}b\+Lah\char`\"{}, \char`\"{}b\+Lah\char`\"{}, .true.)

! Simple mixed wildcard tests suggested by I\+B\+Mer Marlin Deckert. allpassed=allpassed .and. test(\char`\"{}a\char`\"{}, \char`\"{}$\ast$?\char`\"{}, .true.)

! More mixed wildcard tests including coverage for false positives. allpassed=allpassed .and. test(\char`\"{}a\char`\"{}, \char`\"{}??\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}ab\char`\"{}, \char`\"{}?$\ast$?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}ab\char`\"{}, \char`\"{}$\ast$?$\ast$?$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abc\char`\"{}, \char`\"{}?$\ast$$\ast$?$\ast$?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abc\char`\"{}, \char`\"{}?$\ast$$\ast$?$\ast$\&?\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}abcd\char`\"{}, \char`\"{}?b$\ast$??\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abcd\char`\"{}, \char`\"{}?a$\ast$??\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}abcd\char`\"{}, \char`\"{}?$\ast$$\ast$?c?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}abcd\char`\"{}, \char`\"{}?$\ast$$\ast$?d?\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}abcde\char`\"{}, \char`\"{}?$\ast$b$\ast$?$\ast$d$\ast$?\char`\"{}, .true.)

! Single-\/character-\/match cases. allpassed=allpassed .and. test(\char`\"{}b\+Lah\char`\"{}, \char`\"{}b\+L?h\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}b\+Laaa\char`\"{}, \char`\"{}b\+La?\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}b\+Lah\char`\"{}, \char`\"{}b\+La?\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}b\+La\+H\char`\"{}, \char`\"{}?\+Lah\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}b\+La\+H\char`\"{}, \char`\"{}?\+La\+H\char`\"{}, .true.)

! Many-\/wildcard scenarios. allpassed=allpassed .and. test(\& \&\char`\"{}aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\&
      \&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\char`\"{},\& \&\char`\"{}a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$aa$\ast$aaa$\ast$a$\ast$a$\ast$b\char`\"{},\& \&.true.) allpassed=allpassed .and. test(\& \&\char`\"{}abababababababababababababababababababaacacacacacacac\&
      \&adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab\char`\"{},\& \&\char`\"{}$\ast$a$\ast$b$\ast$ba$\ast$ca$\ast$a$\ast$aa$\ast$aaa$\ast$fa$\ast$ga$\ast$b$\ast$\char`\"{},\& \&.true.) allpassed=allpassed .and. test(\& \&\char`\"{}abababababababababababababababababababaacacacacacaca\&
      \&cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab\char`\"{},\& \&\char`\"{}$\ast$a$\ast$b$\ast$ba$\ast$ca$\ast$a$\ast$x$\ast$aaa$\ast$fa$\ast$ga$\ast$b$\ast$\char`\"{},\& \&.false.) allpassed=allpassed .and. test(\& \&\char`\"{}abababababababababababababababababababaacacacacacacacad\&
      \&aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab\char`\"{},\& \&\char`\"{}$\ast$a$\ast$b$\ast$ba$\ast$ca$\ast$aaaa$\ast$fa$\ast$ga$\ast$gggg$\ast$b$\ast$\char`\"{},\& \&.false.) allpassed=allpassed .and. test(\& \&\char`\"{}abababababababababababababababababababaacacacacacacacad\&
      \&aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab\char`\"{},\& \&\char`\"{}$\ast$a$\ast$b$\ast$ba$\ast$ca$\ast$aaaa$\ast$fa$\ast$ga$\ast$ggg$\ast$b$\ast$\char`\"{},\& \&.true.) allpassed=allpassed .and. test(\char`\"{}aaabbaabbaab\char`\"{}, \char`\"{}$\ast$aabbaa$\ast$a$\ast$\char`\"{}, .true.) allpassed=allpassed .and. \& test(\char`\"{}a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$\char`\"{},\& \&\char`\"{}a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}aaaaaaaaaaaaaaaaa\char`\"{},\& \&\char`\"{}$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$\char`\"{}, .true.) allpassed=allpassed .and. test(\char`\"{}aaaaaaaaaaaaaaaa\char`\"{},\& \&\char`\"{}$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$a$\ast$\char`\"{}, .false.) allpassed=allpassed .and. test(\& \&\char`\"{}abc$\ast$abcd$\ast$abcde$\ast$abcdef$\ast$abcdefg$\ast$abcdefgh$\ast$abcdefghi$\ast$abcdefghij\&
      \&$\ast$abcdefghijk$\ast$abcdefghijkl$\ast$abcdefghijklm$\ast$abcdefghijklmn\char`\"{},\& \& \char`\"{}abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc\&
      \&$\ast$abc$\ast$abc$\ast$abc$\ast$\char`\"{},\& \&.false.) allpassed=allpassed .and. test(\& \&\char`\"{}abc$\ast$abcd$\ast$abcde$\ast$abcdef$\ast$abcdefg$\ast$abcdefgh$\ast$abcdefghi$\ast$abcdefghij\&
      \&$\ast$abcdefghijk$\ast$abcdefghijkl$\ast$abcdefghijklm$\ast$abcdefghijklmn\char`\"{},\& \&\char`\"{}abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$\char`\"{},\& \&.true.) allpassed=allpassed .and. test(\char`\"{}abc$\ast$abcd$\ast$abcd$\ast$abc$\ast$abcd\char`\"{},\& \&\char`\"{}abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc\char`\"{}, .false.) allpassed=allpassed .and. test( \char`\"{}abc$\ast$abcd$\ast$abcd$\ast$abc$\ast$abcd$\ast$abcd\&
      \&$\ast$abc$\ast$abcd$\ast$abc$\ast$abc$\ast$abcd\char`\"{}, \& \&\char`\"{}abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abc$\ast$abcd\char`\"{},\& \&.true.) allpassed=allpassed .and. test(\char`\"{}abc\char`\"{},\& \&\char`\"{}$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$a$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$c$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$\char`\"{}, .true.) allpassed=allpassed .and.\& \&test(\char`\"{}$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$a$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$c$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$\char`\"{}, \char`\"{}abc\char`\"{}, .false.) allpassed=allpassed .and. \& \&test(\char`\"{}abc\char`\"{}, \char`\"{}$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$a$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$b$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$\char`\"{}, .false.) allpassed=allpassed .and. test(\char`\"{}$\ast$abc$\ast$\char`\"{}, \char`\"{}$\ast$$\ast$$\ast$a$\ast$b$\ast$c$\ast$$\ast$$\ast$\char`\"{}, .true.)

! A case-\/insensitive algorithm test. ! allpassed=allpassed .and. test(\char`\"{}mississippi\char`\"{}, \char`\"{}$\ast$issip$\ast$\+P\+I\char`\"{}, .true.) enddo

if (allpassed)then write($\ast$,\textquotesingle{}(a)\textquotesingle{})\char`\"{}\+Passed\char`\"{},n\+Reps else write($\ast$,\textquotesingle{}(a)\textquotesingle{})\char`\"{}\+Failed\char`\"{} endif contains ! This is a test program for wildcard matching routines. ! It can be used either to test a single routine for correctness, ! or to compare the timings of two (or more) different wildcard ! matching routines. ! function test(tame, wild, b\+Expected\+Result) result(b\+Passed) use M\+\_\+strings, only \+: glob character(len=$\ast$) \+:: tame character(len=$\ast$) \+:: wild logical \+:: b\+Expected\+Result logical \+:: b\+Result logical \+:: b\+Passed b\+Result = .true. ! We\textquotesingle{}ll do \char`\"{}\&=\char`\"{} cumulative checking. b\+Passed = .false. ! Assume the worst. write($\ast$,$\ast$)repeat(\textquotesingle{}=\textquotesingle{},79) b\+Result = glob(tame, wild) ! Call a wildcard matching routine.

! To assist correctness checking, output the two strings in any ! failing scenarios. if (b\+Expected\+Result .eqv. b\+Result) then b\+Passed = .true. if(n\+Reps == 1) write($\ast$,$\ast$)\char`\"{}\+Passed match on \char`\"{},tame,\char`\"{} vs. \char`\"{}, wild else if(n\+Reps == 1) write($\ast$,$\ast$)\char`\"{}\+Failed match on \char`\"{},tame,\char`\"{} vs. \char`\"{}, wild endif

end function test end program demo\+\_\+glob

Expected output\hypertarget{namespacem__strings_autotoc_md12}{}\doxysubsubsection{A\+U\+T\+H\+OR}\label{namespacem__strings_autotoc_md12}
John S. Urban\hypertarget{namespacem__strings_autotoc_md13}{}\doxysubsubsection{R\+E\+F\+E\+R\+E\+N\+CE}\label{namespacem__strings_autotoc_md13}
The article \char`\"{}\+Matching Wildcards\+: An Empirical Way to Tame an Algorithm\char`\"{} in Dr Dobb\textquotesingle{}s Journal, By Kirk J. Krauss, October 07, 2014\hypertarget{namespacem__strings_autotoc_md14}{}\doxysubsubsection{L\+I\+C\+E\+N\+SE}\label{namespacem__strings_autotoc_md14}
Public Domain 

The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/urbanjs/venus/\+V600/github/\+M\+\_\+strings/src/\mbox{\hyperlink{M__strings_8f90}{M\+\_\+strings.\+f90}}\end{DoxyCompactItemize}
